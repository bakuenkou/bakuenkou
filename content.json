{"meta":{"title":"Baku加油站","subtitle":"","description":"力学如力耕，勤惰尔自知。但使书种多，会有岁稔时","author":"Baku","url":"https://bakuenkou.gitee.io","root":"/"},"pages":[{"title":"about","date":"2023-10-29T18:34:08.140Z","updated":"2023-10-29T18:34:08.140Z","comments":true,"path":"about/index.html","permalink":"https://bakuenkou.gitee.io/about/index.html","excerpt":"","text":"About this blogI will often share simple and fun articles on my blog, even if no one reads them, haha! About Me I work in a famous industrial Internet company in China as an embedded software development engineer. I am good at Linux and FreeRTOS software development, and have rich experience in the development of soft PLC and automation control products. Familiar with the whole process of software development, testing and mass production. If you don’t understand the content of this article or want to cooperate with me, please feel free to contact me. My Email : &#x6d;&#97;&#x69;&#x79;&#97;&#110;&#104;&#x61;&#111;&#46;&#109;&#121;&#104;&#64;&#x66;&#x6f;&#120;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;"},{"title":"所有标签","date":"2023-10-29T18:08:27.103Z","updated":"2023-10-29T18:08:27.103Z","comments":true,"path":"tags/index.html","permalink":"https://bakuenkou.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-10-29T18:23:29.088Z","updated":"2023-10-29T18:23:29.088Z","comments":true,"path":"mylist/index.html","permalink":"https://bakuenkou.gitee.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-10-29T18:15:06.481Z","updated":"2023-10-29T18:15:06.481Z","comments":true,"path":"categories/index.html","permalink":"https://bakuenkou.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【CodeSys】添加自己的代码库","slug":"【CodeSys】添加自己代码库","date":"2023-10-29T16:00:00.000Z","updated":"2023-10-31T14:20:32.933Z","comments":true,"path":"2023/10/30/【CodeSys】添加自己代码库/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/30/%E3%80%90CodeSys%E3%80%91%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E4%BB%A3%E7%A0%81%E5%BA%93/","excerpt":"","text":"测试第一个程序测试之前提几点： runtime还未适配刷flash的功能，所以IDE无法把程序刷到板子中，只能把程序加载到RAM中运行。IDE让程序在RAM中跑需要设置一下：Derive-&gt;属性-&gt;启动应用-&gt;取消勾选下载时隐式创建启动应用，让IDE不下载到Flash。 sysdefines.h中的&#123;&quot;CmpAppEmbedded&quot;, &quot;Bootproject.RunInFlash&quot;, 0&#125;, \\,0则是板子上电在Ram跑、1到Flash跑。 测试程序还需要更改一下Runtime源码中的RAM位置，设置了才能让IDE把程序放到正确的RAM中运行。 使用串口扫描成功设备后，可以在IDE中编写一个简单的程序，比如让某个值++，然后刷程序，进行Debug。这个IDE界面还是比较简单的不放图了。 添加自己代码库（Code Lib） IDE新建Lib工程，选择CODESYS Lib。 删除工程中的库管理器和、xxx。新建POU对象。 在POU中添加变量。 编译-&gt;生成运行时系统文件。为code提供接口。 随后在\\Templates\\复制一个CmpTemplateEmpty模板。把名字全部替换成自己的lib名字。替换生成运行时系统文件中的m4文件到新模板。把myhLibDep.m4、myhLibDep_m4.bat、myhLibItf_m4.bat文件里面的名字也要修改成自己的lib名字。 完成上面步骤后,运行bat文件生成myhLibItf.h、myhLibDep.h、myhLib.c。把这三个文件放到自己的工程中。 修改组件宏头文件，添加int myhLib__Entry(INIT_STRUCT *pInitStruct); \\、&#123;&quot;myhLib&quot;, myhLib__Entry, 0&#125;, \\。c组件宏头文件指的是【CodeSys】移植Runtime中的 myProject.h 和 myProject_Notlmpl.h 把生成运行时系统文件中的.c文件里面的函数复制添加到自己工程中的myhLib.c中。 在函数中调用p指针访问接口，实现自己的算法！！ done 测试代码库和上面测试同理，IDE编写代码，调用代码库的接口。Debug看看值是否变化~","categories":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/categories/CodeSys/"}],"tags":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/tags/CodeSys/"}]},{"title":"【CodeSys】适配串口驱动","slug":"【CodeSys】适配串口驱动","date":"2023-10-28T16:00:00.000Z","updated":"2023-10-29T18:25:15.023Z","comments":true,"path":"2023/10/29/【CodeSys】适配串口驱动/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/29/%E3%80%90CodeSys%E3%80%91%E9%80%82%E9%85%8D%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"适配时间组件 (SysTime)适配SysTimeOS.c的下列函数，为codesys提供系统ms、us的tick。可以参考代码中的例子。 RTS_UI32 CDECL SysTimeGetMs(void)， RTS_RESULT CDECL SysTimeGetUs(RTS_SYSTIME* pTime) 毫秒：如果是HAL库，可以使用HAL_GetTick()实现毫秒；如果是ST&#x2F;GD标准库，需要自己实现函数，获取滴答定时器计数值。 微秒：都需要自行实现函数，获取tick时钟的计数值，计算出微秒。 123456// 举例---系统时钟使用的TIMER2，定时器period=1000,uint32_t getSysTickUs(uint32_t us)&#123; return TIMER_CNT(TIMER2); // return __HAL_TIM_GET_COUNTER(&amp;TIM2_Handler)&#125; 适配串行接口 (SysCom)首先确保程序中的串口驱动正常，串口接收的数据使用环形队列存储起来。随后实现SysComOS.c中的函数，为codesys提供串口读写接口。 RTS_UI32 CDECL SysComRead(RTS_HANDLE hCom, unsigned char *pbyBuffer, RTS_UI32 uiSize, RTS_UI32 ulTimeout, RTS_RESULT *pResult). RTS_UI32 CDECL SysComWrite(RTS_HANDLE hCom, unsigned char *pbyBuffer, RTS_UI32 uiSize, RTS_UI32 ulTimeout, RTS_RESULT *pResult). 到此即可烧录程序到板子了，先使用串口调试工具，查看板子Runtime是否会定期发送内容到调试工具。若成功即可下一步。 配置CodeSys网关 安装xml，IDE: 工具-&gt;设备存储库-&gt;安装-&gt;XXXXX-Cortex-embedded.devdesc。 新建工程，选择标准工程，选择Device（上面安装的）。 点击工程的Device，网关-&gt;配置本地网关-&gt;输入COM端口-&gt;选择波特率-&gt;ok。 扫描网络，若串口ok的话，会扫描到从站设备。 BUG适配SysCom时发现一个BUG，经过定位找到是armcc和gcc之间宽字符类型差别引起的。Runtime中的RTS_WCHAR是2个字节的。GCC工程中的RTS_WCHAR是4个字节的。若不修改，串口发出来的数据每个字节都会多两个&#x2F;0。修改方式如下，在合适位置添加以下宏： 1234# ifndef RTS_WCHAR_DEFINED# define RTS_WCHAR_DEFINED typedef unsigned short RTS_WCHAR; /* wide character value. We expect 2 bytes unicode here! */# endif /*RTS_WCHAR_DEFINED*/","categories":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/categories/CodeSys/"}],"tags":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/tags/CodeSys/"}]},{"title":"【CodeSys】移植Runtime","slug":"【CodeSys】移植Runtime","date":"2023-10-27T16:00:00.000Z","updated":"2023-10-29T18:25:27.677Z","comments":true,"path":"2023/10/28/【CodeSys】移植Runtime/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/28/%E3%80%90CodeSys%E3%80%91%E7%A7%BB%E6%A4%8DRuntime/","excerpt":"","text":"本节内容为移植CodeSys Runtime源码到Cotex-m7平台的记录，开发环境为STM32CubeIDE（Version：1.10.0）。 使用 RtsConfigurator 配置runtime组件使用codesys开发源码包的 RtsConfigurator 软件配置runtime组件。目录：\\Tools\\RtsConfigurator\\Bin。打开软件后，会弹出以下窗口，让我们导入组件。 加载组件，导入开发包中的Components. 加载系统相关，导入开发包中的Platforms\\SysTemplates和Platforms\\SysTemplates\\Sys. 添加操作系统前缀，可以默认使用OS，也可以自定义 勾选需要移植的组件 12345678910111213141516171819202122232425262728293031323334CmpAppEmbeddedCmpBinTagUtilCmpBlkDrvComCmpChannelMgrEmbeddedCmpChannelServerEmbeddedCmpChecksumCmpCommunicationLibCmpDeviceCmpEventMgrCmpIecTaskCmpIoMgrEmbeddedCmpLogEmbeddedCmpMemPoolCmpMonitorCmpNameServiceServerCmpRetainCmpRouterEmbeddedCmpScheduleEmbeddedCmpSettingsEmbeddedCmpSrvSysComSysCpuHandlingSysExceptSysFileFlashSysFlashSysInternalLibSysMemSysTargetSysTime//以上是必须勾选的基本组件，以下是拓展，比如UDP和FreeRTOSCmpBlkDrvUdpSysSocketSysTaskSysEvent 消除RtsConfigurator的警告 如果前面设置系统后缀是OS，则无警告。 如果是自定义的后缀，需要去\\Platforms\\SysTemplates\\Sys目录修改对应文件的名字。例如SysTaskOS -&gt; SysTaskXXXX. 消除后，点击Output-&gt; All output files,输出工程文件。输出如下： 生成的include和soures中就是组件的代码和头文件，myProject.h、myProject_Notlmpl.h是组件选择是否开启的宏。如果后续需要添加自己的代码库或者添加新组件都需要修改这里面的宏。 移植到工程代码。 移植RtsConfigurator生成的include和soures代码到自己工程，复制myProject.h、myProject_Notlmpl.h添加到include。 替换添加文件：替换工程中的sysdefines.h、sysspecific.h、SysCpuHandlingOS.c文件，添加callonstackASM.s、SysCpuHandlingArm_Cortex.s到soures目录，添加CmpErrors.h到include。 修改添加文件的头文件：sysdefines.h中的头文件改成自己工程对应的头文件,我的如下： 12#include &quot;myProject.h&quot;#include &quot;myProject_NotImpl.h&quot; 修改mainOS中的include：#include &quot;myPlatform.h -&gt; #include &quot;myProject.h&quot;。此处的OS是后缀，前面自定义的。 修改mainOS中的main()函数，修改成int codesysMain(void)，参考以下函数内容改代码。 123456789// mian函数的最小运行版本int codesysMain() &#123; RTS_RESULT Result; Result = CMInit(NULL, s_ComponentList); while(!s_bExitLoop) &#123; CMCallHook( CH_COMM_CYCLE, 0, 0, FALSE); &#125; return 0;&#125; 添加系统调度相关文件：CMConvToStr.c、CMEmbedded.c. 把codesysMain添加到自己程序的main函数中，运行时候即可运行codesys，此处实现的是的裸机跑CodeSys，多任务后面在讲。 &gt;以上替换的几个.h .c .s和调度相关的文件，需要找CodeSys公司要。 解决工程的ERROR移植过程可能会出现一些编译器版本造成的error，例如下面。 armcc和gcc版本造成的汇编语法不同，修改callonstackASM.s、SysCpuHandlingArm_Cortex.s文件的汇编代码。替换成gcc适配的（因为我使用的是STM32CubeIDE，若使用Keil MDK可能不会有此问题）。解决举例：123456789101112131415161718//原来的 PRESERVE8 AREA CALLONSTACK, CODE, READONLY THUMB EXPORT callonstackcallonstack ldr r5, [sp, #+0] push &#123; lr &#125; push &#123; r3-r7&#125; mov r3, r0 mov r0, r1 mov sp, r2 BX r3 pop &#123; r3-r7 &#125; mov sp, r5 pop &#123; pc &#125; END 123456789101112131415//修改好的.text.global callonstackcallonstack: ldr r5, [sp, #0] push &#123;lr&#125; push &#123;r3-r7&#125; mov r3, r0 mov r0, r1 mov sp, r2 bx r3 pop &#123;r3-r7&#125; mov sp, r5 pop &#123;pc&#125; 可能还会出现其他奇怪报错，自行解决。 Debug解决工程报错后，组件的移植即完毕了，可以Debug测试一下，是否能进入CMCallHook()函数进行循环。ok的话即可进入适配工作。 添加license(随意，不添加则只能运行2小时) 复制3S.bat到\\Tools\\ConvertFileToArray\\Bin ConvertFileToArray.exe运行&#96;3S.bat，生成3S.txt 复制license到工程中的sysdefines.h文件内. 1234567#define LICENSEFILE_DAT &#123;\\0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\\0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\\0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\\0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\\0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX\\&#125;","categories":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/categories/CodeSys/"}],"tags":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/tags/CodeSys/"}]},{"title":"【Tool】clang-format代码格式化工具","slug":"【Tool】clang-format代码格式化工具","date":"2023-10-23T16:00:00.000Z","updated":"2023-10-29T18:26:28.976Z","comments":true,"path":"2023/10/24/【Tool】clang-format代码格式化工具/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/24/%E3%80%90Tool%E3%80%91clang-format%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"","text":"clang-format有什么用？clang-format是一个由Clang项目提供的工具，用于对C、C++、Objective-C和Objective-C++代码进行格式化。它可以根据预定义的样式或用户自定义的样式规则，自动调整代码的缩进、空格、换行等格式，以提高代码的可读性和一致性。通过使用clang-format，您可以避免手动进行代码格式化的繁琐过程，节省时间和精力。它可以应用于单个文件或整个代码库，并且可以与各种编辑器和集成开发环境（IDE）集成，例如Visual Studio Code、Xcode、Eclipse等。clang-format提供了多个预定义的代码样式选项，例如Google、LLVM、WebKit等。此外，还可以通过.clang-format文件或命令行参数自定义样式规则，以满足个人或项目的需求。总而言之，可帮助开发人员在编写C、C++、Objective-C和Objective-C++代码时保持一致的代码风格，并提高代码的可读性和可维护性。 Use clang-format (windows)使用VsCode插件使用，需安装以下插件： Clang-Format C&#x2F;C++ Extension Pack 安装完毕后设置clang目录。我的目录在C:\\Users\\16097\\.vscode\\extensions\\ms-vscode.cpptools-1.17.5-win32-x64\\LLVM\\bin\\clang-format.exe,各位可根据自己的vscode安装插件的位置寻找。 编写.clang-format然后在工程目录下编写.clang-format文件，用于配置格式化的规则。 以下是我自己的配置，仅供参考，可自行去官网查询如何设置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149---Language: Cpp# BasedOnStyle: LLVMAccessModifierOffset: -4AlignAfterOpenBracket: AlignAlignConsecutiveMacros: trueAlignConsecutiveAssignments: trueAlignConsecutiveBitFields: trueAlignConsecutiveDeclarations: trueAlignEscapedNewlines: RightAlignOperands: AlignAlignTrailingComments: trueAlignArrayOfStructures: LeftAllowAllArgumentsOnNextLine: trueAllowAllConstructorInitializersOnNextLine: trueAllowAllParametersOfDeclarationOnNextLine: trueAllowShortEnumsOnASingleLine: trueAllowShortBlocksOnASingleLine: NeverAllowShortCaseLabelsOnASingleLine: falseAllowShortFunctionsOnASingleLine: falseAllowShortLambdasOnASingleLine: AllAllowShortIfStatementsOnASingleLine: NeverAllowShortLoopsOnASingleLine: falseAlwaysBreakAfterDefinitionReturnType: NoneAlwaysBreakAfterReturnType: NoneAlwaysBreakBeforeMultilineStrings: falseAlwaysBreakTemplateDeclarations: MultiLineBinPackArguments: trueBinPackParameters: trueBraceWrapping: AfterCaseLabel: false AfterClass: false AfterControlStatement: Never AfterEnum: false AfterFunction: false AfterNamespace: false AfterObjCDeclaration: false AfterStruct: false AfterUnion: false AfterExternBlock: false BeforeCatch: false BeforeElse: false BeforeLambdaBody: false BeforeWhile: false IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: trueBreakBeforeBinaryOperators: NoneBreakBeforeBraces: AllmanBreakBeforeInheritanceComma: falseBreakInheritanceList: BeforeColonBreakBeforeTernaryOperators: trueBreakConstructorInitializersBeforeComma: falseBreakConstructorInitializers: BeforeColonBreakAfterJavaFieldAnnotations: falseBreakStringLiterals: trueColumnLimit: 120CommentPragmas: &#x27;^ IWYU pragma:&#x27;CompactNamespaces: falseConstructorInitializerAllOnOneLineOrOnePerLine: falseConstructorInitializerIndentWidth: 4ContinuationIndentWidth: 4Cpp11BracedListStyle: trueDeriveLineEnding: trueDerivePointerAlignment: falseDisableFormat: falseExperimentalAutoDetectBinPacking: falseFixNamespaceComments: trueForEachMacros: - foreach - Q_FOREACH - BOOST_FOREACHIncludeBlocks: PreserveIncludeCategories: - Regex: &#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27; Priority: 2 SortPriority: 0 - Regex: &#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27; Priority: 3 SortPriority: 0 - Regex: &#x27;.*&#x27; Priority: 1 SortPriority: 0IncludeIsMainRegex: &#x27;(Test)?$&#x27;IncludeIsMainSourceRegex: &#x27;&#x27;IndentCaseLabels: trueIndentCaseBlocks: falseIndentGotoLabels: trueIndentPPDirectives: NoneIndentExternBlock: AfterExternBlockIndentWidth: 4IndentWrappedFunctionNames: falseInsertTrailingCommas: NoneJavaScriptQuotes: LeaveJavaScriptWrapImports: trueKeepEmptyLinesAtTheStartOfBlocks: trueMacroBlockBegin: &#x27;&#x27;MacroBlockEnd: &#x27;&#x27;MaxEmptyLinesToKeep: 1NamespaceIndentation: NoneObjCBinPackProtocolList: AutoObjCBlockIndentWidth: 2ObjCBreakBeforeNestedBlockParam: trueObjCSpaceAfterProperty: falseObjCSpaceBeforeProtocolList: truePenaltyBreakAssignment: 2PenaltyBreakBeforeFirstCallParameter: 19PenaltyBreakComment: 300PenaltyBreakFirstLessLess: 120PenaltyBreakString: 1000PenaltyBreakTemplateDeclaration: 10PenaltyExcessCharacter: 1000000PenaltyReturnTypeOnItsOwnLine: 60PointerAlignment: RightReflowComments: trueSortIncludes: trueSortUsingDeclarations: trueSpaceAfterCStyleCast: falseSpaceAfterLogicalNot: falseSpaceAfterTemplateKeyword: trueSpaceBeforeAssignmentOperators: trueSpaceBeforeCpp11BracedList: falseSpaceBeforeCtorInitializerColon: trueSpaceBeforeInheritanceColon: trueSpaceBeforeParens: ControlStatementsSpaceBeforeRangeBasedForLoopColon: trueSpaceInEmptyBlock: falseSpaceInEmptyParentheses: falseSpacesBeforeTrailingComments: 1SpacesInAngles: falseSpacesInConditionalStatement: falseSpacesInContainerLiterals: trueSpacesInCStyleCastParentheses: falseSpacesInParentheses: falseSpacesInSquareBrackets: falseSpaceBeforeSquareBrackets: falseStandard: LatestStatementMacros: - Q_UNUSED - QT_REQUIRE_VERSIONTabWidth: 4UseCRLF: falseUseTab: NeverWhitespaceSensitiveMacros: - STRINGIZE - PP_STRINGIZE - BOOST_PP_STRINGIZE... 格式化代码 使用Vscode快捷键(手动格式化)Shift+Alt+F 自动格式化 VsCode设置搜索clang，勾选后下图处，保存文件会自动格式化代码，需要的话可自行开启。 Use clang-format (linux) 安装clang与llvm：sudo apt-get install clang llvm 编写.clang-format可以选择使用默认的Clang样式或创建自定义的.clang-format文件。然后将其置于代码库的根目录中以应用于整个代码库。可以使用以下命令在当前目录生成一个.clang-format文件：clang-format -style=llvm -dump-config &gt; .clang-formatclang-format -style=google -dump-config &gt; .clang-format或者直接复制上面的~ 格式化代码 命令行 clang-format -i &lt;filename&gt; 或集成开发环境（IDE）：clang-format可通过命令行或与许多常见编辑器和IDE集成使用。例如vscode。","categories":[{"name":"Tool","slug":"Tool","permalink":"https://bakuenkou.gitee.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://bakuenkou.gitee.io/tags/tool/"}]},{"title":"【Tool】Static Analysis Tool (CppCheck)","slug":"【Tool】Static Analysis Tool (CppCheck)","date":"2023-10-22T16:00:00.000Z","updated":"2023-10-29T18:26:34.398Z","comments":true,"path":"2023/10/23/【Tool】Static Analysis Tool (CppCheck)/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/23/%E3%80%90Tool%E3%80%91Static%20Analysis%20Tool%20(CppCheck)/","excerpt":"","text":"CppCheck有什么用？CppCheck是一个开源的静态代码分析工具，用于C和C++代码的错误检查。它的主要目的是检测编程错误和未被其他编译器警告捕获的潜在问题。以下是CppCheck的主要用途和特点： 错误检测：CppCheck可以识别很多常见的C&#x2F;C++编程错误，如数组越界、未初始化的变量、内存泄漏等。 可扩展性：用户可以编写自己的检查规则，使其适应特定的编码风格或项目要求。 不依赖于特定的编译器：这意味着你可以在任何系统上使用CppCheck，不管你使用的是哪种编译器。 命令行工具：它可以轻松地集成到持续集成系统和其他自动化构建流程中。 支持GUI：除了命令行工具，CppCheck还提供了一个图形用户界面，使其使用更为方便。 无假阳性的目标：尽管在实践中完全实现这一目标是非常困难的，但CppCheck的设计目标是尽量减少假阳性（即误报为错误的正确代码）。 性能：与其他静态分析工具相比，CppCheck通常更快。 这玩意可以帮助开发者提前发现和修复潜在的代码问题，但是，静态代码分析工具并不是万能的，它不能替代其他测试和质量保证方法，可以作为软件开发过程中的一个有价值的工具。 Use CppCheck (windows) 下载地址：https://sourceforge.net/projects/cppcheck/files/cppcheck/2.12/ 下载安装后，打开软件，点击分析，选择需要检查的文件或目录即可。（必须英文目录） 分析完成后，点击即可查看，若有错误警告都会显示，此处实例无警告和错误~ Use CppCheck (linux) 安装：sudo apt install cppcheck 基本用法： 扫描单个文件：cppcheck yourfile.cpp 扫描目录：cppcheck your_directory/ 详细输出：cppcheck --enable=all yourfile.cpp 输出到文件： cppcheck yourfile.cpp --output-file=output.txt cppcheck yourfile.cpp &gt; output.txt 检查所有配置：cppcheck --force yourfile.cpp 为C&#x2F;C++指定不同标准：cppcheck --std=c11 --std=c++11 yourfile.cpp 其他请查看help：cppcheck --help 例如执行cppcheck 99-carController/ --output-file=output.txt --force --enable=all后输出了output.txt。 常见警告和其意义 [style]: 表示代码风格建议，例如未使用的变量。 [error]: 表示可能的错误，例如空指针解引用。 [warning]: 表示可能的逻辑或运行时问题。 [performance]: 表示可能影响程序性能的代码。 [portability]: 表示可能在不同编译器或平台上导致问题的代码。 [information]: 提供有关代码或其结构的一般信息","categories":[{"name":"Tool","slug":"Tool","permalink":"https://bakuenkou.gitee.io/categories/Tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://bakuenkou.gitee.io/tags/tool/"}]},{"title":"【Life】周末の青山湖","slug":"【Life】周末の青山湖","date":"2023-10-20T16:00:00.000Z","updated":"2023-10-30T05:45:20.202Z","comments":true,"path":"2023/10/21/【Life】周末の青山湖/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/21/%E3%80%90Life%E3%80%91%E5%91%A8%E6%9C%AB%E3%81%AE%E9%9D%92%E5%B1%B1%E6%B9%96/","excerpt":"","text":"周末闲得无事，想起正值秋天。青山湖最美不过秋冬时节，即刻驱车前往青山湖哈哈哈 周末青山湖人特别多，某的路人挤人QAQ，忙完双十一，我定要请个年假工作日来划船！~ 虽说人很多， 但真的太美了。还有人在拍婚纱。 游客的话门票40，如果买了杭州市民卡的文旅卡的话可以免费进入。文旅卡需要提前买，购买两个小时后才能激活。","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【RK3568】使用MPP采集USB摄像头数据","slug":"【RK3568】使用MMP采集USB摄像头数据","date":"2023-10-05T16:00:00.000Z","updated":"2023-10-29T18:26:23.959Z","comments":true,"path":"2023/10/06/【RK3568】使用MMP采集USB摄像头数据/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/06/%E3%80%90RK3568%E3%80%91%E4%BD%BF%E7%94%A8MMP%E9%87%87%E9%9B%86USB%E6%91%84%E5%83%8F%E5%A4%B4%E6%95%B0%E6%8D%AE/","excerpt":"","text":"MPP简介瑞芯微提供的媒体处理软件平台（Media Process Platform，简称 MPP）是适用于瑞芯微芯片系列的通用媒体处理软件平台。该平台对应用软件屏蔽了芯片相关的复杂底层处理，其目的是为了屏蔽不同芯片的差异，为使用者提供统一的视频媒体处理接口（Media Process Interface，缩写 MPI）。MPP提供的功能包括： 视频解码：H.265 &#x2F; H.264 &#x2F; H.263 &#x2F; VP9 &#x2F; VP8 &#x2F; MPEG-4 &#x2F; MPEG-2 &#x2F; MPEG-1 &#x2F; VC1 &#x2F; MJPEG 视频编码：H.264 &#x2F; VP8 &#x2F; MJPEG 视频处理：视频拷贝，缩放，色彩空间转换，场视频解交织（Deinterlace） MPP在RK的系统架构层次 硬件层Hardware： 硬件层是瑞芯微系列芯片平台的视频编解码硬件加速模块，包括 VPU，rkvdec，rkvenc 等不同类型，不同功能的硬件加速器。 内核驱动层： Linux 内核的编码器硬件设备驱动，以及相关的 mmu，内存，时钟，电源管理模块等。支持的平台主要是 Linux kernel 3.10 和 4.4 两个版本。MPP 库对于内核驱动有依赖。 MMP层： 用户态的 MPP 层屏蔽了不同操作系统和不同芯片平台的差异，为上层使用者提供统一的 MPI 接口。MPP 层包括 MPI 模块，OSAL 模块，HAL 模块以及视频编解码器（Video Decoder &#x2F; Video Encoder）和视频处理功能模块（Video Process）。 操作系统层： MPP 用户态的运行平台，如 Android 以及 Debian 等 Linux 发行版。 应用层： MPP 层通过 MPI 对接各种中间件软件，如 OpenMax，ffmpeg 和 gstreamer，或者直接对接客户的上层应用。 MPP库编译与测试下载源码：MPP 源代码发布官方地址：https://github.com/rockchip-linux/mpp 编译：MPP 源代码编译脚本为 cmake，需要依赖 2.8.12 以上的版本，建议使用 2.8.12 版，使用高版本的 cmake工具可能会产生较多的 warning。 交叉编译：Linux环境，先配置 build&#x2F;linux&#x2F;aarch64&#x2F;目录下 arm.linux.cross.cmake 文件里的工具链，再运行 make-Makefiles.bash 脚本通过 cmake 生成 Makefile，最后运行 make –j20 进行编译。 此处我是先把mpp源码放在ubuntu中使用交叉编译编译完成，再把代码传到板子中，也可以选择把mmp源码放进buildroot中，通过编译rootfs，再放在到板子。 编译完成后，进入test目录，可见一些测试文件。 测试和使用：传输到开发板中，后运行.&#x2F;mpp_info_test，测试程序输出打印在&#x2F;var&#x2F;log&#x2F;目录下，cat syslog或者cat messages。打印的信息提供了有关 MPP 库版本和其历史的重要信息，以及与不同版本之间的兼容性改进相关的详细信息。 1234567891011121314151617mpp_info_test: normal version log:mpp_info: mpp version: 188dfb5d author: Herman Chen 2022-06-1mpp_info_test: history version log:mpp_info: mpp version history 10:mpp_info: 188dfb5d author: Herman Chen 2022-06-17 [mpp_enc]: -gen-rkr3, tag: m/master, atk/master)mpp_info: 2da4ad7b author: sayon.chen 2022-06-16 [vepu580]:mpp_info: 6304f44f author: sayon.chen 2022-06-16 [rkv_dec]:mpp_info: b05ba20d author: sayon.chen 2022-06-16 [mpp_frame]mpp_info: 3e6ff53b author: sayon.chen 2022-06-15 [mpp_enc]:mpp_info: 7c340c88 author: Hongjin Li 2022-06-15 [mpp_dec]:mpp_info: a053db72 author: sayon.chen 2022-06-15 [h265e]: Fimpp_info: ec1f93f1 author: xueman.ruan 2022-06-15 [h265d_parsmpp_info: dd284cc8 author: Herman Chen 2022-06-14 [cmake]: Sempp_info: 67536321 author: Herman Chen 2022-06-14 [test]: Addmpp_compat: id| name -- mpp compat infompp_compat: 0 | increase decoder fbc buffer sizempp_compat: 1 | support encoder async input mode 解码测试：运行.&#x2F;mpi_dec_test，通过查看输出日志，了解参数说明 123456789101112131415161718192021222324252627mpi_dec_utils: usage: ./mpi_dec_test [options]mpi_dec_utils: -i input_file input bitstream filempi_dec_utils: -o output_file output decoded frame filempi_dec_utils: -w width the width of input bitstreammpi_dec_utils: -h height the height of input bitstreammpi_dec_utils: -t type input stream coding typempi_dec_utils: -f format output frame format typempi_dec_utils: -n frame_number max output frame numbermpi_dec_utils: -s instance_nb number of instancesmpi_dec_utils: -v trace option q - quiet f - show fpsmpi_dec_utils: -slt slt file slt verify data filempi_dec_utils: -help help show helpmpi: type: dec id 0 coding: mpeg2 id 2mpi: type: dec id 0 coding: mpeg4 id 4mpi: type: dec id 0 coding: h.263 id 3mpi: type: dec id 0 coding: h.264/AVC id 7mpi: type: dec id 0 coding: h.265/HEVC id 16777220mpi: type: dec id 0 coding: vp8 id 9mpi: type: dec id 0 coding: VP9 id 10mpi: type: dec id 0 coding: avs+ id 16777221mpi: type: dec id 0 coding: jpeg id 8mpi: type: dec id 0 coding: av1 id 16777224mpi: type: enc id 1 coding: h.264/AVC id 7mpi: type: enc id 1 coding: jpeg id 8mpi: type: enc id 1 coding: h265 id 16777220mpi: type: enc id 1 coding: vp8 id 9 随后运行.&#x2F;mpi_dec_test 加上各种参数即可实现解码视频。 编码测试：同上，运行.&#x2F;mpi_enc_test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960mpi_enc_utils: usage: ./mpi_enc_test [options]mpi_enc_utils: -i input_file input frame file mpi_enc_utils: -o output_file output encoded bitstream file mpi_enc_utils: -w width the width of input picture mpi_enc_utils: -h height the height of input picture mpi_enc_utils: -hstride hor_stride the horizontal stride of input picturempi_enc_utils: -vstride ver_stride the vertical stride of input picture mpi_enc_utils: -f format the format of input picture mpi_enc_utils: -t type output stream coding type mpi_enc_utils: -tsrc source type input file source coding type mpi_enc_utils: -n max frame number max encoding frame number mpi_enc_utils: -g gop reference mode gop_mode:gop_len:vi_len mpi_enc_utils: -rc rate control mode set rc_mode mpi_enc_utils: -bps bps target:min:max set tareget/min/max bps and rc_mode mpi_enc_utils: -fps in/output fps set input and output frame rate mpi_enc_utils: -qc quality control set qp_init/min/max/min_i/max_i mpi_enc_utils: -s instance_nb number of instances mpi_enc_utils: -v trace option q - quiet f - show fps mpi_enc_utils: -l loop count loop encoding times for each frame mpi_enc_utils: -ini ini file encoder extra ini config file mpi_enc_utils: -slt slt file slt verify data file mpi: mpp coding type support list:mpi: type: dec id 0 coding: mpeg2 id 2mpi: type: dec id 0 coding: mpeg4 id 4mpi: type: dec id 0 coding: h.263 id 3mpi: type: dec id 0 coding: h.264/AVC id 7mpi: type: dec id 0 coding: h.265/HEVC id 16777220mpi: type: dec id 0 coding: vp8 id 9mpi: type: dec id 0 coding: VP9 id 10mpi: type: dec id 0 coding: avs+ id 16777221mpi: type: dec id 0 coding: jpeg id 8mpi: type: dec id 0 coding: av1 id 16777224mpi: type: enc id 1 coding: h.264/AVC id 7mpi: type: enc id 1 coding: jpeg id 8mpi: type: enc id 1 coding: h265 id 16777220mpi: type: enc id 1 coding: vp8 id 9mpi: mpp color support list:mpi: color: id 0 0x00000 YUV420SP, NV12mpi: color: id 1 0x00001 YUV420SP-10bitmpi: color: id 2 0x00002 YUV422SP, NV24mpi: color: id 3 0x00003 YUV422SP-10bitmpi: color: id 4 0x00004 YUV420P, I420mpi: color: id 5 0x00005 YUV420SP, NV21mpi: color: id 6 0x00006 YUV422P, 422Pmpi: color: id 7 0x00007 YUV422SP, NV42mpi: color: id 8 0x00008 YUV422-YUYV, YUY2mpi: color: id 10 0x0000a YUV422-UYVY, UYVYmpi: color: id 12 0x0000c YUV400-Y8, Y800mpi: color: id 15 0x0000f YUV444SPmpi: color: id 16 0x00010 YUV444Pmpi: color: id 65536 0x10000 RGB565mpi: color: id 65537 0x10001 BGR565mpi: color: id 65538 0x10002 RGB555mpi: color: id 65539 0x10003 BGR555mpi: color: id 65542 0x10006 RGB888mpi: color: id 65543 0x10007 BGR888mpi: color: id 65546 0x1000a ARGB8888mpi: color: id 65547 0x1000b ABGR8888mpi: color: id 65548 0x1000c BGRA8888mpi: color: id 65549 0x1000d RGBA8888 随后运行.&#x2F;mpi_enc_test 加上各种参数即可实现编码视频。 MPI接口使用说明MPI（Media Process Interface）是 MPP 提供给用户的接口，用于提供硬件编解码功能，以及一些必要的相关功能。MPI 是通过 C 结构里的函数指针方式提供给用户，用户可以通过 MPP 上下文结构MppCtx 与 MPI 接口结构 MppApi 组合使用来实现解码器与编码器的功能。 如图，mpp_create，mpp_init，mpp_destroy 是操作 MppCtx 接口的过程，其中 mpp_create 接口也获取到了 MPI 接口结构体 MppApi，真正的编码与解码过程是通过调用 MppApi 结构体里内的函数指针来实现，也就是上图中红框内的部分。红框内的函数调用分为编解码流程接口put&#x2F;get_packet&#x2F;frame 和相关的 control 和 reset 接口。 接口略…有点多。请参考MPP手册或代码。 后面可根据官方例子，进行改进，编写自己的app程序。下一章节介绍。","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【RK3568】采集并存储USB摄像头视频流","slug":"【RK3568】采集并存储USB摄像头视频流","date":"2023-10-04T16:00:00.000Z","updated":"2023-10-29T18:26:18.573Z","comments":true,"path":"2023/10/05/【RK3568】采集并存储USB摄像头视频流/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/05/%E3%80%90RK3568%E3%80%91%E9%87%87%E9%9B%86%E5%B9%B6%E5%AD%98%E5%82%A8USB%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E6%B5%81/","excerpt":"","text":"添加OpenCV库一般开发板sdk都会包含opencv库，需要添加到跟文件系统中。本文使用buildroot添加opencv4。若使用者板子没有opencv库，请自行下载cv代码，编译后添加到buildroot的Libraries中。网上资料比较多，不多赘述。 buildroot中使用make menuconfig添加opencv4代码库。 添加后，编译烧录到开发板。可在开发板&#x2F;usr&#x2F;lib查看库 编写APP程序测试开发板OpenCV库是否ok 测试代码： 12345678910111213141516171819#include &lt;opencv4/opencv2/opencv.hpp&gt;int main() &#123; // 读取图片，这里读取开发板上的一个图片，可以替换自己的 cv::Mat image = cv::imread(&quot;opt/apps/src/test/logo.png&quot;); // 检查是否成功读取图片 if (image.empty()) &#123; std::cout &lt;&lt; &quot;无法读取图片文件&quot; &lt;&lt; std::endl; return -1; &#125; // 创建一个窗口来显示图片 cv::namedWindow(&quot;Image&quot;, cv::WINDOW_AUTOSIZE); // 显示图片 cv::imshow(&quot;Image&quot;, image); // 等待用户按下任意键，然后关闭窗口 cv::waitKey(0); cv::destroyAllWindows(); return 0;&#125; 编写CMakeLists.txt 1234567891011121314151617181920212223# cmake 最低版本cmake_minimum_required(VERSION 3.0)# 输出CMake的版本信息message(STATUS &quot;cmake version $&#123;CMAKE_VERSION&#125;&quot;)# 交叉编译工具链的路径set(TOOLCHAIN_DIR /opt/atk-dlrk356x-toolchain)# C++编译器和C编译器的路径set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/aarch64-buildroot-linux-gnu-g++)set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/aarch64-buildroot-linux-gnu-gcc)# 设置系统根目录（sysroot）路径，包含目标系统的头文件和库文件set(SYSROOT $&#123;TOOLCHAIN_DIR&#125;/aarch64-buildroot-linux-gnu/sysroot/usr/include)set(CMAKE_SYSROOT $&#123;TOOLCHAIN_DIR&#125;/aarch64-buildroot-linux-gnu/sysroot)# C++11标准set(CMAKE_CXX_STANDARD 11)# 链接的OpenCV库的名称set(OPENCV_LIBS opencv_core opencv_videoio opencv_video opencv_highgui opencv_imgcodecs opencv_imgproc)# 将交叉编译环境中的头文件目录添加到项目include_directories($&#123;SYSROOT&#125;)include_directories($&#123;SYSROOT&#125;/opencv4)#生成 opencv_test 执行程序project(opencv)add_executable(opencvTest opencvTest.cpp)target_link_libraries(opencvTest $&#123;OPENCV_LIBS&#125;) 在CMakeLists.txt目录下创建build文件夹，进入build中，输入make ..创建Makefile，随后输入make编译程序。使用scp（scp opencvTest &#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#54;&#57;&#46;&#x32;&#x35;&#x34;&#x2e;&#120;&#x78;&#x78;&#x2e;&#120;&#120;&#x78;:&#x2F;opt&#x2F;apps&#x2F;src&#x2F;mySrc）传输可执行文件和图片到开发板，运行代码。效果如图。 OpenCV视频常见保存格式 AVI (Audio Video Interleave) MP4 (MPEG-4 Part 14) MKV (Matroska) MOV (Apple QuickTime) WMV (Windows Media Video) FLV (Adobe Flash Video) 本文使用AVI，这几种视频格式优劣请自行百度（我也不熟）。 编写程序写程序时候一定要确认好自己板子驱动video号码，我的是video9。还需确认opencv和FFmpeg组合是否支持对应的视频格式及其编解码器！！选择合适正确的格式、编解码器~ 本例子使用的usb摄像头使用avi格式，使用MJPG编解码器。 以下是捕获并保存的app代码,CMakeLists.txt请参考上文。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;opencv4/opencv2/opencv.hpp&gt;#include &lt;opencv4/opencv2/videoio.hpp&gt;#include &lt;iostream&gt;int main() &#123; // 初始化摄像头 cv::VideoCapture cap(9, cv::CAP_V4L2); // 使用V4L2后端 // 检查摄像头是否成功打开 if (!cap.isOpened()) &#123; std::cerr &lt;&lt; &quot;Error: Couldn&#x27;t open the camera.&quot; &lt;&lt; std::endl; return -1; &#125; // 获取摄像头的分辨率 int width = static_cast&lt;int&gt;(cap.get(cv::CAP_PROP_FRAME_WIDTH)); int height = static_cast&lt;int&gt;(cap.get(cv::CAP_PROP_FRAME_HEIGHT)); // 设置保存视频的参数 cv::VideoWriter writer; int fourcc = cv::VideoWriter::fourcc(&#x27;M&#x27;, &#x27;J&#x27;, &#x27;P&#x27;, &#x27;G&#x27;); // 使用MJPG编解码器 double fps = 30.0; // 设置帧速率，根据摄像头而定，也可以使用cap.get(cv::CAP_PROP_FPS)获取 writer.open(&quot;/opt/apps/src/myhSrc/output.avi&quot;, fourcc, fps, cv::Size(width, height), true); // 在这里，你可以修改保存视频的路径 // 检查视频写入器是否成功初始化 if (!writer.isOpened()) &#123; std::cerr &lt;&lt; &quot;Error: Couldn&#x27;t initialize video writer.&quot; &lt;&lt; std::endl; return -1; &#125; cv::Mat frame; while (true) &#123; cap &gt;&gt; frame; // 从摄像头捕获一帧 if (frame.empty()) &#123; std::cerr &lt;&lt; &quot;Error: Empty frame captured.&quot; &lt;&lt; std::endl; break; &#125; writer.write(frame); // 将帧写入文件 // 显示当前帧，可选 cv::imshow(&quot;Camera Stream&quot;, frame); char key = static_cast&lt;char&gt;(cv::waitKey(1)); if (key == 27 || key == &#x27;q&#x27; || key == &#x27;Q&#x27;) &#123; // 按ESC, Q, or q退出 break; &#125; &#125; // 释放资源 cap.release(); writer.release(); cv::destroyAllWindows(); return 0;&#125; 测试结果 导出储存的视频，电脑打开如下。 程序在获取1080P@30fps视频流时候会很卡。我随后尝试使用多线程方式主线程显示视频，另一个线程储存视频，结果是显示流畅，储存的视频很卡。原因有2，一是MJPG编解码过程比较耗时间，可以尝试使用h264，二是密集型io操作很耗费时间。针对视频图像处理最好使用硬件加速解码。比如瑞芯微的MMP的hardware层支持硬件加速。此处不展开了。另起一篇介绍MMP。","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【RK3568】采集并保存USB音频","slug":"【RK3568】采集并保存USB音频","date":"2023-10-03T16:00:00.000Z","updated":"2023-10-29T18:26:11.839Z","comments":true,"path":"2023/10/04/【RK3568】采集并保存USB音频/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/04/%E3%80%90RK3568%E3%80%91%E9%87%87%E9%9B%86%E5%B9%B6%E4%BF%9D%E5%AD%98USB%E9%9F%B3%E9%A2%91/","excerpt":"","text":"音视频处理库 FFmpeg是开源的音视频处理库，对音频、视频流的编码与解码非常方便，这个库很强大，包括libavcodec解码库、libavformat格式转换库，在抖音、快手、剪映等热门软件的安装包里可以解压出这些包。作者板子sdk自带，所以此处使用FFmpeg。FFmpeg是C语言实现的，所以在别的语言如C++中使用，需要使用entern “C”{}包含。 ​ 头文件需要包含以下： 1234#include &lt;libavdevice/avdevice.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavutil/opt.h&gt; 查看USB摄像头音频参数输入arecord -l，查看deviceName： 输入arecord -D hw:0,0 –dump-hw-params，查看详细参数： 单通道，采样率8000~48000，采样格式16 位有符号小端。 代码实现此处实现，get_audio_params_from_arecord()函数使用了arecord -D hw:0,0 –dump-hw-params，通过解析内容自动获取音频通道、采样率参数。除此方法还可以手动设置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define __STDC_CONSTANT_MACROS#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;extern &quot;C&quot; &#123; #include &lt;libavdevice/avdevice.h&gt; #include &lt;libavformat/avformat.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt;&#125;// 使用指令获取audio参数，解析并保存std::map&lt;std::string, std::string&gt; get_audio_params_from_arecord() &#123; std::vector&lt;std::string&gt; keys = &#123;&quot;CHANNELS&quot;, &quot;RATE&quot;&#125;; std::map&lt;std::string, std::string&gt; params; for (const std::string&amp; key : keys) &#123; std::string cmd = &quot;arecord -D hw:0,0 --dump-hw-params 2&gt;&amp;1 | grep &quot; + key; char buffer[128]; FILE* pipe = popen(cmd.c_str(), &quot;r&quot;); if (!pipe) &#123; std::cerr &lt;&lt; &quot;Failed to run command.&quot; &lt;&lt; std::endl; return params; &#125; while (fgets(buffer, sizeof(buffer), pipe) != nullptr) &#123; std::string fullOutput(buffer); size_t pos = fullOutput.find(&quot;:&quot;); if (pos != std::string::npos &amp;&amp; pos + 1 &lt; fullOutput.length()) &#123; std::string value = fullOutput.substr(pos + 1); // Trim leading and trailing white spaces size_t first = value.find_first_not_of(&quot; \\t\\n\\r&quot;); size_t last = value.find_last_not_of(&quot; \\t\\n\\r]&quot;); value = value.substr(first, (last-first+1)); if (key == &quot;RATE&quot;) &#123; // Get the higher rate from the range size_t spacePos = value.rfind(&quot; &quot;); // Using rfind to find the last space if (spacePos != std::string::npos) &#123; value = value.substr(spacePos + 1); &#125; &#125; params[key] = value; &#125; &#125; pclose(pipe); &#125; return params;&#125;int main() &#123; // 注册所有设备，初始化libavdevice库 avdevice_register_all(); AVFormatContext* pFormatCtx = nullptr; // 用于存储音视频文件的信息 AVDictionary *options = nullptr; // 打开设备时的选项 AVInputFormat* inputFormat = av_find_input_format(&quot;alsa&quot;); // 指定使用alsa格式 // 如果您的USB摄像头音频设备不是hw:0,0，请相应修改 // 输入arecord -l查看deviceName，设置音频驱动名字 // 获取音频流的参数并设置 const char* deviceName = &quot;hw:0,0&quot;; std::map&lt;std::string, std::string&gt; audio_params = get_audio_params_from_arecord(); std::cout &lt;&lt; &quot;Channels: &quot; &lt;&lt; audio_params[&quot;CHANNELS&quot;] &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Sample Rate: &quot; &lt;&lt; audio_params[&quot;RATE&quot;] &lt;&lt; std::endl; av_dict_set(&amp;options, &quot;channels&quot;, audio_params[&quot;CHANNELS&quot;].c_str(), 0); // 单/双声道 av_dict_set(&amp;options, &quot;sample_rate&quot;, audio_params[&quot;RATE&quot;].c_str(), 0); // 采样率Hz // 打开输入流，关联到pFormatCtx if (avformat_open_input(&amp;pFormatCtx, deviceName, inputFormat, &amp;options) != 0) &#123; printf(&quot;Couldn&#x27;t open input stream.\\n&quot;); return -1; &#125; // 查找流信息，FFmpeg读取一些数据包来确定流的参数 if (avformat_find_stream_info(pFormatCtx, nullptr) &lt; 0) &#123; printf(&quot;Couldn&#x27;t find stream information.\\n&quot;); return -1; &#125; // 查找音频流 int audioIndex = -1; for (int i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; audioIndex = i; break; &#125; &#125; if (audioIndex == -1) &#123; printf(&quot;Didn&#x27;t find an audio stream.\\n&quot;); return -1; &#125; // 创建输出上下文，在outputwav创建一个新的AVFormatContext // 并为其创建一个新的音频流，然后从输入流复制编解码器参数。 AVFormatContext *outContext = nullptr; avformat_alloc_output_context2(&amp;outContext, nullptr, nullptr, &quot;output.wav&quot;); if (!outContext) &#123; printf(&quot;Couldn&#x27;t create output context.\\n&quot;); return -1; &#125; // 创建新的输出流，nullptr使用默认 AVStream *outStream = avformat_new_stream(outContext, nullptr); if (!outStream) &#123; printf(&quot;Couldn&#x27;t create output stream.\\n&quot;); return -1; &#125; // 复制编解码器参数 if (avcodec_parameters_copy(outStream-&gt;codecpar, pFormatCtx-&gt;streams[audioIndex]-&gt;codecpar) &lt; 0) &#123; printf(&quot;Failed to copy codec parameters.\\n&quot;); return -1; &#125; // 打开输出文件 if (avio_open(&amp;outContext-&gt;pb, &quot;output.wav&quot;, AVIO_FLAG_WRITE) &lt; 0) &#123; printf(&quot;Couldn&#x27;t open output file.\\n&quot;); return -1; &#125; //写入输出文件的头部。写入WAV文件格式的标准头部，包括音频格式、采样率、通道数等信息 if (avformat_write_header(outContext, nullptr) &lt; 0) &#123; printf(&quot;Error occurred when writing header.\\n&quot;); return -1; &#125; AVPacket packet;// 保存从输入设备捕获的音频数据 while (true) &#123; if(av_read_frame(pFormatCtx, &amp;packet) &gt;= 0) &#123; if (packet.stream_index == audioIndex) &#123; // 将音频数据写入文件 av_interleaved_write_frame(outContext, &amp;packet); &#125; av_packet_unref(&amp;packet); &#125; else &#123; // 短暂休眠以减少CPU使用率 std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125; &#125; av_write_trailer(outContext); avio_close(outContext-&gt;pb); avformat_free_context(outContext); avformat_close_input(&amp;pFormatCtx); return 0;&#125; CMakeLists.txt123456789101112131415161718192021222324252627282930# cmake 最低版本cmake_minimum_required(VERSION 3.0)# 输出CMake的版本信息message(STATUS &quot;cmake version $&#123;CMAKE_VERSION&#125;&quot;)# 交叉编译工具链的路径set(TOOLCHAIN_DIR /opt/atk-dlrk356x-toolchain)# C++编译器和C编译器的路径set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/aarch64-buildroot-linux-gnu-g++)set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/aarch64-buildroot-linux-gnu-gcc)# 设置系统根目录（sysroot）路径，包含目标系统的头文件和库文件set(SYSROOT $&#123;TOOLCHAIN_DIR&#125;/aarch64-buildroot-linux-gnu/sysroot/usr/include)set(CMAKE_SYSROOT $&#123;TOOLCHAIN_DIR&#125;/aarch64-buildroot-linux-gnu/sysroot)# C++11标准set(CMAKE_CXX_STANDARD 11)# 设置FFmpeg的头文件目录和库目录set(FFMPEG_INCLUDE_DIR $&#123;CMAKE_SYSROOT&#125;/usr/include)set(FFMPEG_LIB_DIR $&#123;CMAKE_SYSROOT&#125;/usr/lib64)# 将FFmpeg的头文件目录添加到项目include_directories($&#123;FFMPEG_INCLUDE_DIR&#125;)# 链接的FFmpeg库的名称set(FFMPEG_LIBS avdevice avformat avcodec avutil swresample swscale)# 将交叉编译环境中的头文件目录添加到项目include_directories($&#123;SYSROOT&#125;)#生成 opencv_test 执行程序project(test)add_executable(saveWav saveWav.cpp)target_link_libraries(saveWav $&#123;FFMPEG_LIBS&#125;)# 确保链接时搜索到FFmpeg的库link_directories($&#123;FFMPEG_LIB_DIR&#125;)","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【RK3568】U盘锁","slug":"【RK3568】U盘锁","date":"2023-10-02T16:00:00.000Z","updated":"2023-10-29T18:26:07.223Z","comments":true,"path":"2023/10/03/【RK3568】U盘锁/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/03/%E3%80%90RK3568%E3%80%91U%E7%9B%98%E9%94%81/","excerpt":"","text":"【RK3568】U盘锁 创建一个USB锁系统需要涉及到几个方面的技术：USB设备检测、文件读取、数据校验和权限管理。对于隐蔽性和安全性，还需要加密和代码保护措施。 USB设备检测检测USB设备，首先要建立一个udev规则，当usb设备连接或者断开时候，执行某脚本。 在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;目录下创建1-lock.rules，名字可随意。 为规则添加内容： 12ACTION==&quot;add&quot;, KERNEL==&quot;sda1&quot;, ATTR&#123;idVendor&#125;==&quot;0781&quot;, ATTR&#123;idProduct&#125;==&quot;5530&quot;, RUN+=&quot;/opt/apps/src/lock/lock_in.sh&quot;ACTION==&quot;remove&quot;, KERNEL==&quot;sda1&quot;, ATTR&#123;idVendor&#125;==&quot;0781&quot;, ATTR&#123;idProduct&#125;==&quot;5530&quot;, RUN+=&quot;/opt/apps/src/lock/lock_out.sh&quot; 其中KERNEL是U盘的磁盘名字。 ATTR{idVendor}和ATTR{idProduct}代表U盘的ID，可通过lsusb指令查看。如下： 脚本编写随后前往&#x2F;opt&#x2F;apps&#x2F;src&#x2F;lock&#x2F;目录编写lock_in.sh、lock_out.sh脚本 此处脚本仅实现最简单的，挂载U盘，读取U盘lockPassword.txt和本地password.txt中password:”xxx”,的xxx字符进行匹配，若匹配则成功，失败则退出。 脚本执行时候是后台执行，所以无法交互输入，我使用了在password.txt中填写密码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/bin/bash# lock_in.sh# ConfigurationBASE_DIR=&quot;$(cd &quot;$(dirname &quot;$0&quot;)&quot; &amp;&amp; pwd)&quot;LOGFILE=&quot;$BASE_DIR/lock_in.log&quot;MOUNT_POINT=&quot;/mnt/usbLock&quot;DEVICE=&quot;/dev/sda1&quot;LOCAL_PASSWORD_FILE=&quot;$BASE_DIRpassword.txt&quot;USB_PASSWORD_FILE=&quot;$MOUNT_POINT/lockPassword.txt&quot;# Utility Functionslog_message() &#123; echo &quot;[$(date)] $1&quot; &gt;&gt; $LOGFILE&#125;extract_password() &#123; local file=$1 grep -o &#x27;password:&quot;[^&quot;]*&quot;&#x27; $file | awk -F\\&quot; &#x27;&#123;print $2&#125;&#x27;&#125;# Main Script Executionlog_message &quot;Started script&quot;# Check and create mount point if not exists[ ! -d &quot;$MOUNT_POINT&quot; ] &amp;&amp; mkdir -p $MOUNT_POINT# Mount the USB driveif ! mount $DEVICE $MOUNT_POINT; then log_message &quot;Failed to mount $DEVICE&quot; exit 1fi# Check if USB password file existsif [ -f &quot;$USB_PASSWORD_FILE&quot; ]; then # Check if local password file exists if [ -f &quot;$LOCAL_PASSWORD_FILE&quot; ]; then local_password=$(extract_password $LOCAL_PASSWORD_FILE) usb_password=$(extract_password $USB_PASSWORD_FILE) # Log the extracted passwords log_message &quot;Extracted Local password: $local_password&quot; log_message &quot;Extracted USB password: $usb_password&quot; # Compare passwords if [ &quot;$local_password&quot; == &quot;$usb_password&quot; ]; then log_message &quot;Passwords matched&quot; else log_message &quot;Password mismatch&quot; fi else log_message &quot;Local password file $LOCAL_PASSWORD_FILE not found&quot; fielse log_message &quot;No lockPassword.txt found on USB drive&quot;fi# Unmount the USB driveumount $MOUNT_POINT u盘插入后，会自动执行本sh，同时会输出一个log日志，&#x2F;opt&#x2F;apps&#x2F;src&#x2F;lock&#x2F;lock_in.log。如下： 上面是部分是USB插入打印的信息。下部分是log日志。 此处例子USB插入未实现处理代码，所以不放出lock_out.sh，各位可根据自己需求来实现。 加密上面例子的方式并不安全，最好使用加密措施。简单的比如使用OpenSSL，在u盘lockPassword.txt中存放两个经过AES文本密码加密的字符串。然后在板子password.txt，填写两个字符串的密码。然后使用openssl进行解密对比两者结果，一致则开放权限等。复杂情况不建议使用sh（不好写，可读性差），可以在sh上执行其他脚本，如python脚本或者，c++写的脚本。","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【RK3568】U-BOOT启动流程","slug":"【RK3568】U-BOOT启动流程","date":"2023-10-01T16:00:00.000Z","updated":"2023-10-29T18:26:02.560Z","comments":true,"path":"2023/10/02/【RK3568】U-BOOT启动流程/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/02/%E3%80%90RK3568%E3%80%91U-BOOT%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"【RK3568】U-BOOT启动流程RK平台的U-Boot 启动流程如下，仅列出⼀些重要步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051start.s // 汇编环境 =&gt; IRQ/FIQ/lowlevel/vbar/errata/cp15/gic // ARM架构相关的lowlevel初始化 =&gt; _main =&gt; stack // 准备好C环境需要的栈 // 【第⼀阶段】C环境初始化，发起⼀系列的函数调⽤ =&gt; board_init_f: init_sequence_f[] initf_malloc arch_cpu_init // 【SoC的lowlevel初始化】 serial_init // 串口初始化 dram_init // 【获取ddr容量信息】 reserve_mmu // 从ddr末尾开始往低地址reserve内存 reserve_video reserve_uboot reserve_malloc reserve_global_data reserve_fdt reserve_stacks dram_init_banksize sysmem_init setup_reloc // 确定U-Boot⾃⾝要reloc的地址 // 汇编环境 =&gt; relocate_code // 汇编实现U-Boot代码的relocation // 【第⼆阶段】C环境初始化，发起⼀系列的函数调⽤ =&gt; board_init_r: init_sequence_r[] initr_caches // 使能MMU和I/Dcache initr_malloc bidram_initr sysmem_initr initr_of_live // 初始化of_live initr_dm // 初始化dm框架 board_init // 【平台初始化，最核⼼部分】 board_debug_uart_init // 串口iomux、clk配置 init_kernel_dtb // 【切到kernel dtb】！ clks_probe // 初始化系统频率 regulators_enable_boot_on // 初始化系统电源 io_domain_init // io-domain初始化 set_armclk_rate // __weak，ARM提频(平台有需求才实现) dvfs_init // 宽温芯⽚的调频调压 rk_board_init // __weak，由各个具体平台进⾏实现 console_init_r board_late_init // 【平台late初始化】 rockchip_set_ethaddr // 设置mac地址 rockchip_set_serialno // 设置serialno setup_boot_mode // 解析&quot;reboot xxx&quot;命令、 // 识别按键和loader烧写模式、recovery charge_display // U-Boot充电 rockchip_show_logo // 显⽰开机logo soc_clk_dump // 打印clk tree rk_board_late_init // __weak，由各个具体平台进⾏实现 run_main_loop // 【进⼊命令⾏模式，或执⾏启动命令】","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【RK3568】Buildroot开发","slug":"【RK3568】Buildroot开发","date":"2023-09-30T16:00:00.000Z","updated":"2023-10-29T18:25:57.689Z","comments":true,"path":"2023/10/01/【RK3568】Buildroot开发/","link":"","permalink":"https://bakuenkou.gitee.io/2023/10/01/%E3%80%90RK3568%E3%80%91Buildroot%E5%BC%80%E5%8F%91/","excerpt":"","text":"【RK3568】Buildroot开发Buildroot目录介绍 说明 顶层目录名 arch 存放 buildroot 支持的所有 CPU 架构相关的配置文件及构建脚本 board 存放特定目标平台相关的文件，譬如内核配置或补丁文件、rootfs覆盖文件等 boot 存放 buildroot 支持的 BootLoader 相关的补丁、校验文件、构建脚本、配置选项等 build Buildroot 编译系统相关组件configs 存放了所有目标平台的 configs 存放了所有目标平台的 defconfig 配置文件 dl download 的缩写，该目录用于存放下载的各种开源软件包，譬如alsa-lib 库、bluez 库、bzip2、curl 工具等；在编译过程中，buildroot会从网络下载所需软件包、并将其放置在 dl&#x2F;目录下；如果 buildroot下载某软件包时失败、无法下载成功，此时我们也可以自己手动下载该软件包、并将其拷贝至 dl 目录下。所有软件包只需下载一次即可，不是每次编译都要下载一次（除非删除 dl 目录），只要 dl 目录下存在该软件包就不用下载了；所以往往第一次编译会比较慢，因为下载过程会占用很多时间 docs 存放相关的参考文档 fs 存放各种文件系统的源代码 linux 存放 linux 的构建脚本和配置选项 output 该文件夹会在编译 buildroot 后出现，output 目录用于存放编译过程中输出的各种文件，包括各种编译生成的中间目标文件、可执行文件、lib 库以及最终烧录到开发板的 rootfs 镜像等 package 存放所有 package（软件包）的构建脚本、配置选项；每个软件包目录下（package&#x2F;&#x2F;）都有一个 Config.in 文件和.mk 文件（其实就是 Makefile 文件）；如果需要添加一个新的 package，则需对 package&#x2F;目录进行改动。 support 存放一些为 buildroot 提供功能支持的脚本、配置文件等 to loc ha in 存放制作各种交叉编译工具链的构建脚本和相关文件，binutils、gcc、gdb、kernel-header 和 uClibc utils 存放一些 buildroot 的实用脚本和工具 常见编译指令在buildroot跟目录下可以直接使用make命令编译buildroot，也可以单独指定packge进行编译，具体见make help提示。 编译跟文件系统编译之前，先进行配置；进入到 buildroot 目录下，执行如下命令进行配置（以 rk3568 平台为例）： source build&#x2F;envsetup.sh rockchip_rk3568 命令中最后一个参数（rockchip_rk3568）用于指定目标平台的 defconfig 配置文件（不带 _defconfig 后缀），所有目标平台的 defconfig 配置文件都存放在&#x2F;configs** 目录下，在 该目录下可以找到 rk3568 的配置文件 rockchip_rk3568_defconfig，如下所示： 配置后直接： make 或 make all make -j20 或 make all -j20 编译package编译之前，先进行配置。进入到 buildroot 目录下，执行如下命令进行配置（以 rk3568 平台为例）： source build&#x2F;envsetup.sh rockchip_rk3568 配置完成后，执行如下命令编译指定的 package： make 参数用于指定 package 的名字，譬如 myh_package： make myh_package Buildroot清除执行如下可删除所有构建生成的文件（包括 build、host、staging and target trees、images 和 toolchain）： make clean 执行如下命令可删除所有构建时生成的文件以及相关配置（彻底清除，相当于删除 output目录）： make distclean 执行如下命令可删除指定 package 的构建目录： make -dirclean 添加Package详解 package_name 对应的便是 buildroot&#x2F;package&#x2F;文件夹中的某个目录对应的名字（或某个子目录对应的名字），并且该目录中存在 Config.in 配置文件（用于定义 package 配置选项）以及.mk 文件（Makefile 文件，用于定义 package 的构建逻辑）。比如： rkwifibt → package&#x2F;rockchip&#x2F;rkwifibt&#x2F; rknpu → package&#x2F;rockchip&#x2F;rknpu&#x2F; rkupdate → package&#x2F;rockchip&#x2F;rkupdate&#x2F; package（软件包）的构建过程可以分解为：configure（配置）、build（编译）、install（安装），其执行顺序为：配置→编译→安装，每一步可单独执行，执行如下命令： make -configure #执行配置命令 make -build #执行编译命令 make -install #执行安装命令 或者 utils&#x2F;brmake -configure #执行配置命令 utils&#x2F;brmake -build #执行编译命令 utils&#x2F;brmake -install #执行安装命令 以 rkwifibt 为例： utils&#x2F;brmake rkwifibt-configure utils&#x2F;brmake rkwifibt-build utils&#x2F;brmake rkwifibt-install 与之对应的还有：reconfigure（重新配置）、rebuild（重新编译）、reinstall（重新安装）： make -reconfigure #从配置阶段开始，重新启动 package 的构建过程 make -rebuild #从编译阶段开始，重新启动 package 的构建过程 make -reinstall #从安装阶段开始，重新启动 package 的构建过程 或者 utils&#x2F;brmake -reconfigure #从配置阶段开始，重新启动 package 的构建过程 utils&#x2F;brmake -rebuild #从编译阶段开始，重新启动 package 的构建过程 utils&#x2F;brmake -reinstall #从安装阶段开始，重新启动 package 的构建过程 以 rkwifibt 为例： utils&#x2F;brmake rkwifibt-reconfigure utils&#x2F;brmake rkwifibt-rebuild utils&#x2F;brmake rkwifibt-reinstall 添加package 添加代码，编写makefile&#x2F;cmake。 Buildroot&#x2F;package目录下创建目录，并在其中编写Config.in和mypackage.mk。 修改package&#x2F;Config.in，添加mypackage。 mkae menuconfig 在Target packages中使能mypackage。 执行make mypackage-rebuild&#x2F;make mypackage。 随后可执行文件会生成在output&#x2F;rockchip_rk3568&#x2F;target&#x2F;usr&#x2F;bin目录。编译烧写rootfs到板子即可使用。 编译RK3568根文件系统镜像rootfs.img 配置defconfig：source build&#x2F;envsetup.sh rockchip_rk3568 make -j20 或 make all -j20 或 utils&#x2F;brmake -j20 命令中最后一个参数（rockchip_rk3568）用于指定目标平台的 defconfig 配置文件（不带**_defconfig** 后缀），目标平台的 defconfig 配置文件都存放在**&#x2F;configs** 目录下，在该目录下可以找到 rk3568 的配置文件 rockchip_rk3568_defconfig。编译成功后会输出到output目录。 output目录介绍output&#x2F; ├── rockchip_rk3568 ├── build #包含所有构建的软件包，包括 buildroot 在宿主机上所需的工具以及为目标平台编译的软件包 ├── host #包含为 Ubuntu 主机（宿主机）构建的工具，以及目标工具链 ├── images #存放最终编译输出的镜 ├── Makefile ├── staging #一个指向 host&#x2F;目录中目标工具链 sysroot 的符号链接 └── target #根文件系统系统目录，用来创建根文件系统镜像，rootfs.img 镜像的内容就是该目录下的内容","categories":[{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"}],"tags":[{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"}]},{"title":"【Linux】新字符设备驱动","slug":"【Linux】新字符设备驱动","date":"2023-09-06T16:00:00.000Z","updated":"2023-10-31T14:12:49.185Z","comments":true,"path":"2023/09/07/【Linux】新字符设备驱动/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/07/%E3%80%90Linux%E3%80%91%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"新旧字符设备驱动的差别 注册设备方式 旧：用register_chrdev函数来注册字符设备。这个函数需要设备号、设备名和一个指向file_operations结构体的指针 新：使用alloc_chrdev_region、cdev_init和cdev_add等函数来注册字符设备。 设备文件 旧：设备文件（通常位于&#x2F;dev目录）需要手动创建。这可以使用mknod命令来完成。 新：利用udev系统自动创建设备文件。 设备号 旧：旧式驱动通常使用静态设备号。静态设备号可能会导致设备号冲突，且浪费。 新：新式驱动使用动态分配的设备号，这减少了设备号冲突的可能性。 新字符设备驱动实现方式设备号分配设备号有动态和静态两个方式。如果给定了主次设备号，使用静态分配，调用如下函数： int register_chrdev_region(dev_t from, unsigned count, const char *name) // 不建议使用 静态分配设备号存在以下问题： 需要主动确定未被使用的主设备号。 一个字符设备会消耗掉一个住设备号下所有的次设备号。（浪费） 为了解决了这个问题，最好使用动态方式，在需要使用设备号时候向Linux内核申请，需要几个申请几个。由 Linux 内核分配设备可以使用的设备号，调用的函数如下： int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 销毁字符设备时候释放设备号都是调用以下函数。 void unregister_chrdev_region(dev_t from, unsigned count) 新字符设备注册方法字符设备结构体Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中。 1234567891011121314struct cdev &#123; // 用于管理内核对象的生命周期以及提供设备模型（Device Model）支持 struct kobject kobj; //指向拥有这个字符设备的内核模块，防止在字符设备仍在使用时卸载内核模块 struct module *owner; // 操作函数集合 const struct file_operations *ops; // 用于将字符设备插入到内核管理的字符设备链表中的链表头。通过这个链表，内核能够管理和查找系统中的所有字符设备。 struct list_head list; //设备号 dev_t dev; // 记录字符设备占用的设备号范围的大小 unsigned int count; &#125; __randomize_layout;//编译时布局进行随机化处理，安全 注册和添加设备函数：cdev_init()和cdev_add()定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化。随后使和cdev_add函数向 Linux 系统添加这个字符设备。用例如下： 12345678910struct cdev myCdev;、static struct file_operations myFops = &#123; .owner = THIS_MODULE, /* 其他具体的初始项 */&#125;;myCdev.owner = THIS_MODULE;cdev_init(&amp;myCdev, &amp;myFops); /* 初始化 cdev 结构体变量 */cdev_add(&amp;myCdev, devid, 1); /* 添加字符设备 */ 如果再加上面中分配设备号的程序，相当于 register_chrdev 函数的功能。 卸载驱动函数：cdev_del()卸载驱动的时候要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备。 函数：cdev_del(&amp;myCdev); /* 删除 cdev */ cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。 自动创建设备节点启用udev这个不需要我们主动开启，开机会自动开启的，此处仅介绍他的用处~ udev 是 Linux 系统中用于管理设备节点的守护进程，运行在用户空间。其作用可粗略分为以下： 管理 &#x2F;dev&#x2F; 目录下的设备节点：当新设备被添加到系统时，udev 会根据规则文件来创建相应的设备节点。相应地，当设备被移除时，udev 会删除设备节点。 设备持久命名：通过创建持久的、一致的设备节点名称，udev 确保了设备名称在系统重启或设备重新插拔后保持不变。 运行设备特定的初始化和配置脚本：udev 可以根据规则文件配置设备或运行初始化脚本。 加载或关闭额外的设备驱动或固件。（modprobe、rmmod） 创建和删除类自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类。定义在include/linux/device.h。创建和删除的函数如下 12struct class *class_create (struct module *owner, const char *name);void class_destroy(struct class *cls); 创建设备创建类后，还需要创建设备。 12345678// 此为可变参函数struct device *device_create( struct class *class, // 创建到哪个class struct device *parent, // 父设备，一般为NULL dev_t devt, // 设备号 void *drvdata, // 可以用来传递设备驱动的私有数据，不需要则NULL const char *fmt, ... //设备名字，如果设置 fmt=xxx，会生成/dev/xxx设备文件) 如果需要卸载，则使用删除函数： void device_destroy(struct class *cls, dev_t devt) 参考示例在入口函数中创建类与设备，出口函数删除类和设备： 1234567891011121314151617181920212223struct class *class;struct device *device;dev_t devid;static int __init my_init(void)&#123; // 创建类 class = class_create(THIS_MODULE, &quot;XXXX&quot;) // 创建设备 device = device_create(class, NULL, devid, NULL, &quot;XXXX&quot;); return 0;&#125;static void __exit my_exit(void)&#123; // 删除设备 device_destroy(newchrled.class, newchrled.devid); // 删除类 class_destroy(newchrled.class);&#125;module_init(my_init);module_exit(my_exit);","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/tags/Linux/"}]},{"title":"【Linux】GDB调试","slug":"【Linux】GDB调试","date":"2023-09-04T16:00:00.000Z","updated":"2023-10-29T18:25:36.795Z","comments":true,"path":"2023/09/05/【Linux】GDB调试/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/05/%E3%80%90Linux%E3%80%91GDB%E8%B0%83%E8%AF%95/","excerpt":"","text":"GDB指令介绍启动和退出 语句 作用 gdb &lt;program&gt; 启动gdb并加载要调试的程序 strat 停放在main函数第一行前面，等待指令 quit 退出gdb调试器 执行和运行控制 语句 作用 run 执行程序 continue&#x2F;c 继续程序的执行，直到下一个断点或程序结束 next&#x2F;n 执行当前行并转到下一行 step&#x2F;s 单步执行并进入函数调用 finish 执行完当前函数并返回到调用者 kill 终止正在调试的进程 断点和调试控制： 语句 作用 break &lt;line_number&gt; 在指定行设置断点 break &lt;function_name&gt; 在指定函数设置断点 break…if… 设置条件断点 delete &lt;breakpoint_number&gt; 删除指定的断点 disable &lt;breakpoint_number&gt; 禁用指定的断点 enable &lt;breakpoint_number&gt; 启用指定的断点 disable breakpoints 禁用断点 enable breakpoints 启用断点 info breakpoints 显示当前设置的断点列表 变量和表达式： 语句 作用 watch &lt;variable&gt; 设置对变量的监视 info watchpoints 查看当前设置了哪些观察点 print&#x2F;p &lt;variable&gt; 打印变量的值 display &lt;variable&gt; 设置永久显示变量的值 undisplay 取消先前跟踪的变量 set &lt;variable&gt; &#x3D; &lt;value&gt; 设置变量的值 whatis &lt;variable&gt; 显示变量的类型 info locals 显示当前栈帧中的局部变量 堆栈和函数调用： 语句 作用 backtrace&#x2F;bt 显示当前线程的函数调用堆栈 frame &lt;frame_number&gt; 切换到指定的栈帧 up 切换到上一个栈帧 down 切换到下一个栈帧 线程和并发调试： 语句 作用 info threads 显示当前活动线程的列表和各个线程的ID thread &lt;thread_id&gt; 切换到指定的线程 set scheduler-locking on 启用调度程序锁定 set scheduler-locking off 禁用调度程序锁定 调试核心转储文件： 语句 作用 core &lt;core_file&gt; 加载核心转储文件进行调试 堆栈调试以下面的代码为例，funcA和funcB两个线程都会对sharedVariable进行递增操作，可能引发竞争条件。下面使用gdb进行堆栈调试来定位竞争条件的问题。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;thread&gt;int sharedVariable = 0;void funcA() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; sharedVariable++; &#125;&#125;void funcB() &#123; sharedVariable++;&#125;int main() &#123; std::thread t1(funcA); std::thread t2(funcB); t1.join(); t2.join(); std::cout &lt;&lt; &quot;Shared variable value: &quot; &lt;&lt; sharedVariable &lt;&lt; std::endl; return 0;&#125; 启动gdb，并加载程序：$ gdb &lt;program&gt; 在gdb中设置断点，在funcB函数中设置断点：(gdb) break funcB 运行程序(gdb) run 程序停在funB时，可使用info threads查看当前活动线程列表和ID，然后使用&#96;&#96;thread 1&#96;切换到funA 使用backtraceorbt命令查看该线程的堆栈跟踪信息，以了解函数调用路径。 使用frame &lt;frame_number&gt;命令切换到特定的栈帧，并使用list命令查看相关的源代码。 使用print sharedVariable命令查看sharedVariable的值以及其他变量的状态。 实际调试过程比较复杂，基本上就是通过上面指令一顿操作分析，找问题。除此之外还可以结合其他工具，如静态分析工具cppcheck等。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"}]},{"title":"【Linux】线程进程","slug":"【Linux】线程进程","date":"2023-09-03T16:00:00.000Z","updated":"2023-10-29T18:25:53.760Z","comments":true,"path":"2023/09/04/【Linux】线程进程/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/04/%E3%80%90Linux%E3%80%91%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"进程线程概念what‘s a 线程&amp;进程进程和线程是操作系统中关于任务管理和调度的基本概念。 进程 1、进程是一个独立的、在内存中运行的程序实例，它拥有自己的地址空间、代码、开放的文件句柄、系统资源和独立的系统上下文。 2、每个进程都有自己独立的地址空间。 3、创建、销毁或切换进程的开销比线程要大。 线程 1、线程是进程内的一个执行单元或控制流，它共享该进程的地址空间和资源，但拥有自己的调用堆栈、寄存器和程序计数器。 2、线程间它们共享相同的内存空间。所以线程崩溃会影响比较大（进程崩溃、资源泄露、数据不一致等）。 3、创建、销毁或切换线程的开销比进程小。 主要区别 1、独立性：进程是独立的，它们拥有自己的地址空间和资源；而线程是进程内的轻量级实体，它们共享进程的地址空间和资源。 2、通信：由于进程之间的隔离，它们之间的通信比线程间的通信更复杂。 3、开销：进程的生命周期（创建、切换和销毁）的开销通常比线程大。 4、数据共享：线程可以直接访问进程中的数据，因为它们共享相同的地址空间。而进程则需要使用特定的通信机制来共享数据。 多线程进程的优缺点多进程优点 隔离性、稳定性：进程有独立内存地址（虚拟内存），进程崩溃一般不影响其他进程。由 于隔离好所以，进程的一些错误，内存泄漏不会影响其他进程。 通信模型简单：在某些情况下，进程间的通信（如使用管道或消息队列）可能比线程间的同步（如使用锁或条件变量）更简单。 多进程缺点 开销：创建、维护、终止的开销都比线程大。 通信成本：进程间的通信（IPC）通常比线程间的通信慢，因为它涉及到进程间的上下文切换和数据复制。 资源共享：直接共享内存或资源在进程间更为复杂，通常需要使用共享内存、文件映射或其他方法。 多线程优点 低开销：创建、维护和终止线程的开销通常比进程小。 共享内存：线程共享同一地址空间，线程间的通信（如通过共享内存）通常比进程间的通信快。简化了数据交换和同步。 效率：上下文切换快。 多线程缺点 安全性：由于线程共享内存和资源，可能会导致并发问题，如数据竞争、死锁等。 稳定性：一个线程中的错误（如对无效内存的访问）可能会影响同一进程中的所有其他线程。 复杂的同步机制：在多线程程序中确保线程安全通常需要复杂的同步机制，如锁、信号量、条件变量等。 线程进程什么时候使用进程： 隔离性：需要确保任务都在彼此隔离的环境运行。 稳定性：希望进程崩溃不影响其他的进程。 不同地址空间：需要运行的任务有独立的内存地址空间，比如隔离的子系统（沙箱应用）。 简化编程模型：对于某些应用，使用进程和进程间通信（如消息传递）可能比多线程和锁编程更简单。 安全性：特定的安全应用可能要求使用多进程来隔离敏感操作，以防止潜在的内存篡改或泄露。 CPU密集型任务：对于分布在多个核心或计算机上的CPU密集型任务，使用进程可以更容易地实现并行计算，特别是当任务之间的通信较少时。 线程： 共享内存：任务需要频繁地访问和修改共享的数据结构，线程比较好，因为线程共享地址空间。 低延迟通信：线程间的通信（如通过条件变量或共享内存）通常比进程间的通信快。 轻量级并发：如需要大量并发任务，但每个任务的计算和内存需求都相对较小，线程的低的开销可能比较好。 紧密交互任务：如果应用的不同组件需要紧密交互和同步，使用线程可能会更为简单和高效。 资源限制：在资源受限的环境中，线程可能由于其较小的开销而更为合适。 IO密集型任务：许多I&#x2F;O密集型任务（如网络服务或数据库查询），使用多线程可以更有效地管理并发，因为在等待I&#x2F;O操作完成时，其他线程可以继续执行。 多进程间通讯管道匿名管道：通信范围是存在父子关系的进程。 命名管道：不相关的进程间也能相互通信。 优点： 简单：管道的接口和相对简单，易于使用。 数据流式传输：管道为数据提供了一个流式接口，这使得读&#x2F;写操作变得简单。 对于父子进程或兄弟进程之间的通信，管道通常提供了足够的速度和效率。 和标准输入输出结合：管道可以很容易地与进程的标准输入和输出结合使用，这在shell编程中特别有用，如command1 | command2。（可以在程序中，使用shell的指令，并解析指令） 缺点： 单项通信，不支持广播等多路通信。 缓冲区大小限制，管道满时候会阻塞。 总的来说通信效率低，不适合进程间频繁交换数据 消息队列​ 消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。 优点： 程序解耦，发送者和接受者程序解耦，互不影响。 支持优先级消息。 持久性~ 缺点： 通信不及时，异步。 大小有限制，小队列长度和队列总大小都有限制。不适合大数据传输。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。 高吞吐场景效率不如其他IPC机制（共享内存）效率高。 消息队列通信时候，存在用户态和内核态的数据拷贝开销。 共享内存​ 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。 优点： 高效：IPC机制中最快的，直接内存中访问数，无数据复制开销。 容量大：相比消息队列和管道，共享内存通常可以容纳更大的数据量。 灵活：可以使用任何数据结构（如数组、哈希表或其他）。 多进程并发访问：多个进程可以同时读写共享内存。 缺点： 同步：多进程并发访问会导致竞争，须使用信号量或互斥等同步机制确保数据完整性。 复杂：与消息队列或管道相比，共享内存更加复杂，尤其是考虑到同步和并发访问时。 安全：由于直接内存访问，进程可能会不小心破坏其他进程的数据或状态。 持久性：共享内存通常不是持久的。一旦所有进程都分离或结束，共享内存段通常会被系统自动删除。 信号量​ 为了防止多进程竞争共享资源，而造成的数据错乱，需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这一保护机制。 ​ 信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。 信号量表示资源的数量，控制信号量的方式有两种原子操作： 一个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。 另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程； P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。 信号量使用方法简单分为两种。如图。 1、互斥使用 2、同步使用 信号​ 上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。 ​ 在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号： 1234567891011121314$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如 Ctrl+C 产生 SIGINT 信号，表示终止该进程； Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束； 如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如： kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程； 所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。 信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。 1.执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。 2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。 3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。 ​ 在C++中，信号是一种特殊的事件，通常是由操作系统产生的，用于通知进程某些特定类型的事件已经发生，例如：尝试除以零、尝试访问无效内存、外部进程请求进程终止等。当这些事件发生时，操作系统会中断进程的正常流程，先处理这些信号，然后可能返回正常的执行或终止进程。 ​ 虽然信号提供了一种处理异常和其他事件的方法，但通常不建议使用它们来处理程序逻辑。信号最好用作他们原本的目的：响应操作系统发送的异常或事件。对于复杂的事件处理或进程间通信，使用其他IPC机制或事件处理库通常更为合适。 套接字​ 若需要跨越不同主机进行进程间通信，据需要Socket通信了。实际上Socket也可以在同一个主机上进行进程间通信。我们来看看创建 socket 的系统调用： 1int socket(int domain, int type, int protocal) domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机； type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字； protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可； 根据创建 socket 类型的不同，通信的方式也就不同： 实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM； 实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM； 实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket； 接下来，简单说一下这三种通信的编程模式。 ​ 针对 TCP 协议通信的 socket 编程模型 服务端和客户端初始化 socket，得到文件描述符； 服务端调用 bind，将绑定在 IP 地址和端口; 服务端调用 listen，进行监听； 服务端调用 accept，等待客户端连接； 客户端调用 connect，向服务器端的地址和端口发起连接请求； 服务端 accept 返回用于传输的 socket 的文件描述符； 客户端调用 write 写入数据；服务端调用 read 读取数据； 客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。 这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。 成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。 针对 UDP 协议通信的 socket 编程模型 UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。 对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。 另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。 针对本地进程间通信的 socket 编程模型 本地 socket 被用于在同一台主机上进程间通信的场景： 本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议； 本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现； 对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。 对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。 本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。 多线程冲突互斥锁​ 互斥（mutualexclusion），也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区，说白了，就是这段代码执行过程中，最多只能出现一个线程。 ​ 互斥在多线程、多进程竞争共享资源时候同样适用。 同步​ 同步（synchronization），就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。即b执行需要先等待a完成。 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等； 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」； 互斥、同步的实现和使用​ 其实就是使用好信号量、互斥量、原子操作。此处不展开。请看其他章节介绍。 死锁避免死锁互斥条件​ 互斥条件是指多个线程不能同时使用同一个资源。 ​ 比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。 请求保持条件​ 当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。 ​ 破局：一次申请全部条件，不逐个获取。 不可剥夺条件​ 不可剥夺条件是指，当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。 ​ 破局：当进程发现资源被其他进程占用，释放自己已获得的资源。 环路等待条件​ 环路等待条件指的是，在死锁发生的时候，两个线程获取资源的顺序构成了环形链。 比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。 并发，同步，异步，互斥，阻塞，非阻塞的理解1、什么是线程同步和互斥​ 线程同步和互斥都是多线程编程中常见的概念，用于确保数据的完整性和准确性，以及保证多个线程之间的有序执行。 线程同步： ​ 线程同步是指多个线程按照特定的顺序执行某些任务，以确保数据的准确性和完整性。这通常是为了防止多个线程同时访问共享资源，或确保某些任务按照预期的顺序执行。如（信号量、条件变量）。 互斥： ​ 互斥（或互斥锁）是一种同步机制，确保任何时候只有一个线程能够访问特定的代码段或资源。互斥是为了防止多个线程同时修改共享资源，从而可能导致数据的不一致状态。 区别： 互斥重点关注确保任何时候只有一个线程可以访问特定的资源或代码段。 同步更加广泛，除了互斥外，它还涉及确保线程按预期的顺序执行，等待条件等。 2、线程同步与阻塞的关系​ 线程同步和阻塞是多线程编程中的两个概念，它们经常在一起使用，但它们的意义是不同的。 线程同步： ​ 线程同步涉及到协调多个线程，以确保它们以适当和预期的方式访问共享资源或执行任务。同步通常用于防止多个线程同时访问共享资源，从而可能导致不一致的数据状态。 线程阻塞： ​ 线程阻塞是指线程在等待某个条件成真时停止执行。这可能是由于等待资源可用、等待其他线程完成工作或其他原因。在阻塞状态下，线程不会执行任何操作，直到被唤醒。 同步一定阻塞吗？ ​ 不一定。虽然许多同步机制会导致线程阻塞（例如，当一个线程尝试获取已被其他线程持有的互斥锁时），但有些同步策略不涉及阻塞。例如，”spinlocks”（自旋锁）是一种线程在等待获取锁时持续检查（自旋）的同步方法，而不是真正的阻塞。 阻塞一定同步吗？ ​ 不一定。线程可以因多种原因而被阻塞，不仅仅是为了同步目的。例如，线程可能因为等待I&#x2F;O操作完成、等待外部事件或只是调用sleep函数而被阻塞。 3、并发 描述了系统或应用程序同时处理多个任务的能力。 注意并发不一定意味着这些任务是“同时”执行的。它可能是通过快速在任务之间切换来模拟同时执行（如单核CPU上的多线程）。 4、总结：​ 并发描述了多任务处理的情境，不一定需要多个任务同时执行。 ​ 同步和阻塞经常在一起使用，并且它们在许多情况下都是相互关联的，但它们描述的是不同的概念。同步涉及到协调多个线程的行为，而阻塞描述了线程的一种非活动状态。不是所有的同步操作都导致线程阻塞，同样，不是所有的阻塞操作都是为了同步目的。 ​ 互斥是一种同步机制，确保对共享资源的独占访问。 孤儿进程、僵尸进程、守护进程的概念概念 孤儿进程 (Orphan Process): 基本: 当一个父进程在其子进程之前结束时，这些子进程会成为孤儿进程。 概念: 孤儿进程不再有一个父进程与之关联，但它们仍然在执行。在父进程结束后，孤儿进程的父进程ID(PID)会被设置为1，这意味着它们被init进程（或在某些系统上是systemd进程）“收养”。init进程会周期性地回收完成的孤儿进程，从而防止它们成为僵尸进程。 僵尸进程 (Zombie Process): 基本: 当一个子进程完成其执行并退出，但父进程尚未回收它的终止状态时，该子进程称为僵尸进程。 概念: 僵尸进程实际上不消耗任何系统资源（如CPU和内存），但仍会在进程表中保留一个条目。这是为了保留子进程的退出状态，以便父进程可以随后查询。僵尸进程存在的问题是，如果生成了大量的僵尸进程且它们未被清除，可能会导致进程表满，从而无法创建新的进程。通常，父进程通过调用wait()或waitpid()函数来回收子进程的状态并清除僵尸进程。 守护进程 (Daemon Process): 基本: 守护进程是一种在后台运行的进程，通常用于提供某种服务或功能，如日志记录、网络服务等。 概念: 守护进程通常在系统启动时启动，并持续运行，直到系统关闭。它们不与终端或用户会话关联，并且经常将其父进程设置为init进程（PID 1）。守护进程通常不直接与用户交互，而是通过文件、套接字或其他守护进程进行通信。 如何创建守护进程​ Linux系统中，创建守护进程涉及一系列步骤，以确保该进程完全在后台运行，与任何终端或用户会话无关，并正确处理资源和信号。 创建新的进程: 使用fork()创建新进程并终止父进程。 创建新的会话: 使用setsid()为新进程创建新的会话。 更改当前工作目录: 通常更改为根目录，确保守护进程不会锁定任何文件系统。 关闭所有打开的文件描述符。 重新打开标准输入、输出、错误描述符，通常重定向到&#x2F;dev&#x2F;null。 处理信号: 例如，处理SIGHUP以重新读取配置 此代码创建一个守护进程，它仅在后台运行并每60秒执行一个操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;void daemonize() &#123; pid_t pid; // Step 1: Fork off the parent process pid = fork(); if (pid &lt; 0) &#123; exit(EXIT_FAILURE); &#125; if (pid &gt; 0) &#123; exit(EXIT_SUCCESS); &#125; // Step 2: Create a new session if (setsid() &lt; 0) &#123; exit(EXIT_FAILURE); &#125; // Ignore signals signal(SIGCHLD, SIG_IGN); signal(SIGHUP, SIG_IGN); // Step 3: Fork again to ensure the daemon is not a session leader pid = fork(); if (pid &lt; 0) &#123; exit(EXIT_FAILURE); &#125; if (pid &gt; 0) &#123; exit(EXIT_SUCCESS); &#125; // Step 4: Change working directory chdir(&quot;/&quot;); // Step 5: Close all open file descriptors for (int x = sysconf(_SC_OPEN_MAX); x &gt;= 0; x--) &#123; close(x); &#125; // Reopen stdin, stdout, stderr open(&quot;/dev/null&quot;, O_RDWR); dup(0); dup(0);&#125;int main() &#123; daemonize(); // Daemon process logic starts here while (true) &#123; // Your daemon code here sleep(60); &#125; return 0;&#125; 如何处理僵尸进程​ 僵尸进程本身并不消耗任何系统资源（除了进程表中的一个条目），但如果大量的僵尸进程没有被清除，进程表可能会填满，从而导致系统无法创建新的进程。 以下是处理僵尸进程的几种方法： 使用wait()或waitpid()函数: 父进程可以通过调用wait()或waitpid()函数来回收已完成的子进程的终止状态。这将从进程表中删除对应的子进程条目，从而防止它们成为僵尸进程。 处理SIGCHLD信号: 当子进程终止时，操作系统会向其父进程发送一个SIGCHLD信号。父进程可以捕获这个信号并调用wait()或waitpid()来回收子进程的状态。 12345cCopy codevoid sigchld_handler(int signo) &#123; while (waitpid(-1, NULL, WNOHANG) &gt; 0);&#125;signal(SIGCHLD, sigchld_handler); WNOHANG标志使waitpid()在没有子进程终止时立即返回，从而允许处理器函数清除所有僵尸进程。 double fork技巧: 父进程首先fork一个子进程，然后立即等待它终止。而这个子进程再fork另一个子进程并立即终止。这样，第二个子进程将被init进程（或在某些系统上是systemd进程）“收养”，并且当它终止时，init进程将负责清除其状态，从而确保它不会成为僵尸进程。 使子进程脱离父进程: 子进程可以调用setsid()函数来开始一个新的会话，并与其父进程断开连接。这样，子进程将不再有父进程，因此在终止时不会成为僵尸进程。 总之，为了避免僵尸进程，重要的是父进程应该负责回收其所有已完成的子进程的状态，或者确保有其他机制来完成这项工作。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"}]},{"title":"【Linux】高频问题linux系统","slug":"【Linux】高频问题linux系统","date":"2023-09-02T16:00:00.000Z","updated":"2023-10-29T18:25:50.209Z","comments":true,"path":"2023/09/03/【Linux】高频问题linux系统/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/03/%E3%80%90Linux%E3%80%91%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98linux%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"【Linux】高频问题linux系统用户空间和内核空间通信的方式有什么系统调用： ​ 应用程序通过系统调用请求操作系统提供的服务，如文件操作、网络访问、进程控制。例如：open(), read(), write(), close() 等。 虚拟文件系统： ​ 操作系统提供特定的文件系统接口，允许用户空间应用直接读写这些文件，从而与内核交互。例如，在Linux上，可以通过读写&#x2F;proc和&#x2F;sys中的文件来获取系统信息或修改某些内核参数。 I&#x2F;O 控制 (IOCTL)： ​ ioctl 是一个多用途的系统调用，一般用于设备驱动程序，允许用户空间应用发送命令或请求到驱动程序。它通常用于不适合使用普通系统调用的那些特定的、不常见的设备操作。 信号： ​ 内核可以向用户空间进程发送信号，通知它某些事件发生，如终止请求、段错误等。 共享内存： ​ 内核可以与用户空间应用共享内存区域，使得它们可以直接读写同一块内存，从而实现高效的数据交换。 消息队列： ​ 进程间通信（IPC）机制，允许用户空间应用发送和接收消息。尽管这主要用于用户空间之间的通信，但某些操作系统实现（如Linux的netlink）允许内核和用户空间通过消息队列进行通信。 Socket： ​ 尤其是在Linux上，netlink套接字允许用户空间应用与内核空间进行通信，主要用于网络配置和监视。 中断和异常处理： ​ 当硬件设备需要注意或发生异常时，内核会接收到中断或异常，并可以选择将相关信息传递给用户空间。 内存映射 (mmap)： 用户空间应用程序可以使用 `mmap` 系统调用将文件或设备映射到其地址空间。这允许它直接访问内存，从而与内核或其他进程共享数据。 ​ 系统调用read()、write()具体做了什么工作​ 系统调用read()和write()是POSIX规范定义的基本I&#x2F;O操作，用于从文件或其他I&#x2F;O流中读取数据以及向文件或其他I&#x2F;O流中写入数据。在Linux中，几乎所有的I&#x2F;O操作，包括对普通文件、目录、设备文件、套接字等的操作，都可以使用这两个系统调用。 内核中的操作：** ​ 此函数从一个已打开的文件描述符（file descriptor）读取数据。通常，第一次读&#x2F;写操作从文件的当前偏移量开始，并在读&#x2F;写操作之后更新该偏移量。 内核的操作： 验证给定的文件描述符是否有效。 检查是否有权限从给定的文件描述符进行读&#x2F;写。 确定要读&#x2F;写的数据量和位置。 根据文件描述符类型（例如普通文件、套接字、字符设备等）进行特定的读&#x2F;写取操作。 从文件系统缓冲区或设备驱动程序读&#x2F;写数据。 将数据从内核复制到用户空间的缓冲区（或将用户空间缓冲区的数据复制到内核空间）。 更新文件的当前偏移量。 返回读&#x2F;写的字节数。 ​ 这些操作经过了多层抽象，并且可以根据文件类型、文件系统、驱动程序等进行特定的实现。例如，对于普通文件，read()和write()可能会涉及磁盘I&#x2F;O，而对于套接字，它们可能涉及网络I&#x2F;O。 ​ 系统调用的作用​ 系统调用是操作系统内核提供的一组函数接口，允许用户空间的应用程序请求内核执行特定的操作。这是用户空间程序与内核空间代码进行交互的主要方式。系统调用为应用程序提供了一种方法，使其能够使用由内核管理的资源和服务，如文件操作、进程控制、网络通信等。 系统调用的主要作用包括： 抽象硬件：系统调用为应用程序提供了一个统一的接口，使其可以访问硬件资源，而不必关心底层硬件的具体细节。 提供安全的权限控制：通过系统调用，操作系统可以限制用户程序的行为，防止其执行潜在危险的操作。例如，一个普通用户程序不能直接重启计算机，但它可以通过系统调用请求这样做，并由内核决定是否允许这种操作。 资源管理：操作系统负责管理计算机的资源，如CPU、内存、磁盘等。系统调用提供了一种方法，使应用程序能够请求、使用和释放这些资源。 进程控制：系统调用允许应用程序执行诸如创建、暂停或终止进程，以及进程间通信等任务。 文件操作：应用程序可以使用系统调用打开、读取、写入和关闭文件，以及执行其他与文件系统相关的操作。 设备操作：系统调用提供了与外部设备（如打印机、磁盘、网络卡等）交互的能力。 网络通信：系统调用允许应用程序创建套接字、发送和接收数据包，以及其他与网络通信相关的操作。 时间和计时：应用程序可以使用系统调用获取系统时间、设置闹钟或延时执行。 查询和设置系统信息：应用程序可以使用系统调用来查询或修改系统的运行时信息和配置。 ​ 总之，系统调用为应用程序提供了一个受控、安全的抽象接口，使其能够与计算机的硬件和系统资源交互。应用程序可以不管硬件和内核安全的执行其任务。确保资源访问的安全性和系统的稳定性。 ​ 内核态和用户态的区别​ 这两种模式的存在是为了隔离操作系统内核和用户程序，确保系统的稳定性和安全性。 权限: 内核态 ：CPU可以执行所有的指令和访问所有的内存地址。它拥有对系统资源的完全访问权限。 用户态：CPU的权限受到限制。尝试执行特定的敏感指令或访问受保护的内存区域会触发异常。 错误的影响: 内核态：在内核态下出现的错误通常会导致整个系统崩溃或不稳定。 用户态：用户态程序出现的错误通常只会影响该程序本身，而不会对整个系统产生影响。 上下文切换： 从用户态切换到内核态（或反之）需要上下文切换，这会产生一定的开销。这种切换通常通过系统调用、中断或异常来触发。 应用： 内核态：操作系统内核、设备驱动和其他系统级代码在内核态下运行。 用户态：应用程序、用户级工具和大多数软件都在用户态下运行。 安全和隔离： 通过将操作系统内核放在内核态并将应用程序放在用户态，操作系统可以确保用户程序不会直接访问或修改关键的系统资源和结构。 内存访问： 内核态：可以访问整个物理和虚拟内存，包括硬件的内存映射区域。 用户态：只能访问特定区域的虚拟内存（进程分配的内存）。尝试访问其他内存区域或执行某些特权指令会导致异常。 系统调用： 当用户态程序需要访问系统资源或执行某些只能在内核态完成的操作时，它会通过系统调用进入内核态。完成系统调用后，程序返回到用户态继续执行。 ​ 总之，内核态和用户态的区分是操作系统设计中的一种关键机制，用于确保系统的稳定性、安全性和隔离性。这种分隔使得操作系统能够控制和管理资源，防止恶意或错误的用户程序干扰系统的正常操作。 ​ bootloader、内核和跟文件系统的关系​ Bootloader、内核和根文件系统都是操作系统启动过程中的关键组成部分。 Bootloader：负责初始化硬件并加载操作系统内核（初始化硬件，比如设置时钟，初始化内存控制器等。加载操作系统内核到 RAM。跳转到内核的执行地址开始执行）。 内核：管理系统的硬件资源，提供程序运行时的各种服务（管理硬件资源，如 CPU、内存、I&#x2F;O 设备等。提供系统调用接口，应用程序通过这些接口请求内核的服务。进程管理，调度，内存管理等。）。 根文件系统：根文件系统包含操作系统和用户程序需要的各种文件（系统配置文件、系统库、用户程序和脚本、设备文件等）。 关系： Bootloader 到内核：Bootloader 负责将内核从存储设备加载到内存中，并将控制权转交给内核。这一过程可能包括解压缩内核映像（如果它被压缩的话）。 内核到根文件系统：内核在启动时，需要访问根文件系统来加载初始化脚本和程序，来继续启动过程。这通常包括挂载根文件系统，运行 init 程序等。 整体流程：电源开机 -&gt; Bootloader 启动并初始化硬件 -&gt; Bootloader 加载内核 -&gt; 内核初始化并挂载根文件系统 -&gt; 运行 init 进程 -&gt; 系统完全启动。 bootloader（U-boot）的启动过程简单的说，bootloader过程分为以下几步： 上电或重置：重置向量，开始执行。 初级启动阶段（ Secondary Program Loader）：初始化关键硬件 硬件初始化：进一步初始化硬件，这包括时钟、内存、外设接口如串口、网络接口、存储设备等 控制台初始化：U-Boot 在控制台上显示其版本信息和命令提示符，允许用户与其交互。 执行bootcmd：U-Boot 执行名为 bootcmd 的环境变量中定义的命令。用于定义如何查找和启动内核。 加载内核和设备树：根据 bootcmd，加载内核、加载设备树 blob（DTB），及硬件的结构和配置。 跳转到内核执行：地址并跳转到内核的起始地址，开始执行内核。 参数传递：传递信息给内核。这些参数可能包括 root 文件系统的位置、控制台的配置等。 这只是大致过程，不同平台可能会有一些区别。 rk平台处理器uboot启动过程：http://www.baku233.top/2023/09/12341234sdfg.html ​ linux内核由bootloader装载到内存吗？是啊！ ​ 为什么要bootloader&#x2F;uboot 硬件初始化: 在操作系统内核可以正常运行之前，需要进行一系列的硬件初始化操作，包括时钟设置、内存配置、外设设置等。Bootloader 负责这些初始化任务，为后续的系统启动创建一个稳定的环境。 通用性和灵活性: 与固定在硬件中的启动逻辑相比，bootloader 可以被更新和配置，以支持不同的启动场景。例如，U-Boot 支持从网络、SD 卡、USB 或其他存储介质启动。 简化内核设计: 由于 bootloader 负责初步的硬件初始化和配置，操作系统内核可以假定某些硬件已经被正确配置，从而简化其设计和初始化代码。 交互能力: 许多 bootloaders，如 U-Boot，提供了交互式命令行接口，允许用户更改启动参数、测试硬件功能或手动选择不同的启动选项。 支持多个操作系统: 一些 bootloader 可以配置为从不同的内核或操作系统映像中选择启动。例如，GRUB 可以让用户在 Linux、Windows 或其他操作系统之间进行选择。 预启动环境: Bootloader 为系统提供了一个预启动环境，可以进行故障排除、系统恢复和其他低级任务，而不需要完整的操作系统。 提供启动协议: 特别是在 ARM 或其他嵌入式系统中，bootloader 可以为内核提供设备树 (Device Tree) 信息，告诉内核关于硬件的配置和特性，这样内核就不需要为每种硬件配置重新编译。 保护和安全: 一些高级 bootloader（如电脑的 UEFI）提供安全启动机制，确保只有签名过的操作系统或应用程序能够执行。 linux内核同步方式总结​ Linux 内核提供了一系列的同步原语以支持多核和多线程环境中的并发操作。这些同步原语确保数据的一致性、防止数据竞争并帮助实现原子操作，还挺多。 自旋锁 (Spinlocks)：略 信号量 (Semaphores)：略 互斥量 (Mutexes)：略 读写锁 (Read-Write Locks)：适用于读操作远多于写操作的 可能基于信号量和互斥量。 RCU (Read-Copy Update): 允许读者和写者并发执行，特别适用于读操作远远多于写操作的场景（例如路由表、配置数据等），不需要传统的锁。 写者通过创建数据的一个新副本来实现更新，读者总是看到数据的一个一致的版本。 延迟回收机制 当新的数据副本被写入并被其他线程访问时，旧的数据仍然存在，因为可能还有读者正在访问它。 RCU 保证在删除旧数据之前，没有线程正在访问它。为了做到这一点，RCU 使用了一个名为“grace period”的机制。 在一个 grace period 期间，RCU 保证系统中的每个线程都至少被上下文切换一次（即从内核模式切换到用户模式，或者反过来）。 一旦 grace period 结束，可以确信没有线程还在访问旧的数据，因此可以安全地回收它。 RCU 读操作不需要锁，但写操作仍需同步机制（例如，自旋锁或信号量）来保护数据结构，确保只有一个写者修改数据。 顺序锁 (Seqlocks)：用于读操作多于写操作 位锁 (Bit Locks)：允许在一个字内为每一位设置锁，从而实现非常高的锁粒度。 原子操作 (Atomic Operations)：略 屏障 (Barriers)：用于确保一系列的读&#x2F;写操作按预期的顺序执行，防止编译器或处理器重排操作。 完全屏障 (Memory Barriers or Fences)：用于多处理器系统，确保某些操作的全局顺序。 为什么自旋锁不能睡眠，拥有信号量时候可以。奇葩问题？持有自旋锁时，再去尝试获取一个可能导致睡眠的信号量或其他可能导致睡眠的锁。。。 持有自旋锁，处于原子上下文，代码不能打断，会破格好坏数据结构完整性或引发竞争条件。 如果在自旋锁中键，不能进行会导致当前任务被调度出去的操作。会造成死锁啥的。而且这么做内核一般会触发信号BUG或WARN，生成调用栈回溯。 ​ linux下检查内存状态的指令 free -h top htop（需要安装） vmstat（看虚拟内存） swapon（看交换空间） pmap （看进程内存映射） 持续更新。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"}]},{"title":"【Linux】多线程喂狗","slug":"【Linux】多线程喂狗","date":"2023-09-01T16:00:00.000Z","updated":"2023-10-29T18:25:46.321Z","comments":true,"path":"2023/09/02/【Linux】多线程喂狗/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/02/%E3%80%90Linux%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%96%82%E7%8B%97/","excerpt":"","text":"多线程喂狗实现原理 创建看门狗线程，用于监控各个线程 为每个需要喂狗的线程定义一个信号&#x2F;事件&#x2F;结构体。 线程中定期给出信号或事件，使用结构体则修改其内容。 看门狗线程根据线程的操作，判断是否正常，从而选择是否重启程序或重启线程。 单内核操作系统（linux）linux可以使用eventfd、信号量、互斥量实现多线程看门狗，此处使用互斥量。 多个线程需要在程序中定期调用Watchdog::heartbeat，来告诉看门狗，我还活着。若退出某线程，退出前务必调用Watchdog::removeThread。否则会一直提示看门狗超时。代码仅供参考，在应用环境还需要做更多处理。 一个完整的看门狗线程需要包含：心跳检测、超时机制、恢复措施、日志通知、参数可配置、清理与管理、安全机制、互斥并发。此处代码仅实现：心跳检查、超时机制、清理、互斥并发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Watchdog &#123; private: int efd; private: std::map&lt;std::string, std::chrono::time_point&lt;std::chrono::steady_clock&gt;&gt; lastHeartbeats;// 使用模板类，用名字索引，内容是上次心跳的时间。 private: std::mutex heartbeatMutex; private: std::thread watchThread; private: std::condition_variable cv; private: bool shutdown = false; private: void watch() &#123; while (!shutdown) &#123; std::unique_lock&lt;std::mutex&gt; lock(heartbeatMutex); cv.wait_for(lock, std::chrono::milliseconds(100), [this]() &#123; return shutdown; &#125;); auto now = std::chrono::steady_clock::now(); for (auto&amp; pair : lastHeartbeats) &#123; if (now - pair.second).count() &gt; std::chrono::milliseconds(500)) &#123; std::cout &lt;&lt; &quot;Watchdog triggered. No heartbeat received from &quot; &lt;&lt; pair.first &lt;&lt; std::endl; // 你可以在这里加入恢复措施，比如重启线程 &#125; &#125; &#125; &#125; public: Watchdog() &#123; watchThread = std::thread(&amp;Watchdog::watch, this); &#125; public: ~Watchdog() &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(heartbeatMutex); shutdown = true; &#125; cv.notify_one(); if (watchThread.joinable()) watchThread.join(); &#125; public: void heartbeat(const std::string&amp; threadName) &#123; std::lock_guard&lt;std::mutex&gt; lock(heartbeatMutex); lastHeartbeats[threadName] = std::chrono::steady_clock::now(); std::cout &lt;&lt; &quot;Heartbeat received from &quot; &lt;&lt; threadName &lt;&lt; std::endl; &#125; public: void removeThread(const std::string&amp; threadName) &#123; std::lock_guard&lt;std::mutex&gt; lock(heartbeatMutex); lastHeartbeats.erase(threadName); &#125;&#125;;void work1_thread(Watchdog&amp; watchdog) &#123; while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(200)); watchdog.heartbeat(&quot;work1&quot;); &#125;&#125;void work2_thread(Watchdog&amp; watchdog) &#123; while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(300)); watchdog.heartbeat(&quot;work2&quot;); &#125;&#125;int main() &#123; Watchdog watchdog; std::thread work1(&amp;work1_thread, std::ref(watchdog)); std::thread work2(&amp;work2_thread, std::ref(watchdog)); work1.join(); work2.join(); return 0;&#125; 微内核操作系统（FreeRTOS）FreeRTOS可以使用事件方式来实现多线程看门狗。以下代码只保留核心部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 定义事件组EventGroupHandle_t watchdogEventGroup;#define TASK1_WATCHDOG (1 &lt;&lt; 0)#define TASK2_WATCHDOG (1 &lt;&lt; 1)// 看门狗任务void watchdogTask(void* arg) &#123; const TickType_t xMaxBlockTime = pdMS_TO_TICKS(MAX_TIME_MS); while (1) &#123; // 等待所有任务的事件位都被设置 EventBits_t uxBits = xEventGroupWaitBits( watchdogEventGroup, // 事件组句柄 TASK1_WATCHDOG|TASK2_WATCHDOG, // 等待的事件位 pdTRUE, // 清除所有设置的事件位 pdTRUE, // 等待所有指定的事件位都被设置 xMaxBlockTime // 最大阻塞时间 ); if ((uxBits &amp; (TASK1_WATCHDOG | TASK2_WATCHDOG)) == (TASK1_WATCHDOG | TASK2_WATCHDOG)) &#123; // 所有任务都正常喂了狗 &#125; else &#123; // 至少有一个任务没有喂狗，可以采取相应的措施 if ((uxBits &amp; TASK1_WATCHDOG) == 0) &#123; // 任务1没有喂狗 &#125; if ((uxBits &amp; TASK2_WATCHDOG) == 0) &#123; // 任务2没有喂狗 &#125; // 更多的任务检查... &#125; &#125;&#125;// 需要监控的线程void workerTask1(void* arg) &#123; while (1) &#123; // 执行... // 喂狗：设置任务1的事件位 xEventGroupSetBits(watchdogEventGroup, TASK1_WATCHDOG); vTaskDelay(10); &#125;&#125;void workerTask2(void* arg) &#123; while (1) &#123; // 执行... // 喂狗：设置任务2的事件位 xEventGroupSetBits(watchdogEventGroup, TASK2_WATCHDOG); vTaskDelay(10); &#125;&#125;// mainvoid main(void) &#123; // 硬件初始化，如时钟、中断等... // 创建事件组 watchdogEventGroup = xEventGroupCreate(); // 创建任务 xTaskCreate(workerTask1, &quot;WorkerTask1&quot;, STACK_SIZE, NULL, PRIORITY1, NULL); xTaskCreate(workerTask2, &quot;WorkerTask2&quot;, STACK_SIZE, NULL, PRIORITY2, NULL); // 创建看门狗任务 xTaskCreate(watchdogTask, &quot;WatchdogTask&quot;, STACK_SIZE, NULL, WATCHDOG_PRIORITY, NULL); // 启动调度器 vTaskStartScheduler(); for(;;);&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"}]},{"title":"【Linux】VsCode使用CMake配置C++环境","slug":"【Linux】VsCode使用CMake配置C++环境","date":"2023-08-31T16:00:00.000Z","updated":"2023-10-30T05:48:30.314Z","comments":true,"path":"2023/09/01/【Linux】VsCode使用CMake配置C++环境/","link":"","permalink":"https://bakuenkou.gitee.io/2023/09/01/%E3%80%90Linux%E3%80%91VsCode%E4%BD%BF%E7%94%A8CMake%E9%85%8D%E7%BD%AEC++%E7%8E%AF%E5%A2%83/","excerpt":"","text":"VsCode需要安装的插件1、Tabnine: AI Autocomplete &amp; Chat for Javascript, Python, Typescript, PHP, Go, Java &amp; more 2、Makefile Tools 3、CMake Tools 4、CMake Language Support 5、CMake 6、Chinese (Simplified) (简体中文) Language Pack for Visual 7、Studio Code 8、C/C++ Themes 9、C/C++ Project Generator 10、C/C++ Extension Pack 11、C/C++ 12、Better C++ Syntax 13、NET Install Tool for Extension Authors 编写CMakeLists.txt多文件、多目录 根目录CMakeLists.txt#CMake 最低版本号要求 cmake_minimum_required(VERSION 3.0) #指定工程名 project(SoliderFire) #包含目录 include_directories($&#123;PROJECT_SOURCE_DIR&#125;/inc) #链接子目录CMakeFiles.txt add_subdirectory(src) #链接静态库 link_libraries(src) #指定C/C++编译器 set(CMAKE_C_COMPILER &quot;/usr/bin/gcc&quot;) set(CMAKE_CXX_COMPILER &quot;/usr/bin/g++&quot;) #指定C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) #指定编译选项 set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;) set(CMAKE_BUILD_TYPE Debug) #生成可执行文件 main add_executable(myexe main.cpp) #add_executable($&#123;PROJECT_NAME&#125; main.cpp) 次级目录CMakeLists.txtcmake_minimum_required(VERSION 3.0) project(src) #搜索源文件 aux_source_directory(./ SRC) #编译静态库文件 add_library(src $&#123;SRC&#125;) .vscode配置c_cpp_properties.jsonincludePath：添加文件路径，写代码时候vscode就不会有红色波浪线。compilerPath：g++目录，实际而定。 &#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;$&#123;workspaceFolder&#125;/**/inc&quot;, &quot;$&#123;workspaceFolder&#125;/**/src&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/g++&quot;, &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot; &#125; ], &quot;version&quot;: 4 &#125; launch.jsonvscode生成的，略微修改即可修改成cmake生成的执行文件目录。 “program”: “${workspaceFolder}&#x2F;build&#x2F;myexe” 运行vscode时候执行的任务名字，与tasks.json有关联 “preLaunchTask”: “Build” gdb路径 “miDebuggerPath”:”&#x2F;usr&#x2F;bin&#x2F;gdb” name，随便写，debug时候别选错就行 “name”: “g++ cmake 启动” &#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++ cmake 启动&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/myexe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;Build&quot;, &quot;miDebuggerPath&quot;:&quot;/usr/bin/gdb&quot; &#125; ] &#125; tasks.json cwd：在此目录生成执行文件 shell任务执行：cmake .. make任务执行：make build任务执行：shell和make build任务在launch.json中执行。 &#123; &#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;mkdir&quot;, &quot;command&quot;: &quot;mkdir&quot;, &quot;args&quot;: [ &quot;-p&quot;, &quot;build&quot; ] &#125;, &#123; &quot;label&quot;: &quot;cmake&quot;, &quot;command&quot;: &quot;cmake&quot;, &quot;args&quot;: [ &quot;-B&quot;, &quot;$&#123;workspaceFolder&#125;/build&quot;, &quot;-S&quot;, &quot;.&quot; ] &#125;, &#123; &quot;label&quot;: &quot;make&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;command&quot;: &quot;make&quot;, &quot;args&quot;: [], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot; &#125; &#125;, &#123; &quot;label&quot;: &quot;Build&quot;, &quot;dependsOrder&quot;: &quot;sequence&quot;, &quot;dependsOn&quot;: [ &quot;mkdir&quot;, &quot;cmake&quot;, &quot;make&quot; ] &#125; ] &#125; Debug代码","categories":[{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"},{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"}]},{"title":"【Life】仙英座流星雨","slug":"【Life】仙英座流星雨","date":"2023-08-11T16:00:00.000Z","updated":"2023-10-29T04:41:26.224Z","comments":true,"path":"2023/08/12/【Life】仙英座流星雨/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/12/%E3%80%90Life%E3%80%91%E4%BB%99%E8%8B%B1%E5%BA%A7%E6%B5%81%E6%98%9F%E9%9B%A8/","excerpt":"","text":"美女看了微博后跟我说：“今晚有流星雨！！！！冲啊！”，随后扔给我好多张观看流星雨最佳的位置（都好远啊）。 晚上10点，穿上各种保暖衣服，带好零食。前往比较近的一个山头看流星雨（王位山），这个上山路是真的难开，弯弯绕绕。还有很多人也驱车来看流星雨了，好一段山路堵车！ 个人认为王位山山顶位置不是最佳观测的地方，上面人很多，很多灯光设备。所以我选了一个半山腰的位置，有一个亭子，黑漆漆的~ nice 晚上11点半一直看到了凌晨一点，看到了近十颗流星雨，看流星雨的过程和钓鱼一样，越心急越看不到。晚上我观测到的流星雨中，有一颗特别大，特别亮的流星雨，拖着长长的尾巴，整座王位山的人都在为看到这颗流星而欢呼！（真的特别耀眼） 山腰的亭子 来看图找找仙后座呀哈哈哈哈~","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【C++】智能指针（Smart Pointer）","slug":"【C++】智能指针（Smart Pointer）","date":"2023-08-04T16:00:00.000Z","updated":"2023-10-29T18:24:53.413Z","comments":true,"path":"2023/08/05/【C++】智能指针（Smart Pointer）/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/05/%E3%80%90C++%E3%80%91%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88Smart%20Pointer%EF%BC%89/","excerpt":"","text":"概述​ 智能指针是C++中的一种对象，它的设计初衷是为了解决原生指针在资源管理上的一些问题。C++11 开始提供了几种类型的智能指针，std::auto_ptr（已被废弃，不推荐使用），std::unique_ptr，std::shared_ptr 和 std::weak_ptr。 ​ 智能指针由以下几个好处： ​ 自动内存管理：智能指针会自动释放其指向的对象，当智能指针超出其作用范围或被显式重置时，它将负责删除其所指向的对象。这大大减少了因手动管理内存而导致的内存泄漏的风险。 ​ 自动销毁、防止悬垂：当没有任何智能指针指向某个对象时（例如，对于 std::shared_ptr，引用计数变为0），该对象会被自动销毁。悬垂指针通常是由于对象已被删除，但仍有指针指向它造成的。智能指针通过所有权管理和引用计数来降低这种风险。 ​ 兼容性好：智能指针可以与C++标准库容器一起使用，如 std::vector&lt;std::shared_ptr&lt;T&gt;&gt;。 ​ 安全的自定义删除器：智能指针允许用户提供自定义删除器，这对于特殊资源（如文件句柄、套接字或自定义内存分配器）的管理非常有用。 ​ 移动语义支持：特别是 std::unique_ptr，支持C++11引入的移动语义，使资源所有权的转移更加直观和高效。 unique_ptr​ 这个实际上模板类，提供一些机制保证堆上分配的对象的指针离开作用域时候，会自动释放。基本无开销。并且进入unique_ptr实现时候可以发现，他显示的删除了复制构造函数和复制赋值操作符（&#x3D;操作）。 ​ 删除复制构造函数后，意味着你不能复制这个对象，无法执行例如把函数指针当作函数的值传递入参。因为值传递时候会对目标进行复制。但是可以引用传递和右值引用（&amp;&amp;）来传递它们。 ​ 右值引用：一般移动构造函数或移动赋值操作符一起使用，允许资源的所有权从一个对象转移到另一个对象。 1234567891011121314void foo(std::unique_ptr&lt;int&gt;&amp; ptr) &#123;&#125;void bar(std::unique_ptr&lt;int&gt;&amp;&amp; ptr) &#123;&#125;void func(std::unique_ptr&lt;int&gt; ptr) &#123;&#125;int main() &#123; std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(10);//引入于 C++14 标准 //std::unique_ptr&lt;int&gt; ptr(new int(10)); //低于 C++14 标准使用这个！！ //std::unique_ptr&lt;int&gt; ptr = new int(10); //false：构造函数不接受裸指针作为参数 func(ptr); // Will compile errors func(std::move(ptr)); // Pass by ownership is OK foo(ptr); // Pass by reference is fine. bar(std::move(ptr)); // Pass by rvalue reference using std::move.&#125; 用法：拥有其指向的对象的唯一所有权。 区别：不能复制，可以移动。 优点：轻量级，安全的资源所有权管理 缺点：无法共享所有权 用途：希望一个对象只有一个所有者时候使用。 shared_ptr​ 这玩意工作方式是使用引用计数，用来跟踪你的指针有多少个引用。一旦引用计数为0，则删除指针。 ​ 使用shared_ptr务必使用make_shared（引入于 C++11 标准）： 1、避免异常安全情况：比如fun(std::shared_ptr(new int(10)), std::shared_ptr(new int(20)));分为三个过程1、new int(10)。2、new int(20)。3、std::unique_ptr 构造函数调用。 ​ 如果 new int(10) 成功执行并分配了内存，但在执行 new int(20) 时由于某种原因（例如内存不足）抛出异常。在这种情况下，因为 std::shared_ptr的构造函数还没有开始执行，所以 new int(10)&#96; 分配的内存不会被释放，导致内存泄漏。 2、效率高：这个操作可以在一个原子操作完成，使用new则需要两次分配内存，一次是对象本身，一次是控制块（储存引用计数），提高效率高。 3、内存连续性：由于 std::make_shared 通常在一个连续的内存块中同时分配对象数据和控制块，这可以为某些缓存友好的应用程序提供性能优势。 4、*避免裸指针***：使用 std::make_shared 的另一个优势是避免暴露裸指针，减少了出错的机会。 12345678910111213141516class Entity &#123; public: Entity() &#123; std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl &#125; ~Entity() &#123; std::cout &lt;&lt; &quot;Destroyed Entity!&quot; &lt;&lt; std::endl &#125;&#125;;int main() &#123; &#123; std::shared_ptr&lt;Entity&gt; ptr; &#123; std::shared_ptr&lt;Entity&gt; fuck = std::make_shared&lt;Entity&gt;(); ptr = fuck;// 进行复制赋值操作 &#125;//1 &#125;//2 return 0;&#125; Debug以上代码可以发现，代码在执行make_shared时候，调用了构造函数，当执行完第一个花括号时候，并没有执行析构函数，在执行完第二个花括号时候才执行了析构函数。这就是引用计数~ 用法：多个 shared_ptr 可以共享对同一个对象的所有权。 区别：使用引用计数来确保只有在最后一个指向对象的 shared_ptr 被销毁或重置时，对象才会被删除。 优点：可以共享资源所有权。 缺点：相对于 unique_ptr 更重，因为它需要管理引用计数。 用途：当你希望多个指针共享一个对象的所有权时使用。 weak_ptr弱指针，Debug以下代码可以发现，代码在执行make_shared时候，调用了构造函数，当执行完第一个花括号时候时候就执行了析构函数。第一个花括号处。weak_ptr指向一个无效的Entity~ 12345678910111213141516class Entity &#123; public: Entity() &#123; std::cout &lt;&lt; &quot;Created Entity!&quot; &lt;&lt; std::endl &#125; ~Entity() &#123; std::cout &lt;&lt; &quot;Destroyed Entity!&quot; &lt;&lt; std::endl &#125;&#125;;int main() &#123; &#123; std::weak_ptr&lt;Entity&gt; ptr; &#123; std::shared_ptr&lt;Entity&gt; fuck = std::make_shared&lt;Entity&gt;(); ptr = fuck;// 进行复制赋值操作 &#125;//1 &#125;//2 return 0;&#125; 用法：它是对 shared_ptr 的一种弱引用，不会增加引用计数。 区别：当与之相关联的 shared_ptr 被销毁时，weak_ptr 不会阻止对象被删除。 优点：避免 shared_ptr 之间的循环引用问题。 缺点：不能直接使用，必须先转化为 shared_ptr。 用途：当你需要一个不参与引用计数的指针，特别是为了避免循环引用时使用。","categories":[{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]},{"title":"【C++】高频问题（继承、多态）","slug":"【C++】高频问题（继承、多态）","date":"2023-08-03T16:00:00.000Z","updated":"2023-10-29T18:24:44.909Z","comments":true,"path":"2023/08/04/【C++】高频问题（继承、多态）/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/04/%E3%80%90C++%E3%80%91%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%EF%BC%88%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89/","excerpt":"","text":"继承和虚继承 继承：允许一个类（派生类）从另一个类（基类）继承属性和行为。且基类的公有和保护成员默认被派生类继承。 虚继承：是一种特殊的继承，用于解决多个派生类从同一个基类继承而导致的冗余和歧义问题（钻石问题）。使用虚继承时，来自虚基类的成员在内存中只有一个副本，无论基类被继承了多少次。 钻石问题：当多个类继承自一个类，并且另一个类从这些类多重继承时，就可能出现钻石问题。例如，Vehicle -&gt; Car 和 Boat，然后 AmphibiousVehicle 从 Car 和 Boat 继承。为了避免 AmphibiousVehicle 中有两个 Vehicle 副本，可以使用虚继承。 总结：普通继承主要用于实现类型的“是一个”关系，如 “Cat” 是一个 “Animal”。虚继承主要用于解决由于多重继承而导致的冗余和歧义问题。 多态的类，内存布局是怎样的多态在 C++ 中通常通过虚函数来实现。要支持多态行为，C++ 使用了虚函数表（vtable）的机制。 假设有以下的基类和派生类： 12345678910111213class Base &#123;public: virtual void func1() &#123;&#125; virtual void func2() &#123;&#125; int baseData;&#125;;class Derived : public Base &#123;public: virtual void func1() override &#123;&#125; virtual void func3() &#123;&#125; int derivedData;&#125;; 以下是基于此代码的对象的内存布局的一种典型表示： 123456789101112131415Base object:+------------------+| vptr | --&gt; Points to vtable for Base+------------------+| baseData |+------------------+Derived object:+------------------+| vptr | --&gt; Points to vtable for Derived+------------------+| baseData |+------------------+| derivedData |+------------------+ vtable 是一个包含指向类的虚函数的指针的数组。 类的每一个对象都有一个指向它的类的 vtable 的指针，这个指针通常被称为 vptr。 vtable 使得在运行时能够正确地解析应该调用哪一个虚函数版本。 对于上述 Base 和 Derived 类的对象，其相关的 vtable 可能如下： 123456789101112131415vtable for Base:+------------------+| Address of Base::func1 |+------------------+| Address of Base::func2 |+------------------+vtable for Derived:+------------------+| Address of Derived::func1 | (Overridden from Base)+------------------+| Address of Base::func2 | (Not overridden, so Base&#x27;s version is used)+------------------+| Address of Derived::func3 |+------------------+ 当我们通过基类指针调用一个虚函数时，编译器会使用这个对象的 vptr 来查找正确的函数地址。 此处描述的内存布局和vtable机制是基于C++标准和许多常用编译器的典型实现。这种实现方式在多个平台和操作系统上，如Windows、Linux和macOS，以及各种编译器，如GCC、Clang和MSVC，都是普遍存在的。 确切的细节，如vptr和vtable在内存中的位置、其他可能的元数据等，可能会根据不同的编译器和它们的版本、平台、编译器选项和优化级别略有不同。 此处为通用的、概念性的理解。如想了解特定于某个编译器或系统的内部细节，需要参考相关的编译器文档或使用工具（如objdump或gdb在Linux上）来检查生成的二进制代码和数据结构。 被隐藏的基类函数和基类成员变量 and 子类调用父类的同名函数和同名成员变量被隐藏的基类函数和基类成员变量： ​ 当子类有一个与父类同名的成员（函数或变量），该成员会隐藏父类的同名成员。 子类调用父类的同名函数和同名成员变量： ​ 若想在子类中调用父类的同名函数或访问父类的成员变量，你可以使用 作用域解析运算符 :: 如以下例子： 123456789101112131415161718192021222324class Base &#123;public: int value = 20; void foo() &#123; std::cout &lt;&lt; &quot;Base::foo() called&quot; &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: int value = 10; void foo() &#123; std::cout &lt;&lt; &quot;Derived::foo() called&quot; &lt;&lt; std::endl; &#125; void callBaseFoo() &#123; Base::foo(); std::cout &lt;&lt; &quot;Base value: &quot; &lt;&lt; Base::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Derived value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Derived d; d.foo(); // 输出：Derived::foo() called d.callBaseFoo(); // 输出：Base::foo() called和变量&#125; 多态的三个条件和实现原理多态的三个条件： 继承：必须存在基类和派生类的关系。 虚函数：基类必须定义一个或多个虚函数，供派生类重写。 基类指针或引用：为了实现多态，我们需要使用基类的指针或引用来指向派生类的对象，即在编译时，你编写的代码基于基类的接口，但在运行时，代码会根据实际传入的对象类型动态选择合适的方法。如下 1234567891011121314151617181920class Animal &#123;public: virtual void makeSound() const &#123; std::cout &lt;&lt; &quot;The animal makes a sound.&quot; &lt;&lt; std::endl; &#125;&#125;;class Cat : public Animal &#123;public: void makeSound() const override &#123; std::cout &lt;&lt; &quot;The cat meows.&quot; &lt;&lt; std::endl; &#125;&#125;;void SoundOfAnimal(const Animal &amp;animal) &#123; animal.makeSound();&#125;int main() &#123; Cat myCat; SoundOfAnimal(myCat); // Outputs: &quot;The cat meows.&quot;&#125; 原理： ​ 多态的实现在 C++ 中依赖于虚函数表（vtable）和虚函数指针（vptr）。 虚函数表（vtable）：每个有虚函数的类都有一个与之关联的虚函数表。vtable 是一个存储函数指针的数组，其中的每个函数指针都指向该类中的一个虚函数。这些函数可以是定义在本类中的，也可以是从基类继承过来的。 虚函数指针（vptr）：类的每个对象都有一个虚函数指针（通常称为 vptr），它指向与该对象关联的类的 vtable。vptr 在对象创建时自动设置，指向适当的 vtable。 可参考上面的 多态的类，内存布局是怎样的 拷贝构造函数、深浅拷贝的理解和用途，何时需要自定义拷贝构造函数拷贝构造函数：当从一个对象创建另一个对象的副本时，会调用拷贝构造函数。如下： ClassName(const ClassName&amp; source); 深拷贝：不仅复制对象的每个成员，还复制指针指向的数据。这样，两个对象就不会共享相同的资源，从而避免了浅拷贝中的问题。 浅拷贝：简单地复制对象的每个成员。对于基本数据类型浅拷贝是可以的，但是对于指针或动态分配的资源可能会出问题。因为复制的是指针本身，而不是指向的数据。如果你释放其中一个对象的资源，其他对象也会被影响，因为它们共享同一块内存。 何时需要自定义拷贝构造函数？ 管理动态分配的内存：若类有指向动态分配的内存的指针，你需要提供深拷贝逻辑来确保新的对象有自己的内存副本。 管理资源：除内存外，如果类管理其他资源，如文件、网络连接或数据库连接，你可能也需要自定义拷贝构造函数来正确复制这些资源。（比如说文件句柄，当复制该类的对象时，你可能想为新对象打开一个新的文件句柄，而不是共享同一个句柄。） 引用计数：如果你的类使用引用计数来管理资源（如智能指针的拷贝构造中，会增加引用计数。析构时候减少引用计数，计数为0则销毁），则需要自定义拷贝构造函数来更新引用计数。 修改拷贝行为：如果你想在复制对象时提供一些特殊的行为，比如记录拷贝操作或修改某些成员的值。 析构函数可以抛出异常吗？首先析构函数可以抛出异常。 但是在析构中抛出异常是一个不好的做法，会设计很多相关风险问题。如下 双重异常问题：如果在析构期间抛出一个异常，而另一个异常已经在处理，那么std::terminate会被调用，导致程序终止。这是因为C++不允许有两个未处理的异常同时存在。 难以捕获：当对象在栈上销毁或作为部分容器被销毁时，你可能无法明确地捕获析构函数中的异常。 RAII原则违背：在C++中，一种常用的资源管理技术是资源获取即初始化（RAII）。其中，构造函数用于获取资源，而析构函数用于释放资源。如果析构函数中存在异常抛出的可能性，RAII的安全性和可靠性就会被破坏。 资源泄漏：如果析构函数早期退出并且没有适当地清理资源，那么可能会导致资源泄漏。 可维护性降低：析构函数中的异常使代码更难以理解和维护，因为你必须密切关注析构逻辑以确保所有路径都适当地处理资源并且不会抛出异常。 其他析构函数可能不会被调用：如果在析构函数中抛出异常，其他还未调用的析构函数可能不会被执行，导致潜在的资源泄漏和未定义的行为。 什么情况调用拷贝构造函数 直接初始化：ClassName obj2 = obj1; 传递对象作为函数参数：someFunction(objClass); 函数返回对象： ClassName someFunction() &#123; ClassName obj; return obj; // 可能调用拷贝构造函数，但因为RVO，实际拷贝可能会被优化掉 &#125; 123456789- **拷贝初始化：**`ClassName obj2(obj1); `- **在容器中存储对象：**- ```c++ std::vector&lt;ClassName&gt; vec; ClassName obj; vec.push_back(obj); // 调用拷贝构造函数（emplace方法可以避免此拷贝） 初始化聚合类或结构体的成员：若一个类或结构体包含其他类的对象，则对象可以通过拷贝构造函数进行初始化。 析构函数一般写成虚函数原因为了确保派生类对象的正确析构，尤其是当派生类对象通过基类指针或引用进行删除时。 123456789101112131415161718192021222324class Base &#123;public: Base() &#123; std::cout &lt;&lt; &quot;Base Constructor&quot; &lt;&lt; std::endl; &#125; ~Base() &#123; std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl; &#125; //错招 virtual ~Base() &#123; std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl; &#125;//正招&#125;;class Derived : public Base &#123;public: int* arr; Derived() &#123; arr = new int[10]; std::cout &lt;&lt; &quot;Derived Constructor&quot; &lt;&lt; std::endl; &#125; ~Derived() &#123; delete[] arr; std::cout &lt;&lt; &quot;Derived Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Base* ptr = new Derived(); delete ptr; return 0;&#125; 错招：如果你执行 delete ptr;，会发现只有 Base 的析构函数被调用，而 Derived 的析构函数没有被调用。这可能导致资源泄漏。 正招：执行 delete ptr;，首先会调用 Derived 的析构函数，然后才是 Base 的析构函数，从而确保所有的资源都被正确地释放。 构造函数为什么不定义为虚函数​ 虚构造函数在 C++ 中没有意义，并且不被允许。 对象实例化的本质：当你创建一个对象（实例化一个类），该对象的内存首次被分配，构造函数被调用来初始化这些内存。但是在对象创建时，它的虚函数表（vtable）还没有被建立。因为构造函数是为了设置这种基础设置和初始化的，所以它不能是虚的。 虚函数的实现机制：虚函数依赖于每个对象的虚函数表（vtable）。对象的 vtable 在构造函数被调用时才被设置。因此，构造函数的虚拟化意味着它会使用一个还没有建立的 vtable，这是不可能的。 语义上的问题：构造函数的目的是创建和初始化对象。当我们创建一个派生类的对象时，基类的构造函数首先被调用，然后是派生类的构造函数。这确保了对象从基本部分到更专门的部分被正确初始化。将构造函数设置为虚函数没有明确的意义，因为我们已经有一个确定的顺序来调用构造函数。 没有继承的构造函数：在 C++ 中，构造函数不被派生类继承。每个类都有其自己的构造函数。如果你试图通过派生类的对象调用基类的构造函数，它总是明确地知道要调用哪个构造函数，因此不需要虚构造函数。 静态绑定和动态绑定介绍静态绑定和动态绑定是编程中两种不同的函数调用机制。它们主要涉及到面向对象编程，特别是在存在继承和多态时。 静态绑定（早期绑定）: 定义: 静态绑定是在编译时确定要调用的函数版本的过程。 特点: 函数的调用地址在编译时被确定，并在生成的机器代码中硬编码。 适用情况: 非虚成员函数、静态成员函数和全局函数通常使用静态绑定。 性能: 由于不需要运行时的查找过程，通常性能稍好。 动态绑定（晚期绑定）: 定义: 动态绑定是在运行时根据对象的实际类型来确定要调用的函数版本的过程。 特点: 它依赖于虚函数表（vtable）来确定在运行时要调用的正确的函数版本。每个有虚函数的类的对象都有一个指向其vtable的指针。 适用情况: 只有通过指针或引用调用的虚函数才会使用动态绑定。 性能: 动态绑定涉及到在运行时查找适当的函数地址，通常会比静态绑定略慢，但这种差异在现代计算机上通常是微不足道的。 123456789101112131415161718192021class Base &#123;public: void ShowStatic() &#123; std::cout &lt;&lt; &quot;Base (static)&quot; &lt;&lt; std::endl; &#125; virtual void ShowDynamic() &#123; std::cout &lt;&lt; &quot;Base (dynamic)&quot; &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base &#123;public: void ShowStatic() &#123; std::cout &lt;&lt; &quot;Derived (static)&quot; &lt;&lt; std::endl; &#125; virtual void ShowDynamic() &#123; std::cout &lt;&lt; &quot;Derived (dynamic)&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Base* b = new Derived(); Derived * c = new Derived(); b-&gt;ShowStatic(); //静态绑定：输出 Base (static) b-&gt;ShowDynamic(); //动态绑定：输出 Derived (dynamic) c-&gt;ShowStatic(); //静态绑定：输出 Derived (static) c-&gt;ShowDynamic(); //动态绑定：输出 Derived (dynamic) delete b; delete c;&#125; 调用动态绑定函数时候，涉及虚函数的查找，可以参考上面虚函数的介绍。首先是访问对象的虚函数表指针，根据这个指针，找到对应函数。b和c的对象都是Derived类型。 C++所有构造函数 默认构造函数：Example() &#123;&#125; 参数化构造函数：Example(int val) : data(val) &#123;&#125; 拷贝构造函数： Example(const Example&amp; source) &#123;&#125; 移动构造函数：Example(Example&amp;&amp; source) &#123;&#125; 委托构造函数： Example() : Example(0) &#123;&#125; &#x2F;&#x2F; Delegates to the parameterized constructor Example(int value) &#123;&#125; &#x2F;&#x2F; initialize with value 显示构造函数：explicit Example(int value) {} 重写、重载、覆盖区别 重载 (Overloading) 描述：在同一作用域内，函数名称相同但参数列表不同（包括参数的类型、顺序或数量）。 适用范围：可以重载普通函数或类成员函数。 示例： 123void display(int a);void display(double b);void display(int a, double b); 覆盖 (Overriding) 描述：在派生类中，派生类提供一个与基类中某个虚函数签名完全相同的函数。 前提：基类中的函数必须被声明为virtual。 注意：覆盖涉及到基类和派生类之间的关系。当基类的虚函数被派生类覆盖时，如果通过基类指针或引用调用该函数，实际上会调用派生类中的版本（前提是该指针或引用指向的是派生类的对象）。 示例： 123456789class Base &#123;public: virtual void display() &#123; std::cout &lt;&lt; &quot;Base display&quot;; &#125;&#125;;class Derived : public Base &#123;public: void display() override &#123; std::cout &lt;&lt; &quot;Derived display&quot;; &#125; // 覆盖基类的display() 函数&#125;; 重写 (Redefining) 描述：在派生类中重新定义基类中的非虚函数。 注意：与覆盖不同，重写并不保证动态分派。即，如果通过基类指针或引用调用该函数，将调用基类的版本，而不是派生类的版本。 示例： 123456789class Base &#123;public: void display() &#123; std::cout &lt;&lt; &quot;Base display&quot;; &#125;&#125;;class Derived : public Base &#123;public: void display() &#123; std::cout &lt;&lt; &quot;Derived display&quot;; &#125; // 重写基类的 display() 函数&#125;; 总结： 重载：同一函数名，不同的参数。 覆盖：派生类提供一个与基类虚函数完全相同签名的函数。 重写：派生类重新定义了基类的非虚函数，这样会隐藏的基类函数。 成员初始化列表的概念、好处成员初始化列表是C++中类构造函数的一部分，用于直接初始化其成员变量和基类。 12345class MyClass &#123; int a; double b; MyClass(int i, double d) : a(i), b(d) &#123;&#125; // 成员初始化列表&#125;; 直接初始化，避免额外的赋值：当你使用初始化列表，成员是直接用指定的值或对象进行初始化的，而不是先进行默认初始化然后再赋值。这意味着成员的构造只进行一次，而不是两次（默认构造然后拷贝赋值）。 初始化引用和常量成员：引用和常量成员变量必须在声明时或通过成员初始化列表进行初始化。它们不能在构造函数体中被赋值。 确保成员变量的初始化顺序：类的成员变量总是按照它们在类中声明的顺序进行初始化，而不是按照它们在初始化列表中出现的顺序。使用成员初始化列表可以清晰地显示这种顺序，从而减少因初始化顺序不当而导致的错误。 调用基类的非默认构造函数： class Base &#123; Base() &#123; std::cout &lt;&lt; &quot;Base default constructor\\n&quot;; &#125; Base(int x) &#123; std::cout &lt;&lt; &quot;Base parameterized constructor: &quot; &lt;&lt; x &lt;&lt; &quot;\\n&quot;; &#125; &#125;; class Derived : public Base &#123; // 使用成员初始化列表调用基类的非默认构造函数 Derived(int y) : Base(y) &#123; std::cout &lt;&lt; &quot;Derived constructor\\n&quot;; &#125; &#125;; int main() &#123; Derived d(42); //输出：Base parameterized constructor: 42 return 0; //输出：Derived constructor &#125; 1234567891011121314151617181920 输出：Base parameterized constructor: 42 ​ Derived constructor- **调用基类的非默认构造函数：** - ```c++ class ClassB &#123; ClassB(int z) &#123; std::cout &lt;&lt; &quot;ClassB parameterized constructor: &quot; &lt;&lt; z&#125; &#125;; class ClassA &#123; ClassB objB; // 使用成员初始化列表调用ClassB的非默认构造函数 ClassA(int value) : objB(value) &#123; std::cout &lt;&lt; &quot;ClassA constructor&quot;; &#125; &#125;; int main() &#123; ClassA a(100); //输出：ClassB parameterized constructor: 100 return 0; //输出：ClassA constructor &#125; 如何避免编译器进行隐式类型转换（explicit）隐式转换可能会有以下影响： 性能影响：隐式转换可能会引入未预期的性能开销，尤其是涉及复杂类型或对象的构造和析构时。 精度丢失：例如，从浮点类型转换为整数类型或从大整数类型转换为小整数类型时。 逻辑错误：程序员可能没有意识到转换正在发生，这可能导致逻辑错误，因为转换可能不是他们想要的。 歧义：在某些情况下，可能存在多个匹配的转换，导致调用歧义。 安全性问题：隐式转换可能会导致值超出目标类型的范围，可能引发溢出等安全问题。 尽可能避免定义能导致隐式转换的构造函数或转换运算符。当你确实需要这样的构造函数时，使用 explicit 关键字来防止隐式转换。 始终在编写代码时明确你的意图，如果需要类型转换，请显式地进行转换。 使用编译器警告来检测和修正可能的隐式转换问题。 持续更新…","categories":[{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]},{"title":"【C/C++】高频问题（C和C+的区别）","slug":"【C++】高频问题（C和C+的区别）","date":"2023-08-02T16:00:00.000Z","updated":"2023-10-29T18:24:39.935Z","comments":true,"path":"2023/08/03/【C++】高频问题（C和C+的区别）/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/03/%E3%80%90C++%E3%80%91%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%EF%BC%88C%E5%92%8CC+%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89/","excerpt":"","text":"new和malloc区别 malloc是一个函数；new是c++的操作符。 malloc只分配内存、不调用对象的构造函数；new会分配内存并且调用构造函数。 malloc返回类型是void*需要类型强制转换；new会返回适当类型的指针。 malloc失败时候会返回NULL；new失败时候会抛出bad_alloc异常，除非使用了nothrow。 malloc使用free释放内存；new使用delete释放内存。 malloc需要显式的分配字节大小；new会分局类型自动计算需要分配的大小。 在C++中编写代码的话，建议使用new和delete，他们提供了更多面向对象的特性和安全性。 malloc底层实现malloc又称动态存储器分配器，维护着堆空间。且堆空间是向上增长的。 linux系统中malloc函数一般由glibc（GUN C Library）提供。且分配的是虚拟内存，如果分配后，内存未被访问，则不会映射到物理内存。当访问虚拟内存时候，查找页表发现没有对于应物理内存，则会触发缺页中断，建立虚拟和物理地址的映射。 申请内存时候可以根据大小被分为”小块“和”大块“，对应两种不同分配方式。（linux系统默认128k为区分大小快的界限） 小块通过brk()系统调用从堆中分配内存。 大块则通过mmap()系统调用在文件映射区中分配内存。 使用brk()方式申请的内存，free不会把内存归还给操作系统，而是缓存在malloc内存池中，等下次使用，目的是下次使用会快速。退出进程时候系统会回收所有资源。 使用mmap()申请内存，free会把内存归还操作系统，真正释放。 mmap缺点：频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。 brk缺点：内存碎片导致泄露。 malloc之后的内存地址和堆空间的地址范围是不一致的。是因为还有一个内存块描述信息。通常是16字节。比如内存起始地址是 d73010，而 maps 文件显示堆内存空间的起始地址是 d73000，多出0x10字节。 在4G物理内存的计算机是否能malloc 8G内存 操作系统位数，32 or 64？ 申请8G后会不会使用&#x2F;访问内存。 系统是否开启Swap机制。 总结 在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。 在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区： 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）； 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行； 指针和引用区别、如何互相转换 指针是一个变量，保存了一个地址；引用是一个对象的别名。 指针可以指向一个对象或NULL，未初始化时候值是随机的（野指针）；引用必须在声明时初始化，且不能更改，不能为NULL。 指针可修改指向对象，引用不能修改。 相互转换： 引用到指针：使用&amp;操作符获取引用代表的地址。int &amp;ref &#x3D; x；int *p &#x3D; &amp;ref； 指针到引用：解引用一个指针来获取它指向的对象。int *p &#x3D; &amp;x；int &amp;r &#x3D; *p; extern ”C“作用extern &quot;C&quot; 是 C++ 中的一个链接修饰符。它的主要目的是确保 C++ 代码可以与 C 代码互操作，并在链接时能够正确地找到符号。 这里就涉及C&#x2F;C++的编译区别了。 C++ 编译器编译函数时，为了支持函数重载，它会对函数名进行修饰或装饰。这意味着编译器会将函数名和其参数类型组合在一起，生成一个独特的名字。例如下面代码编译后，这两个 foo 函数可能会得到类似 _foo_int 和 _foo_double 这样的名称。 12void foo(int) &#123;&#125;void foo(double) &#123;&#125; C 语言不支持函数重载，所以它没有名称修饰的概念。当 C 代码中的函数被编译时，它的名字保持不变。所以，void foo(int) 在 C 中可能只是 foo。 当你在 C++ 中使用 extern &quot;C&quot;，你告诉 C++ 编译器不要为指定的代码进行名称修饰，而是使用 C 风格的链接。 比如下面：C++使用FFmpeg库（C语言库） 12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;extern &quot;C&quot; &#123; #include &lt;libavdevice/avdevice.h&gt; #include &lt;libavformat/avformat.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt;&#125; 函数参数压栈顺序 左到右（少见） 右到左（常用） 重写memcpy函数需要注意什么 地址重叠：果源地址和目标地址重叠，memcpy 可能不会正确工作。对于处理重叠的情况，通常使用 memmove。 类型安全: 为了通用性，memcpy 使用 void* 指针。但在使用这些指针时，需要确保进行适当的类型转换。 效率: 标准库中的 memcpy 通常高度优化，使用各种技术（如单词复制，SIMD 指令等）来加速操作。 错误检查: 在某些实现中，可能需要检查 NULL 指针等错误情况。 下面是一个简单的 memcpy 实现：未考虑使用CPU指令、SIMD优化加速内存复制过程。 12345678910111213141516171819202122#include &lt;stddef.h&gt;void* my_memcpy(void* dest, const void* src, size_t n) &#123; if (!dest || !src) &#123; return NULL; // 错误检查 &#125; // 转换为字符指针 unsigned char* d = (unsigned char*)dest; const unsigned char* s = (const unsigned char*)src; // 处理地址重叠问题 // 当 s &lt; d 并且重叠时，从后往前复制 if (s &lt; d &amp;&amp; s + n &gt; d) &#123; for (size_t i = n; i != 0; i--) &#123; d[i-1] = s[i-1]; &#125; &#125; else &#123; // 从前往后复制 for (size_t i = 0; i &lt; n; i++) &#123; d[i] = s[i]; &#125; &#125; return dest;&#125; 数组存放在哪里 栈：函数中声明局部变量，栈内存自动管理，函数返回时候释放数组内存。 堆：动态内存分配（new、malloc、calloc），需要人为显式释放。 静态存储区：全局变量或函数内使用static关键字。此区域存储全局变量、静态变量和常量。在程序的生命周期中一直存在。 常量区：字符串字面值（和其他常量）通常存储在常量区，这是一个特殊的内存区域，用于存储常量数据。这部分内存通常是只读的。如：char* str = &quot;Hello, World!&quot;; struct和class区别 默认访问权限： struct默认的成员变量和基类的访问权限是 public； class默认的成员变量和基类的访问权限是 private。 默认继承方式: 当使用 struct 继承时，基类的默认访问权限是 public。 当使用 class 继承时，基类的默认访问权限是 private。 C兼容性（特定场景） C 语言中，只有 struct，并且它不能包含函数。如果你在 C++ 中写了一个只包含数据的 struct。呢么C和C++可以兼容。 在C语言中，struct无法使用面向对象的编程，没有继承多态等概念。 static的定义和用途 局部变量使用：更改了储存位置（存放在静态存储区），不改变作用域（范围还在函数内）。 全局变量使用：不改变储存位置，改变作用域范围（限定在本文件，其他文件不可见）。 类成员使用： ​ 静态成员变量：每个类都对应同一个变量副本。以前一个对象对应一个变量，现在多个对象对应一个变量。类似类中全局变量~ ​ 静态成员函数：不再属于类的任何特定对象。它只能访问静态成员变量或其他静态成员函数，不能访问类的非静态成员。 const和#define区别 #define：是预处理指令，只在预处理阶段起作用。直接文本替换，然后进行编译操作。不涉及内存分配。 const：编译和运行时候都用到了，编译阶段确保程序没有修改const的值。运行阶段，会占用内存。并且初始化后无法进行修改，除非使用指针。 volatile作用和用法作用： 防止编译器优化：编译器优化会根据上下文做假设，如果代码中没有明确的修改此变量，则值就不会改变并一次做优化。使用了volatile 则不会做假设&#x2F;优化了。 确保读写顺序：当对 volatile 变量进行读或写操作时，编译器不会重新排序这些操作。这确保了指令的执行顺序与源代码中的顺序匹配。 用法： 硬件寄存器访问：硬件状态随时会改变，使用volatile后，读取数据时候都会在物理地址获取，不会使用缓存的值。确保硬件数据是正确的。 多线程和中断服务程序：如果一个变量在主程序中被使用，并在中断服务程序中被修改，这个变量应该被声明为 volatile，以确保主程序总是读取最新的值。 信号：信号的变量通常是volatile，确保在信号处理器和主程序之间正确地传递数据。 ​ 虽然 volatile 可以确保单个读或写操作不被其他操作中断，但它不提供复杂操作的原子性或内存屏障的功能。在多线程环境中，应该使用专门的并发原语，如互斥量、自旋锁或原子操作。 ​ 过度使用 volatile 可能导致不必要的性能开销，因为它会阻止编译器执行某些优化。 常量浅析C&#x2F;C++中变量的作用域 局部作用域：{ }包含的代码区域，离开即销毁。 文件作用域：也就是全局变量，在所有文件中都可访问。（static全局变量除外，限定本文件访问）。 函数作用域：特殊！仅限于goto语句，在整个函数中都可见，不受局部作用域限制。 函数原型作用域：指的是函数输入参数作用域限定在该函数，类似函数作用域。 类作用域：C++才有。类的变量、函数，智能通过类的对象或类本身（const）访问。 命名空间作用域：防止命名冲突使用的，里面的变量函数，限定在其中。 持续更新。。。","categories":[{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]},{"title":"【C++】Virtual functions | Pure virtual functions","slug":"【C++】Virtual functions  Pure virtual functions","date":"2023-08-01T16:00:00.000Z","updated":"2023-10-29T18:24:34.637Z","comments":true,"path":"2023/08/02/【C++】Virtual functions  Pure virtual functions/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/02/%E3%80%90C++%E3%80%91Virtual%20functions%20%20Pure%20virtual%20functions/","excerpt":"","text":"虚函数总结1、虚函数目的，当子类的某函数覆写父类虚函数时候，在哪个实例使用函数，就执行对应实例的函数。 2、虚函数是，父类有此函数，子类覆写。纯虚函数则是父类没实现函数，让子类区实现。 3、纯虚函数我理解的用法：接口！告诉子类设计者，你帮我写这个函数~ 4、含有纯虚函数的类叫：抽象类。只能作为基类。若派生类没实现纯虚函数，则此派生类也是抽象类，由再下一个派生类实现。（派生类不实现function，则抽象类无穷尽）。 虚函数例子123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;//可删掉Player的override行。运行查看运行区别class Entity &#123; public: virtual std::string GetName() &#123;return &quot;Entity&quot;;&#125;&#125;;class Player : public Entity&#123;private: std::string s_name;public: Player(const std::string&amp; name) : s_name(name) &#123;&#125;; std::string GetName() override &#123;return &quot;Player&quot;;&#125;&#125;;void log(Entity* entity)&#123; std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;&#125;int main()&#123; Entity* e = new Entity(); log(e); Player* p = new Player(&quot;John&quot;); log(p); return 0;&#125; 纯虚函数例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;//纯虚函数目的，作接口使用，父类包含未实现的函数，子类去实现//logName函数中不关心输入的类，只要是继承printable即可。//此程序包含虚函数、纯虚函数、class Printable&#123;public: virtual std::string GetClassName() = 0;//等于0本质让他变成纯虚函数&#125;;class Entity : public Printable&#123; public: virtual std::string GetName() &#123;return &quot;Entity&quot;;&#125; std::string GetClassName() override &#123;return &quot;Entity&quot;;&#125;&#125;;class Player : public Entity&#123;private: std::string s_name;public: Player(const std::string&amp; name) : s_name(name) &#123;&#125;; std::string GetName() override &#123;return &quot;Player&quot;;&#125; std::string GetClassName() override &#123;return &quot;Player&quot;;&#125;&#125;;void log(Entity* entity)&#123; std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;&#125;void logName(Printable* obj)&#123; std::cout &lt;&lt; obj-&gt;GetClassName() &lt;&lt; std::endl;&#125;int main()&#123; Entity* e = new Entity(); Entity* p = new Player(&quot;fuck&quot;); logName(e); logName(p); return 0;&#125; 析构函数一般写成虚函数原因为了确保派生类对象的正确析构，尤其是当派生类对象通过基类指针或引用进行删除时。 123456789101112131415161718192021222324class Base &#123;public: Base() &#123; std::cout &lt;&lt; &quot;Base Constructor&quot; &lt;&lt; std::endl; &#125; ~Base() &#123; std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl; &#125; //错招 virtual ~Base() &#123; std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl; &#125;//正招&#125;;class Derived : public Base &#123;public: int* arr; Derived() &#123; arr = new int[10]; std::cout &lt;&lt; &quot;Derived Constructor&quot; &lt;&lt; std::endl; &#125; ~Derived() &#123; delete[] arr; std::cout &lt;&lt; &quot;Derived Destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123; Base* ptr = new Derived(); delete ptr; return 0;&#125; 错招：如果你执行 delete ptr;，会发现只有 Base 的析构函数被调用，而 Derived 的析构函数没有被调用。这可能导致资源泄漏。 正招：执行 delete ptr;，首先会调用 Derived 的析构函数，然后才是 Base 的析构函数，从而确保所有的资源都被正确地释放。","categories":[{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]},{"title":"【C++】lambda：匿名函数的用法","slug":"【C++】lambda：匿名函数的用法","date":"2023-07-31T16:00:00.000Z","updated":"2023-10-29T18:24:28.836Z","comments":true,"path":"2023/08/01/【C++】lambda：匿名函数的用法/","link":"","permalink":"https://bakuenkou.gitee.io/2023/08/01/%E3%80%90C++%E3%80%91lambda%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"基本表达式[capture](parameters) -&gt; return_type &#123; body &#125; apture ：捕获列表，用于指定 lambda 表达式中要捕获的变量。这可以是空的（[]），表示不捕获任何变量，也可以使用不同的方式来捕获外部变量，例如 [x] 捕获变量 x，[x, y] 捕获变量 x 和 y，[&#x3D;] 捕获所有外部变量等等。 parameters ：参数列表，与普通函数的参数列表类似。这里可以指定 lambda 表达式接受的参数。 return_type ：返回类型，用于指定 lambda 表达式的返回类型。可以省略，编译器会自动推导返回类型。 body ：函数体，用于编写 lambda 表达式的实际操作。 无参lambda表达式12345678#include &lt;iostream&gt;int main() &#123; auto function= []() &#123; std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl; &#125;; function(); // 调用 lambda 表达式 return 0;&#125; 含参lambda表达式12345678#include &lt;iostream&gt;int main() &#123; auto add = [](int a, int b) &#123; return a + b; &#125;; int result = add(5, 3); // 调用 lambda 表达式 return 0;&#125; 捕获外部lambda表达式12345678910#include &lt;iostream&gt;int main() &#123; int x = 10; // 捕获外部变量 x auto increment = [&amp;x](int a) &#123; x += a; &#125;; increment(); // 调用 lambda 表达式 return 0;&#125; 捕获不定数量的lambda表达式12345678910#include &lt;iostream&gt;int main() &#123; int x = 10, y = 5, ch = 8; // 捕获外部变量 x auto increment = [&amp;]() &#123; std::cout &lt;&lt; &quot;Inside lambda: x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; &quot;, ch = &quot; &lt;&lt; ch &lt;&lt; std::endl; &#125;; increment(); // 调用 lambda 表达式 return 0;&#125; 举例","categories":[{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]},{"title":"【Life】此刻心情","slug":"【Life】此刻心情","date":"2023-07-19T16:00:00.000Z","updated":"2023-10-29T05:25:47.543Z","comments":true,"path":"2023/07/20/【Life】此刻心情/","link":"","permalink":"https://bakuenkou.gitee.io/2023/07/20/%E3%80%90Life%E3%80%91%E6%AD%A4%E5%88%BB%E5%BF%83%E6%83%85/","excerpt":"","text":"​ .","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】逆子十五(2)","slug":"【Life】逆子十五(2)","date":"2023-06-01T16:00:00.000Z","updated":"2023-10-30T05:44:54.650Z","comments":true,"path":"2023/06/02/【Life】逆子十五(2)/","link":"","permalink":"https://bakuenkou.gitee.io/2023/06/02/%E3%80%90Life%E3%80%91%E9%80%86%E5%AD%90%E5%8D%81%E4%BA%94(2)/","excerpt":"","text":"","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】逆子十五(1)","slug":"【Life】逆子十五(1)","date":"2023-05-31T16:00:00.000Z","updated":"2023-10-30T05:44:47.458Z","comments":true,"path":"2023/06/01/【Life】逆子十五(1)/","link":"","permalink":"https://bakuenkou.gitee.io/2023/06/01/%E3%80%90Life%E3%80%91%E9%80%86%E5%AD%90%E5%8D%81%E4%BA%94(1)/","excerpt":"","text":"分享几张十五，小时候的照片哈哈哈哈","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】周末の莫干山","slug":"【Life】周末の莫干山","date":"2023-05-26T16:00:00.000Z","updated":"2023-10-29T05:06:01.254Z","comments":true,"path":"2023/05/27/【Life】周末の莫干山/","link":"","permalink":"https://bakuenkou.gitee.io/2023/05/27/%E3%80%90Life%E3%80%91%E5%91%A8%E6%9C%AB%E3%81%AE%E8%8E%AB%E5%B9%B2%E5%B1%B1/","excerpt":"","text":"周末和朋友骑车去莫干山！庾村广场的鸽子依在，我依旧没去爬莫干山哈哈哈。","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】51劳动节の上海","slug":"【Life】51劳动节の上海","date":"2023-04-30T16:00:00.000Z","updated":"2023-10-29T05:19:16.014Z","comments":true,"path":"2023/05/01/【Life】51劳动节の上海/","link":"","permalink":"https://bakuenkou.gitee.io/2023/05/01/%E3%80%90Life%E3%80%9151%E5%8A%B3%E5%8A%A8%E8%8A%82%E3%81%AE%E4%B8%8A%E6%B5%B7/","excerpt":"","text":"51小长假，目的-&gt;上海，和好友们冲啊~ 上海的小杨生煎 三件套 听朋友说上海特产是小日子，很多日料，作为一个日语生，必须要尝尝。不过小日子的都预约满了，找了个融合日料，味道也不错~","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】51劳动节の千岛湖","slug":"【Life】51劳动节の千岛湖","date":"2023-04-28T16:00:00.000Z","updated":"2023-10-30T05:44:12.685Z","comments":true,"path":"2023/04/29/【Life】51劳动节の千岛湖/","link":"","permalink":"https://bakuenkou.gitee.io/2023/04/29/%E3%80%90Life%E3%80%9151%E5%8A%B3%E5%8A%A8%E8%8A%82%E3%81%AE%E5%8D%83%E5%B2%9B%E6%B9%96/","excerpt":"","text":"51小长假，目的-&gt;千岛湖，和好友们冲啊~ 可惜天气不太好，有点下雨，不过依旧挡不住我们坐船登岛参观！","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】扬州三日游","slug":"【Life】扬州三日游","date":"2023-03-16T16:00:00.000Z","updated":"2023-10-30T05:45:25.910Z","comments":true,"path":"2023/03/17/【Life】扬州三日游/","link":"","permalink":"https://bakuenkou.gitee.io/2023/03/17/%E3%80%90Life%E3%80%91%E6%89%AC%E5%B7%9E%E4%B8%89%E6%97%A5%E6%B8%B8/","excerpt":"","text":"部门准备安排去团建了~选了扬州。 三日游，第一天吃的是最好的，各种海鲜，佛跳墙等扬州名菜，后面逐渐减配。酒店却是一天1000+….下次能不能合理分配一下，害。 没咋好好拍照，随便记录了一下hhhh~ 扬州真的蛮漂亮的，无论是窄窄的街道还是经典，满满江南气息，非常的惬意。不愧是古代富商(盐商)聚集地。 不过堵车好厉害~而且明明是工作日，但是游客还是络绎不绝…","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】十五拆弹","slug":"【Life】十五拆弹","date":"2023-02-03T16:00:00.000Z","updated":"2023-10-30T05:45:02.443Z","comments":true,"path":"2023/02/04/【Life】十五拆弹/","link":"","permalink":"https://bakuenkou.gitee.io/2023/02/04/%E3%80%90Life%E3%80%91%E5%8D%81%E4%BA%94%E6%8B%86%E5%BC%B9/","excerpt":"","text":"最近发现十五貌似发情了，经常咬着鱼儿……. 问了医生后，安排时间给他进行拆弹hhh 他可能也知道大事不妙了 2023-9-20补充： 十五拆弹之后，半年多来感觉乖了很多，叫声从以前的，老吴变成了喵~~~~呜，","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]},{"title":"【Life】元旦の黄山","slug":"【Life】元旦の黄山","date":"2022-12-30T16:00:00.000Z","updated":"2023-10-30T05:44:00.058Z","comments":true,"path":"2022/12/31/【Life】元旦の黄山/","link":"","permalink":"https://bakuenkou.gitee.io/2022/12/31/%E3%80%90Life%E3%80%91%E5%85%83%E6%97%A6%E3%81%AE%E9%BB%84%E5%B1%B1/","excerpt":"","text":"终于元旦假期了！和朋友晚上一拍脑袋，明天去黄山！冲！ 没有攻略，没有准备，买了第二天早上最早高铁去黄山~ 游玩过程十分曲折，但是山中美景真让人流连忘返！！ 黄山上面很多小松鼠，跑的老快了，和西湖肥头大耳的天天有人喂的松鼠完全不一样哈哈哈哈~ 黄山周边相比华山等景点感觉开发的还是差点意思，缆车早早就关了，如果没赶上，就只能自己爬下去！我们就错过了哈哈哈，看了眼山上酒店，一晚1k+，厚脸皮去找了缆车工作人员，软磨硬泡坐上了他们往山下运东西的最后一趟货缆车，不得不说，装货的缆车真大！！！ 下到山后，发现，这里还在山中，离附近的酒店老远了！！！！！，而且天色已黑。无奈，厚着脸皮再去问了问，正好有个员工准备回家，给师傅塞了点辛苦费，送我们直接去了高铁站，回家了哈哈哈哈哈。 各位去玩的话，一定要做好攻略，别学我哈哈哈哈哈哈哈哈哈哈哈哈。","categories":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"}]}],"categories":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/categories/CodeSys/"},{"name":"Tool","slug":"Tool","permalink":"https://bakuenkou.gitee.io/categories/Tool/"},{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/categories/Life/"},{"name":"RK3568","slug":"RK3568","permalink":"https://bakuenkou.gitee.io/categories/RK3568/"},{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/categories/Linux/"},{"name":"C++","slug":"C","permalink":"https://bakuenkou.gitee.io/categories/C/"}],"tags":[{"name":"CodeSys","slug":"CodeSys","permalink":"https://bakuenkou.gitee.io/tags/CodeSys/"},{"name":"tool","slug":"tool","permalink":"https://bakuenkou.gitee.io/tags/tool/"},{"name":"Life","slug":"Life","permalink":"https://bakuenkou.gitee.io/tags/Life/"},{"name":"rk3568","slug":"rk3568","permalink":"https://bakuenkou.gitee.io/tags/rk3568/"},{"name":"Linux","slug":"Linux","permalink":"https://bakuenkou.gitee.io/tags/Linux/"},{"name":"linux","slug":"linux","permalink":"https://bakuenkou.gitee.io/tags/linux/"},{"name":"c-plus","slug":"c-plus","permalink":"https://bakuenkou.gitee.io/tags/c-plus/"}]}