<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【C++】Virtual functions | Pure virtual functions</title>
    <url>/blog/cPulsVirtualFun/</url>
    <content><![CDATA[<h2 id="虚函数总结"><a href="#虚函数总结" class="headerlink" title="虚函数总结"></a>虚函数总结</h2><p>1、虚函数目的，当子类的某函数覆写父类虚函数时候，在哪个实例使用函数，就执行对应实例的函数。</p>
<p>2、虚函数是，父类有此函数，子类覆写。纯虚函数则是父类没实现函数，让子类区实现。</p>
<p>3、纯虚函数我理解的用法：接口！告诉子类设计者，你帮我写这个函数~</p>
<p>4、含有纯虚函数的类叫：抽象类。只能作为基类。若派生类没实现纯虚函数，则此派生类也是抽象类，由再下一个派生类实现。（派生类不实现function，则抽象类无穷尽）。</p>
<h2 id="虚函数例子"><a href="#虚函数例子" class="headerlink" title="虚函数例子"></a>虚函数例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//可删掉Player的override行。运行查看运行区别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">s_name</span>(name) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    <span class="built_in">log</span>(e);</span><br><span class="line">    Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="built_in">log</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="纯虚函数例子"><a href="#纯虚函数例子" class="headerlink" title="纯虚函数例子"></a>纯虚函数例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数目的，作接口使用，父类包含未实现的函数，子类去实现</span></span><br><span class="line"><span class="comment">//logName函数中不关心输入的类，只要是继承printable即可。</span></span><br><span class="line"><span class="comment">//此程序包含虚函数、纯虚函数、</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//等于0本质让他变成纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> : <span class="keyword">public</span> Printable</span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">s_name</span>(name) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logName</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    Entity* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">    <span class="built_in">logName</span>(e);</span><br><span class="line">    <span class="built_in">logName</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="析构函数一般写成虚函数原因"><a href="#析构函数一般写成虚函数原因" class="headerlink" title="析构函数一般写成虚函数原因"></a>析构函数一般写成虚函数原因</h2><p>为了确保派生类对象的正确析构，尤其是当派生类对象通过基类指针或引用进行删除时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl; &#125;		<span class="comment">//错招</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl; &#125;<span class="comment">//正招</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>错招：</strong>如果你执行 <code>delete ptr;</code>，会发现只有 <code>Base</code> 的析构函数被调用，而 <code>Derived</code> 的析构函数没有被调用。这可能导致资源泄漏。</li>
<li><strong>正招：</strong>执行 <code>delete ptr;</code>，首先会调用 <code>Derived</code> 的析构函数，然后才是 <code>Base</code> 的析构函数，从而确保所有的资源都被正确地释放。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++】lambda：匿名函数的用法</title>
    <url>/blog/cPulsLambda/</url>
    <content><![CDATA[<h2 id="基本表达式"><a href="#基本表达式" class="headerlink" title="基本表达式"></a>基本表达式</h2><pre><code>[capture](parameters) -&gt; return_type &#123; body &#125;
</code></pre>
<ol>
<li><strong>apture</strong> ：捕获列表，用于指定 lambda 表达式中要捕获的变量。这可以是空的（[]），表示不捕获任何变量，也可以使用不同的方式来捕获外部变量，例如 [x] 捕获变量 x，[x, y] 捕获变量 x 和 y，[&#x3D;] 捕获所有外部变量等等。</li>
<li><strong>parameters</strong> ：参数列表，与普通函数的参数列表类似。这里可以指定 lambda 表达式接受的参数。</li>
<li><strong>return_type</strong> ：返回类型，用于指定 lambda 表达式的返回类型。可以省略，编译器会自动推导返回类型。</li>
<li><strong>body</strong> ：函数体，用于编写 lambda 表达式的实际操作。</li>
</ol>
<h2 id="无参lambda表达式"><a href="#无参lambda表达式" class="headerlink" title="无参lambda表达式"></a>无参lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> function= []() &#123;</span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">function</span>();  <span class="comment">// 调用 lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="含参lambda表达式"><a href="#含参lambda表达式" class="headerlink" title="含参lambda表达式"></a>含参lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 调用 lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获外部lambda表达式"><a href="#捕获外部lambda表达式" class="headerlink" title="捕获外部lambda表达式"></a>捕获外部lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 捕获外部变量 x</span></span><br><span class="line">    <span class="keyword">auto</span> increment = [&amp;x](<span class="type">int</span> a) &#123;</span><br><span class="line">        x += a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">increment</span>();  <span class="comment">// 调用 lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获不定数量的lambda表达式"><a href="#捕获不定数量的lambda表达式" class="headerlink" title="捕获不定数量的lambda表达式"></a>捕获不定数量的lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>, ch = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 捕获外部变量 x</span></span><br><span class="line">    <span class="keyword">auto</span> increment = [&amp;]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, ch = &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="built_in">increment</span>();  <span class="comment">// 调用 lambda 表达式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="http://s1lcia52i.bkt.gdipper.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20202917.png?e=1695809622&token=Pz2y7VaKVenNEaUUo-TufB9J-F6kbcB5wjl0Fmkb:sQGpf-_7UmKZJEIet756maIoYnc=" alt="丢失了"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++】智能指针（Smart Pointer）</title>
    <url>/blog/cPulsSmartPointer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​	智能指针是C++中的一种对象，它的设计初衷是为了解决原生指针在资源管理上的一些问题。C++11 开始提供了几种类型的智能指针，<code>std::auto_ptr</code>（已被废弃，不推荐使用），<code>std::unique_ptr</code>，<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。</p>
<p>​	智能指针由以下几个好处：</p>
<p>​	<strong>自动内存管理</strong>：智能指针会自动释放其指向的对象，当智能指针超出其作用范围或被显式重置时，它将负责删除其所指向的对象。这大大减少了因手动管理内存而导致的内存泄漏的风险。</p>
<p>​	<strong>自动销毁、防止悬垂</strong>：当没有任何智能指针指向某个对象时（例如，对于 <code>std::shared_ptr</code>，引用计数变为0），该对象会被自动销毁。悬垂指针通常是由于对象已被删除，但仍有指针指向它造成的。智能指针通过所有权管理和引用计数来降低这种风险。</p>
<p>​	<strong>兼容性好</strong>：智能指针可以与C++标准库容器一起使用，如 <code>std::vector&lt;std::shared_ptr&lt;T&gt;&gt;</code>。</p>
<p>​	<strong>安全的自定义删除器</strong>：智能指针允许用户提供自定义删除器，这对于特殊资源（如文件句柄、套接字或自定义内存分配器）的管理非常有用。</p>
<p>​	<strong>移动语义支持</strong>：特别是 <code>std::unique_ptr</code>，支持C++11引入的移动语义，使资源所有权的转移更加直观和高效。</p>
<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>​	这个实际上模板类，提供一些机制保证堆上分配的对象的指针离开作用域时候，会自动释放。基本无开销。并且进入unique_ptr实现时候可以发现，他显示的删除了<strong>复制构造函数</strong>和<strong>复制赋值操作符</strong>（&#x3D;操作）。</p>
<p>​	删除复制构造函数后，意味着你不能复制这个对象，无法执行例如把函数指针当作函数的值传递入参。因为<strong>值传递</strong>时候会对目标进行复制。但是可以<strong>引用传递</strong>和<strong>右值引用（<code>&amp;&amp;</code>）</strong>来传递它们。</p>
<p>​	右值引用：一般移动构造函数或移动赋值操作符一起使用，允许资源的所有权从一个对象转移到另一个对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt;&amp; ptr)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt;&amp;&amp; ptr)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);<span class="comment">//引入于 C++14 标准</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;int&gt; ptr(new int(10));	//低于 C++14 标准使用这个！！</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;int&gt; ptr = new int(10);	//false：构造函数不接受裸指针作为参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>(ptr); 				<span class="comment">// Will compile errors</span></span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(ptr)); 	<span class="comment">// Pass by ownership is OK</span></span><br><span class="line">    <span class="built_in">foo</span>(ptr); 				<span class="comment">// Pass by reference is fine.</span></span><br><span class="line">    <span class="built_in">bar</span>(std::<span class="built_in">move</span>(ptr)); 	<span class="comment">// Pass by rvalue reference using std::move.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>用法</strong>：拥有其指向的对象的唯一所有权。</p>
</li>
<li><p><strong>区别</strong>：不能复制，可以移动。</p>
</li>
<li><p><strong>优点</strong>：轻量级，安全的资源所有权管理</p>
</li>
<li><p><strong>缺点</strong>：无法共享所有权</p>
</li>
<li><p><strong>用途</strong>：希望一个对象只有一个所有者时候使用。</p>
</li>
</ul>
<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>​	这玩意工作方式是使用引用计数，用来跟踪你的指针有多少个引用。一旦引用计数为0，则删除指针。</p>
<p>​	使用shared_ptr务必使用make_shared（引入于 C++11 标准）：</p>
<p>1、<strong>避免异常安全情况</strong>：比如fun(std::shared_ptr<int>(new int(10)), std::shared_ptr<int>(new int(20)));分为三个过程1、<code>new int(10)</code>。2、<code>new int(20)</code>。3、<code>std::unique_ptr</code> 构造函数调用。</p>
<p>​	如果 <code>new int(10)</code> 成功执行并分配了内存，但在执行 <code>new int(20)</code> 时由于某种原因（例如内存不足）抛出异常。在这种情况下，因为 <code>std::shared_ptr的构造函数还没有开始执行，所以 </code>new int(10)&#96; 分配的内存不会被释放，导致<strong>内存泄漏</strong>。</p>
<p>2、<strong>效率高</strong>：这个操作可以在一个原子操作完成，使用new则需要两次分配内存，一次是对象本身，一次是控制块（储存引用计数），提高效率高。</p>
<p>3、<strong>内存连续性</strong>：由于 <code>std::make_shared</code> 通常在一个连续的内存块中同时分配对象数据和控制块，这可以为某些缓存友好的应用程序提供性能优势。</p>
<p>4、*<em>避免裸指针</em>***：使用 <code>std::make_shared</code> 的另一个优势是避免暴露裸指针，减少了出错的机会。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; ptr;</span><br><span class="line">        &#123;</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; fuck = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">            ptr = fuck;<span class="comment">// 进行复制赋值操作</span></span><br><span class="line">        &#125;<span class="comment">//1</span></span><br><span class="line">    &#125;<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Debug以上代码可以发现，代码在执行make_shared时候，调用了构造函数，当执行完第一个花括号时候，并没有执行析构函数，在执行完第二个花括号时候才执行了析构函数。这就是引用计数~</p>
<ul>
<li><p><strong>用法</strong>：多个 <code>shared_ptr</code> 可以共享对同一个对象的所有权。</p>
</li>
<li><p><strong>区别</strong>：使用引用计数来确保只有在最后一个指向对象的 <code>shared_ptr</code> 被销毁或重置时，对象才会被删除。</p>
</li>
<li><p><strong>优点</strong>：可以共享资源所有权。</p>
</li>
<li><p><strong>缺点</strong>：相对于 <code>unique_ptr</code> 更重，因为它需要管理引用计数。</p>
</li>
<li><p><strong>用途</strong>：当你希望多个指针共享一个对象的所有权时使用。</p>
</li>
</ul>
<h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>弱指针，Debug以下代码可以发现，代码在执行make_shared时候，调用了构造函数，当执行完第一个花括号时候时候就执行了析构函数。第一个花括号处。weak_ptr指向一个无效的Entity~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::weak_ptr&lt;Entity&gt; ptr;</span><br><span class="line">        &#123;</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; fuck = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">            ptr = fuck;<span class="comment">// 进行复制赋值操作</span></span><br><span class="line">        &#125;<span class="comment">//1</span></span><br><span class="line">    &#125;<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用法</strong>：它是对 <code>shared_ptr</code> 的一种弱引用，不会增加引用计数。</li>
<li><strong>区别</strong>：当与之相关联的 <code>shared_ptr</code> 被销毁时，<code>weak_ptr</code> 不会阻止对象被删除。</li>
<li><strong>优点</strong>：避免 <code>shared_ptr</code> 之间的循环引用问题。</li>
<li><strong>缺点</strong>：不能直接使用，必须先转化为 <code>shared_ptr</code>。</li>
<li><strong>用途</strong>：当你需要一个不参与引用计数的指针，特别是为了避免循环引用时使用。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++】高频问题（继承、多态）</title>
    <url>/blog/cPulsPolymorphic/</url>
    <content><![CDATA[<h4 id="继承和虚继承"><a href="#继承和虚继承" class="headerlink" title="继承和虚继承"></a>继承和虚继承</h4><ul>
<li>继承：允许一个类（派生类）从另一个类（基类）继承属性和行为。且基类的公有和保护成员默认被派生类继承。</li>
<li>虚继承：是一种特殊的继承，用于解决多个派生类从同一个基类继承而导致的冗余和歧义问题（钻石问题）。使用虚继承时，来自虚基类的成员在内存中只有一个副本，无论基类被继承了多少次。</li>
<li>钻石问题：当多个类继承自一个类，并且另一个类从这些类多重继承时，就可能出现钻石问题。例如，<code>Vehicle</code> -&gt; <code>Car</code> 和 <code>Boat</code>，然后 <code>AmphibiousVehicle</code> 从 <code>Car</code> 和 <code>Boat</code> 继承。为了避免 <code>AmphibiousVehicle</code> 中有两个 <code>Vehicle</code> 副本，可以使用虚继承。</li>
</ul>
<p>总结：<strong>普通继承</strong>主要用于实现类型的“是一个”关系，如 “Cat” 是一个 “Animal”。<strong>虚继承</strong>主要用于解决由于多重继承而导致的冗余和歧义问题。</p>
<h4 id="多态的类，内存布局是怎样的"><a href="#多态的类，内存布局是怎样的" class="headerlink" title="多态的类，内存布局是怎样的"></a>多态的类，内存布局是怎样的</h4><p>多态在 C++ 中通常通过虚函数来实现。要支持多态行为，C++ 使用了虚函数表（vtable）的机制。</p>
<p>假设有以下的基类和派生类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> baseData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> derivedData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是基于此代码的对象的内存布局的一种典型表示：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Base object:</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| vptr             | <span class="comment">--&gt; Points to vtable for Base</span></span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| baseData         |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line"></span><br><span class="line">Derived object:</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| vptr             | <span class="comment">--&gt; Points to vtable for Derived</span></span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| baseData         |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| derivedData      |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>vtable</strong> 是一个包含指向类的虚函数的指针的数组。</li>
<li>类的每一个对象都有一个指向它的类的 vtable 的指针，这个指针通常被称为 <code>vptr</code>。</li>
<li>vtable 使得在运行时能够正确地解析应该调用哪一个虚函数版本。</li>
</ul>
<p>对于上述 <code>Base</code> 和 <code>Derived</code> 类的对象，其相关的 vtable 可能如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vtable <span class="keyword">for</span> Base:</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Address of Base::func1  |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Address of Base::func2  |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line"></span><br><span class="line">vtable <span class="keyword">for</span> Derived:</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Address of Derived::func1 | (Overridden from Base)</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Address of Base::func2    | (Not overridden, so Base<span class="string">&#x27;s version is used)</span></span><br><span class="line"><span class="string">+------------------+</span></span><br><span class="line"><span class="string">| Address of Derived::func3 |</span></span><br><span class="line"><span class="string">+------------------+</span></span><br></pre></td></tr></table></figure>

<p>当我们通过基类指针调用一个虚函数时，编译器会使用这个对象的 <code>vptr</code> 来查找正确的函数地址。</p>
<p>此处描述的内存布局和<code>vtable</code>机制是基于C++标准和许多常用编译器的典型实现。这种实现方式在多个平台和操作系统上，如Windows、Linux和macOS，以及各种编译器，如GCC、Clang和MSVC，都是普遍存在的。</p>
<p>确切的细节，如<code>vptr</code>和<code>vtable</code>在内存中的位置、其他可能的元数据等，可能会根据不同的编译器和它们的版本、平台、编译器选项和优化级别略有不同。</p>
<p>此处为通用的、概念性的理解。如想了解特定于某个编译器或系统的内部细节，需要参考相关的编译器文档或使用工具（如<code>objdump</code>或<code>gdb</code>在Linux上）来检查生成的二进制代码和数据结构。</p>
<h4 id="被隐藏的基类函数和基类成员变量-and-子类调用父类的同名函数和同名成员变量"><a href="#被隐藏的基类函数和基类成员变量-and-子类调用父类的同名函数和同名成员变量" class="headerlink" title="被隐藏的基类函数和基类成员变量 and 子类调用父类的同名函数和同名成员变量"></a>被隐藏的基类函数和基类成员变量 and 子类调用父类的同名函数和同名成员变量</h4><p><strong>被隐藏的基类函数和基类成员变量：</strong></p>
<p>​		当子类有一个与父类同名的成员（函数或变量），该成员会隐藏父类的同名成员。</p>
<p><strong>子类调用父类的同名函数和同名成员变量：</strong></p>
<p>​		若想在子类中调用父类的同名函数或访问父类的成员变量，你可以使用 作用域解析运算符 <code>::</code> 如以下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::foo() called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::foo() called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callBaseFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">foo</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base value: &quot;</span> &lt;&lt; Base::value &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">foo</span>();           <span class="comment">// 输出：Derived::foo() called</span></span><br><span class="line">    d.<span class="built_in">callBaseFoo</span>();   <span class="comment">// 输出：Base::foo() called和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多态的三个条件和实现原理"><a href="#多态的三个条件和实现原理" class="headerlink" title="多态的三个条件和实现原理"></a>多态的三个条件和实现原理</h4><p><strong>多态的三个条件：</strong></p>
<ol>
<li><p><strong>继承</strong>：必须存在基类和派生类的关系。</p>
</li>
<li><p><strong>虚函数</strong>：基类必须定义一个或多个虚函数，供派生类重写。</p>
</li>
<li><p><strong>基类指针或引用</strong>：为了实现多态，我们需要使用基类的指针或引用来指向派生类的对象，即在编译时，你编写的代码基于基类的接口，但在运行时，代码会根据实际传入的对象类型动态选择合适的方法。如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The animal makes a sound.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The cat meows.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SoundOfAnimal</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">makeSound</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat myCat;</span><br><span class="line">    <span class="built_in">SoundOfAnimal</span>(myCat);  <span class="comment">// Outputs: &quot;The cat meows.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>原理：</strong></p>
<p>​		多态的实现在 C++ 中依赖于虚函数表（vtable）和虚函数指针（vptr）。</p>
<ol>
<li><strong>虚函数表（vtable）</strong>：每个有虚函数的类都有一个与之关联的虚函数表。vtable 是一个存储函数指针的数组，其中的每个函数指针都指向该类中的一个虚函数。这些函数可以是定义在本类中的，也可以是从基类继承过来的。</li>
<li><strong>虚函数指针（vptr）</strong>：类的每个对象都有一个虚函数指针（通常称为 <code>vptr</code>），它指向与该对象关联的类的 vtable。<code>vptr</code> 在对象创建时自动设置，指向适当的 vtable。</li>
</ol>
<p>可参考上面的  <code>多态的类，内存布局是怎样的</code></p>
<h4 id="拷贝构造函数、深浅拷贝的理解和用途，何时需要自定义拷贝构造函数"><a href="#拷贝构造函数、深浅拷贝的理解和用途，何时需要自定义拷贝构造函数" class="headerlink" title="拷贝构造函数、深浅拷贝的理解和用途，何时需要自定义拷贝构造函数"></a>拷贝构造函数、深浅拷贝的理解和用途，何时需要自定义拷贝构造函数</h4><p><strong>拷贝构造函数：</strong>当从一个对象创建另一个对象的副本时，会调用拷贝构造函数。如下：</p>
<blockquote>
<p>ClassName(const ClassName&amp; source);</p>
</blockquote>
<p><strong>深拷贝：</strong>不仅复制对象的每个成员，还复制指针指向的数据。这样，两个对象就不会共享相同的资源，从而避免了浅拷贝中的问题。</p>
<p><strong>浅拷贝：</strong>简单地复制对象的每个成员。对于基本数据类型浅拷贝是可以的，但是对于指针或动态分配的资源可能会出问题。因为复制的是指针本身，而不是指向的数据。如果你释放其中一个对象的资源，其他对象也会被影响，因为它们共享同一块内存。</p>
<p><strong>何时需要自定义拷贝构造函数？</strong></p>
<ol>
<li><strong>管理动态分配的内存</strong>：若类有指向动态分配的内存的指针，你需要提供深拷贝逻辑来确保新的对象有自己的内存副本。</li>
<li><strong>管理资源</strong>：除内存外，如果类管理其他资源，如文件、网络连接或数据库连接，你可能也需要自定义拷贝构造函数来正确复制这些资源。（比如说文件句柄，当复制该类的对象时，你可能想为新对象打开一个新的文件句柄，而不是共享同一个句柄。）</li>
<li><strong>引用计数</strong>：如果你的类使用引用计数来管理资源（如智能指针的拷贝构造中，会增加引用计数。析构时候减少引用计数，计数为0则销毁），则需要自定义拷贝构造函数来更新引用计数。</li>
<li><strong>修改拷贝行为</strong>：如果你想在复制对象时提供一些特殊的行为，比如记录拷贝操作或修改某些成员的值。</li>
</ol>
<h4 id="析构函数可以抛出异常吗？"><a href="#析构函数可以抛出异常吗？" class="headerlink" title="析构函数可以抛出异常吗？"></a>析构函数可以抛出异常吗？</h4><p>首先析构函数可以抛出异常。</p>
<p><strong>但是</strong>在析构中抛出异常是一个不好的做法，会设计很多相关风险问题。如下</p>
<ol>
<li><strong>双重异常问题</strong>：如果在析构期间抛出一个异常，而另一个异常已经在处理，那么<code>std::terminate</code>会被调用，导致程序终止。这是因为C++不允许有两个未处理的异常同时存在。</li>
<li><strong>难以捕获</strong>：当对象在栈上销毁或作为部分容器被销毁时，你可能无法明确地捕获析构函数中的异常。</li>
<li><strong>RAII原则违背</strong>：在C++中，一种常用的资源管理技术是资源获取即初始化（RAII）。其中，构造函数用于获取资源，而析构函数用于释放资源。如果析构函数中存在异常抛出的可能性，RAII的安全性和可靠性就会被破坏。</li>
<li><strong>资源泄漏</strong>：如果析构函数早期退出并且没有适当地清理资源，那么可能会导致资源泄漏。</li>
<li><strong>可维护性降低</strong>：析构函数中的异常使代码更难以理解和维护，因为你必须密切关注析构逻辑以确保所有路径都适当地处理资源并且不会抛出异常。</li>
<li><strong>其他析构函数可能不会被调用</strong>：如果在析构函数中抛出异常，其他还未调用的析构函数可能不会被执行，导致潜在的资源泄漏和未定义的行为。</li>
</ol>
<h4 id="什么情况调用拷贝构造函数"><a href="#什么情况调用拷贝构造函数" class="headerlink" title="什么情况调用拷贝构造函数"></a>什么情况调用拷贝构造函数</h4><ul>
<li><p><strong>直接初始化：</strong><code>ClassName obj2 = obj1;  </code></p>
</li>
<li><p><strong>传递对象作为函数参数：</strong><code>someFunction(objClass);  </code></p>
</li>
<li><p><strong>函数返回对象：</strong></p>
</li>
<li><pre><code class="c++">ClassName someFunction() &#123;
   ClassName obj;
   return obj;  // 可能调用拷贝构造函数，但因为RVO，实际拷贝可能会被优化掉
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **拷贝初始化：**`ClassName obj2(obj1); `</span><br><span class="line"></span><br><span class="line">- **在容器中存储对象：**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  std::vector&lt;ClassName&gt; vec;</span><br><span class="line">  ClassName obj;</span><br><span class="line">  vec.push_back(obj);  // 调用拷贝构造函数（emplace方法可以避免此拷贝）</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>初始化聚合类或结构体的成员：</strong>若一个类或结构体包含其他类的对象，则对象可以通过拷贝构造函数进行初始化。</p>
</li>
</ul>
<h4 id="析构函数一般写成虚函数原因"><a href="#析构函数一般写成虚函数原因" class="headerlink" title="析构函数一般写成虚函数原因"></a>析构函数一般写成虚函数原因</h4><p>为了确保派生类对象的正确析构，尤其是当派生类对象通过基类指针或引用进行删除时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl; &#125;		<span class="comment">//错招</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl; &#125;<span class="comment">//正招</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>错招：</strong>如果你执行 <code>delete ptr;</code>，会发现只有 <code>Base</code> 的析构函数被调用，而 <code>Derived</code> 的析构函数没有被调用。这可能导致资源泄漏。</li>
<li><strong>正招：</strong>执行 <code>delete ptr;</code>，首先会调用 <code>Derived</code> 的析构函数，然后才是 <code>Base</code> 的析构函数，从而确保所有的资源都被正确地释放。</li>
</ul>
<h4 id="构造函数为什么不定义为虚函数"><a href="#构造函数为什么不定义为虚函数" class="headerlink" title="构造函数为什么不定义为虚函数"></a>构造函数为什么不定义为虚函数</h4><p>​		虚构造函数在 C++ 中没有意义，并且不被允许。</p>
<ol>
<li><strong>对象实例化的本质</strong>：当你创建一个对象（实例化一个类），该对象的内存首次被分配，构造函数被调用来初始化这些内存。<u>但是</u>在对象创建时，它的虚函数表（vtable）还没有被建立。因为构造函数是为了设置这种基础设置和初始化的，所以它不能是虚的。</li>
<li><strong>虚函数的实现机制</strong>：虚函数依赖于每个对象的虚函数表（vtable）。对象的 vtable 在构造函数被调用时才被设置。因此，构造函数的虚拟化意味着它会使用一个还没有建立的 vtable，这是不可能的。</li>
<li><strong>语义上的问题</strong>：构造函数的目的是创建和初始化对象。当我们创建一个派生类的对象时，基类的构造函数首先被调用，然后是派生类的构造函数。这确保了对象从基本部分到更专门的部分被正确初始化。将构造函数设置为虚函数没有明确的意义，因为我们已经有一个确定的顺序来调用构造函数。</li>
<li><strong>没有继承的构造函数</strong>：在 C++ 中，构造函数不被派生类继承。每个类都有其自己的构造函数。如果你试图通过派生类的对象调用基类的构造函数，它总是明确地知道要调用哪个构造函数，因此不需要虚构造函数。</li>
</ol>
<h4 id="静态绑定和动态绑定介绍"><a href="#静态绑定和动态绑定介绍" class="headerlink" title="静态绑定和动态绑定介绍"></a>静态绑定和动态绑定介绍</h4><p>静态绑定和动态绑定是编程中两种不同的函数调用机制。它们主要涉及到面向对象编程，特别是在存在继承和多态时。</p>
<p><strong>静态绑定（早期绑定）:</strong></p>
<ul>
<li>定义: 静态绑定是在编译时确定要调用的函数版本的过程。</li>
<li>特点: 函数的调用地址在编译时被确定，并在生成的机器代码中硬编码。</li>
<li>适用情况: 非虚成员函数、静态成员函数和全局函数通常使用静态绑定。</li>
<li>性能: 由于不需要运行时的查找过程，通常性能稍好。</li>
</ul>
<p><strong>动态绑定（晚期绑定）:</strong></p>
<ul>
<li>定义: 动态绑定是在运行时根据对象的实际类型来确定要调用的函数版本的过程。</li>
<li>特点: 它依赖于虚函数表（vtable）来确定在运行时要调用的正确的函数版本。每个有虚函数的类的对象都有一个指向其vtable的指针。</li>
<li>适用情况: 只有通过指针或引用调用的虚函数才会使用动态绑定。</li>
<li>性能: 动态绑定涉及到在运行时查找适当的函数地址，通常会比静态绑定略慢，但这种差异在现代计算机上通常是微不足道的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowStatic</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base (static)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowDynamic</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base (dynamic)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowStatic</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived (static)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowDynamic</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived (dynamic)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived * c = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">ShowStatic</span>();   <span class="comment">//静态绑定：输出 Base (static)</span></span><br><span class="line">    b-&gt;<span class="built_in">ShowDynamic</span>();  <span class="comment">//动态绑定：输出 Derived (dynamic)</span></span><br><span class="line">    c-&gt;<span class="built_in">ShowStatic</span>();   <span class="comment">//静态绑定：输出 Derived (static)</span></span><br><span class="line">    c-&gt;<span class="built_in">ShowDynamic</span>();  <span class="comment">//动态绑定：输出 Derived (dynamic)</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用动态绑定函数时候，涉及虚函数的查找，可以参考上面虚函数的介绍。首先是访问<strong>对象</strong>的虚函数表指针，根据这个指针，找到对应函数。b和c的对象都是<code>Derived</code>类型。</p>
<h4 id="C-所有构造函数"><a href="#C-所有构造函数" class="headerlink" title="C++所有构造函数"></a>C++所有构造函数</h4><ul>
<li>默认构造函数：<code>Example() &#123;&#125;</code></li>
<li>参数化构造函数：<code>Example(int val) : data(val) &#123;&#125;</code></li>
<li>拷贝构造函数： <code>Example(const Example&amp; source) &#123;&#125;</code></li>
<li>移动构造函数：<code>Example(Example&amp;&amp; source) &#123;&#125;</code></li>
<li>委托构造函数：<ul>
<li><code>Example() : Example(0) &#123;&#125;</code>  &#x2F;&#x2F;  Delegates to the parameterized constructor   </li>
<li><code>Example(int value)  &#123;&#125;</code>  &#x2F;&#x2F; initialize with value</li>
</ul>
</li>
<li>显示构造函数：explicit Example(int value) {}</li>
</ul>
<h4 id="重写、重载、覆盖区别"><a href="#重写、重载、覆盖区别" class="headerlink" title="重写、重载、覆盖区别"></a>重写、重载、覆盖区别</h4><ol>
<li><p><strong>重载 (Overloading)</strong></p>
<ul>
<li><p>描述：在同一作用域内，函数名称相同但参数列表不同（包括参数的类型、顺序或数量）。</p>
</li>
<li><p>适用范围：可以重载普通函数或类成员函数。</p>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>覆盖 (Overriding)</strong></p>
<ul>
<li><p>描述：在派生类中，派生类提供一个与基类中某个虚函数签名完全相同的函数。</p>
</li>
<li><p>前提：基类中的函数必须被声明为<code>virtual</code>。</p>
</li>
<li><p>注意：覆盖涉及到基类和派生类之间的关系。当基类的虚函数被派生类覆盖时，如果通过基类指针或引用调用该函数，实际上会调用派生类中的版本（前提是该指针或引用指向的是派生类的对象）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span>; &#125;  <span class="comment">// 覆盖基类的display() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重写 (Redefining)</strong></p>
<ul>
<li><p>描述：在派生类中重新定义基类中的非虚函数。</p>
</li>
<li><p>注意：与覆盖不同，重写并不保证动态分派。即，如果通过基类指针或引用调用该函数，将调用基类的版本，而不是派生类的版本。</p>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span>; &#125;  <span class="comment">// 重写基类的 display() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><strong>重载</strong>：同一函数名，不同的参数。</li>
<li><strong>覆盖</strong>：派生类提供一个与基类虚函数完全相同签名的函数。</li>
<li><strong>重写</strong>：派生类重新定义了基类的非虚函数，这样会隐藏的基类函数。</li>
</ul>
<h4 id="成员初始化列表的概念、好处"><a href="#成员初始化列表的概念、好处" class="headerlink" title="成员初始化列表的概念、好处"></a>成员初始化列表的概念、好处</h4><p>成员初始化列表是C++中类构造函数的一部分，用于直接初始化其成员变量和基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i, <span class="type">double</span> d) : <span class="built_in">a</span>(i), <span class="built_in">b</span>(d) &#123;&#125;  <span class="comment">// 成员初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>直接初始化，避免额外的赋值</strong>：当你使用初始化列表，成员是直接用指定的值或对象进行初始化的，而不是先进行默认初始化然后再赋值。这意味着成员的构造只进行一次，而不是两次（默认构造然后拷贝赋值）。</p>
</li>
<li><p><strong>初始化引用和常量成员</strong>：引用和常量成员变量必须在声明时或通过成员初始化列表进行初始化。它们不能在构造函数体中被赋值。</p>
</li>
<li><p><strong>确保成员变量的初始化顺序</strong>：类的成员变量总是按照它们在类中声明的顺序进行初始化，而不是按照它们在初始化列表中出现的顺序。使用成员初始化列表可以清晰地显示这种顺序，从而减少因初始化顺序不当而导致的错误。</p>
</li>
<li><p><strong>调用基类的非默认构造函数：</strong></p>
<ul>
<li><pre><code class="c++">class Base &#123;
    Base() &#123; std::cout &lt;&lt; &quot;Base default constructor\n&quot;; &#125;
    Base(int x) &#123; std::cout &lt;&lt; &quot;Base parameterized constructor: &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;; &#125;
&#125;;
class Derived : public Base &#123;
    // 使用成员初始化列表调用基类的非默认构造函数
    Derived(int y) : Base(y) &#123; std::cout &lt;&lt; &quot;Derived constructor\n&quot;; &#125;
&#125;;
int main() &#123;
    Derived d(42);	//输出：Base parameterized constructor: 42 
    return 0;		//输出：Derived constructor
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    输出：Base parameterized constructor: 42 </span><br><span class="line"></span><br><span class="line">    ​			Derived constructor</span><br><span class="line"></span><br><span class="line">- **调用基类的非默认构造函数：**</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    class ClassB &#123;</span><br><span class="line">        ClassB(int z) &#123; std::cout &lt;&lt; &quot;ClassB parameterized constructor: &quot; &lt;&lt; z&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    class ClassA &#123;</span><br><span class="line">        ClassB objB;</span><br><span class="line">        // 使用成员初始化列表调用ClassB的非默认构造函数</span><br><span class="line">        ClassA(int value) : objB(value) &#123; std::cout &lt;&lt; &quot;ClassA constructor&quot;; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    int main() &#123;</span><br><span class="line">        ClassA a(100);	//输出：ClassB parameterized constructor: 100</span><br><span class="line">        return 0;		//输出：ClassA constructor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="如何避免编译器进行隐式类型转换（explicit）"><a href="#如何避免编译器进行隐式类型转换（explicit）" class="headerlink" title="如何避免编译器进行隐式类型转换（explicit）"></a>如何避免编译器进行隐式类型转换（explicit）</h4><p>隐式转换可能会有以下影响：</p>
<ol>
<li><strong>性能影响</strong>：隐式转换可能会引入未预期的性能开销，尤其是涉及复杂类型或对象的构造和析构时。</li>
<li><strong>精度丢失</strong>：例如，从浮点类型转换为整数类型或从大整数类型转换为小整数类型时。</li>
<li><strong>逻辑错误</strong>：程序员可能没有意识到转换正在发生，这可能导致逻辑错误，因为转换可能不是他们想要的。</li>
<li><strong>歧义</strong>：在某些情况下，可能存在多个匹配的转换，导致调用歧义。</li>
<li><strong>安全性问题</strong>：隐式转换可能会导致值超出目标类型的范围，可能引发溢出等安全问题。</li>
</ol>
<ul>
<li>尽可能避免定义能导致隐式转换的构造函数或转换运算符。当你确实需要这样的构造函数时，使用 <code>explicit</code> 关键字来防止隐式转换。</li>
<li>始终在编写代码时明确你的意图，如果需要类型转换，请显式地进行转换。</li>
<li>使用编译器警告来检测和修正可能的隐式转换问题。</li>
</ul>
<p>持续更新…</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>【CodeSys】添加自己的代码库</title>
    <url>/blog/CodesysAddMyLib/</url>
    <content><![CDATA[<h1 id="测试第一个程序"><a href="#测试第一个程序" class="headerlink" title="测试第一个程序"></a>测试第一个程序</h1><p>测试之前提几点：</p>
<ol>
<li>runtime还未适配刷flash的功能，所以IDE无法把程序刷到板子中，只能把程序加载到RAM中运行。<br>IDE让程序在RAM中跑需要设置一下：<code>Derive-&gt;属性-&gt;启动应用-&gt;取消勾选下载时隐式创建启动应用</code>，让IDE不下载到Flash。</li>
<li><code>sysdefines.h</code>中的<code>&#123;&quot;CmpAppEmbedded&quot;, &quot;Bootproject.RunInFlash&quot;, 0&#125;, \</code>,0则是板子上电在Ram跑、1到Flash跑。</li>
<li>测试程序还需要更改一下Runtime源码中的RAM位置，设置了才能让IDE把程序放到正确的RAM中运行。<br><img src="/picture/tech/codesys/codesys8.png"></li>
<li>使用串口扫描成功设备后，可以在IDE中编写一个简单的程序，比如让某个值++，然后刷程序，进行Debug。这个IDE界面还是比较简单的不放图了。</li>
</ol>
<h1 id="添加自己代码库（Code-Lib）"><a href="#添加自己代码库（Code-Lib）" class="headerlink" title="添加自己代码库（Code Lib）"></a>添加自己代码库（Code Lib）</h1><ol>
<li><p>IDE新建Lib工程，选择CODESYS Lib。</p>
</li>
<li><p>删除工程中的库管理器和、xxx。新建POU对象。</p>
</li>
<li><p>在POU中添加变量。<br><img src="/picture/tech/codesys/codesys12.png"></p>
</li>
<li><p>编译-&gt;生成运行时系统文件。为code提供接口。</p>
</li>
<li><p>随后在\Templates\复制一个CmpTemplateEmpty模板。把名字全部替换成自己的lib名字。替换生成运行时系统文件中的m4文件到新模板。把<code>myhLibDep.m4</code>、<code>myhLibDep_m4.bat</code>、<code>myhLibItf_m4.bat</code><strong>文件里面的名字</strong>也要修改成自己的lib名字。<br><img src="/picture/tech/codesys/codesys9.png"></p>
</li>
<li><p>完成上面步骤后,运行bat文件生成<code>myhLibItf.h</code>、<code>myhLibDep.h</code>、<code>myhLib.c</code>。把这三个文件放到自己的工程中。<br><img src="/picture/tech/codesys/codesys11.png"></p>
</li>
<li><p>修改组件宏头文件，添加<code>int myhLib__Entry(INIT_STRUCT *pInitStruct); \</code>、<code>&#123;&quot;myhLib&quot;, myhLib__Entry, 0&#125;, \</code>。c组件宏头文件指的是【CodeSys】移植Runtime中的 <code>myProject.h</code> 和 <code>myProject_Notlmpl.h</code></p>
</li>
<li><p>把生成运行时系统文件中的.c文件里面的函数复制添加到自己工程中的myhLib.c中。<br><img src="/picture/tech/codesys/codesys10.png"></p>
</li>
<li><p>在函数中调用p指针访问接口，实现自己的算法！！ done<br><img src="/picture/tech/codesys/codesys13.png"></p>
</li>
</ol>
<h2 id="测试代码库"><a href="#测试代码库" class="headerlink" title="测试代码库"></a>测试代码库</h2><p>和上面测试同理，IDE编写代码，调用代码库的接口。Debug看看值是否变化~</p>
]]></content>
      <categories>
        <category>CodeSys</category>
      </categories>
      <tags>
        <tag>CodeSys</tag>
      </tags>
  </entry>
  <entry>
    <title>【CodeSys】适配串口驱动</title>
    <url>/blog/CodesysAdaptSerial/</url>
    <content><![CDATA[<h2 id="适配时间组件-SysTime"><a href="#适配时间组件-SysTime" class="headerlink" title="适配时间组件 (SysTime)"></a>适配时间组件 (SysTime)</h2><p>适配<code>SysTimeOS.c</code>的下列函数，为codesys提供系统ms、us的tick。可以参考代码中的例子。</p>
<ol>
<li><code>RTS_UI32 CDECL SysTimeGetMs(void)</code>，</li>
<li><code>RTS_RESULT CDECL SysTimeGetUs(RTS_SYSTIME* pTime)</code></li>
</ol>
<ul>
<li><p>毫秒：如果是HAL库，可以使用HAL_GetTick()实现毫秒；如果是ST&#x2F;GD标准库，需要自己实现函数，获取滴答定时器计数值。</p>
</li>
<li><p>微秒：都需要自行实现函数，获取tick时钟的计数值，计算出微秒。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例---系统时钟使用的TIMER2，定时器period=1000,</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">getSysTickUs</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> TIMER_CNT(TIMER2);</span><br><span class="line">	<span class="comment">// return __HAL_TIM_GET_COUNTER(&amp;TIM2_Handler)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配串行接口-SysCom"><a href="#适配串行接口-SysCom" class="headerlink" title="适配串行接口 (SysCom)"></a>适配串行接口 (SysCom)</h2><p>首先确保程序中的串口驱动正常，串口接收的数据使用环形队列存储起来。随后实现<code>SysComOS.c</code>中的函数，为codesys提供串口读写接口。</p>
<ol>
<li><code>RTS_UI32 CDECL SysComRead(RTS_HANDLE hCom, unsigned char *pbyBuffer, RTS_UI32 uiSize, RTS_UI32 ulTimeout, RTS_RESULT *pResult)</code>.</li>
<li><code>RTS_UI32 CDECL SysComWrite(RTS_HANDLE hCom, unsigned char *pbyBuffer, RTS_UI32 uiSize, RTS_UI32 ulTimeout, RTS_RESULT *pResult)</code>.</li>
<li>到此即可烧录程序到板子了，先使用串口调试工具，查看板子Runtime是否会定期发送内容到调试工具。若成功即可下一步。</li>
</ol>
<h2 id="配置CodeSys网关"><a href="#配置CodeSys网关" class="headerlink" title="配置CodeSys网关"></a>配置CodeSys网关</h2><ol>
<li>安装xml，IDE: 工具-&gt;设备存储库-&gt;安装-&gt;<code>XXXXX-Cortex-embedded.devdesc</code>。</li>
<li>新建工程，选择标准工程，选择Device（上面安装的）。</li>
<li>点击工程的Device，<code>网关-&gt;配置本地网关-&gt;输入COM端口-&gt;选择波特率-&gt;ok</code>。</li>
<li>扫描网络，若串口ok的话，会扫描到从站设备。</li>
</ol>
<h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>适配SysCom时发现一个BUG，经过定位找到是armcc和gcc之间<code>宽字符类型</code>差别引起的。<br>Runtime中的<code>RTS_WCHAR</code>是2个字节的。<br>GCC工程中的<code>RTS_WCHAR</code>是4个字节的。<br>若不修改，串口发出来的数据每个字节都会多两个&#x2F;0。<br>修改方式如下，在合适位置添加以下宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#	<span class="keyword">ifndef</span> RTS_WCHAR_DEFINED</span></span><br><span class="line"><span class="meta">#		<span class="keyword">define</span> RTS_WCHAR_DEFINED</span></span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>		RTS_WCHAR;	<span class="comment">/* wide character value. We expect 2 bytes unicode here! */</span></span><br><span class="line"><span class="meta">#	<span class="keyword">endif</span>	<span class="comment">/*RTS_WCHAR_DEFINED*/</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CodeSys</category>
      </categories>
      <tags>
        <tag>CodeSys</tag>
      </tags>
  </entry>
  <entry>
    <title>【CodeSys】移植Runtime</title>
    <url>/blog/CodesysRuntime/</url>
    <content><![CDATA[<p>本节内容为移植CodeSys Runtime源码到Cotex-m7平台的记录，开发环境为STM32CubeIDE（Version：1.10.0）。</p>
<h2 id="使用-RtsConfigurator-配置runtime组件"><a href="#使用-RtsConfigurator-配置runtime组件" class="headerlink" title="使用 RtsConfigurator 配置runtime组件"></a>使用 RtsConfigurator 配置runtime组件</h2><p>使用codesys开发源码包的 RtsConfigurator 软件配置runtime组件。<code>目录：\Tools\RtsConfigurator\Bin</code>。<br>打开软件后，会弹出以下窗口，让我们导入组件。<br><img src="/picture/tech/codesys/codesys1.png"></p>
<ol>
<li><p>加载组件，导入开发包中的<code>Components</code>.<br> <img src="/picture/tech/codesys/codesys2.png"></p>
</li>
<li><p>加载系统相关，导入开发包中的<code>Platforms\SysTemplates</code>和<code>Platforms\SysTemplates\Sys</code>.<br> <img src="/picture/tech/codesys/codesys3.png"></p>
</li>
<li><p>添加操作系统前缀，可以默认使用OS，也可以自定义<br> <img src="/picture/tech/codesys/codesys4.png"></p>
</li>
<li><p>勾选需要移植的组件<br> <img src="/picture/tech/codesys/codesys5.png"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CmpAppEmbedded</span><br><span class="line">CmpBinTagUtil</span><br><span class="line">CmpBlkDrvCom</span><br><span class="line">CmpChannelMgrEmbedded</span><br><span class="line">CmpChannelServerEmbedded</span><br><span class="line">CmpChecksum</span><br><span class="line">CmpCommunicationLib</span><br><span class="line">CmpDevice</span><br><span class="line">CmpEventMgr</span><br><span class="line">CmpIecTask</span><br><span class="line">CmpIoMgrEmbedded</span><br><span class="line">CmpLogEmbedded</span><br><span class="line">CmpMemPool</span><br><span class="line">CmpMonitor</span><br><span class="line">CmpNameServiceServer</span><br><span class="line">CmpRetain</span><br><span class="line">CmpRouterEmbedded</span><br><span class="line">CmpScheduleEmbedded</span><br><span class="line">CmpSettingsEmbedded</span><br><span class="line">CmpSrv</span><br><span class="line">SysCom</span><br><span class="line">SysCpuHandling</span><br><span class="line">SysExcept</span><br><span class="line">SysFileFlash</span><br><span class="line">SysFlash</span><br><span class="line">SysInternalLib</span><br><span class="line">SysMem</span><br><span class="line">SysTarget</span><br><span class="line">SysTime</span><br><span class="line"><span class="comment">//以上是必须勾选的基本组件，以下是拓展，比如UDP和FreeRTOS</span></span><br><span class="line">CmpBlkDrvUdp</span><br><span class="line">SysSocket</span><br><span class="line">SysTask</span><br><span class="line">SysEvent</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消除RtsConfigurator的警告"><a href="#消除RtsConfigurator的警告" class="headerlink" title="消除RtsConfigurator的警告"></a>消除RtsConfigurator的警告</h2><ul>
<li><p>如果前面设置系统后缀是OS，则无警告。</p>
</li>
<li><p>如果是自定义的后缀，需要去<code>\Platforms\SysTemplates\Sys</code>目录修改对应文件的名字。例如<code>SysTaskOS -&gt; SysTaskXXXX</code>.</p>
</li>
<li><p>消除后，点击<code>Output-&gt; All output files</code>,输出工程文件。输出如下：<br><img src="/picture/tech/codesys/codesys6.png"></p>
<p>生成的<code>include</code>和<code>soures</code>中就是组件的代码和头文件，<code>myProject.h</code>、<code>myProject_Notlmpl.h</code>是组件选择是否开启的宏。如果后续需要添加自己的<code>代码库</code>或者添加<code>新组件</code>都需要修改这里面的宏。</p>
</li>
</ul>
<h2 id="移植到工程代码。"><a href="#移植到工程代码。" class="headerlink" title="移植到工程代码。"></a>移植到工程代码。</h2><ul>
<li><p>移植RtsConfigurator生成的<code>include</code>和<code>soures</code>代码到自己工程，复制<code>myProject.h</code>、<code>myProject_Notlmpl.h</code>添加到<code>include</code>。<br><img src="/picture/tech/codesys/codesys7.png"></p>
</li>
<li><p>替换添加文件：替换工程中的<code>sysdefines.h</code>、<code>sysspecific.h</code>、<code>SysCpuHandlingOS.c</code>文件，添加<code>callonstackASM.s</code>、<code>SysCpuHandlingArm_Cortex.s</code>到<code>soures</code>目录，添加<code>CmpErrors.h</code>到<code>include</code>。</p>
</li>
<li><p>修改添加文件的头文件：<code>sysdefines.h</code>中的头文件改成自己工程对应的头文件,我的如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myProject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myProject_NotImpl.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>mainOS</code>中的include：<code>#include &quot;myPlatform.h -&gt; #include &quot;myProject.h&quot;</code>。此处的OS是后缀，前面自定义的。</p>
</li>
<li><p>修改<code>mainOS</code>中的<code>main()</code>函数，修改成<code>int codesysMain(void)</code>，参考以下函数内容改代码。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mian函数的最小运行版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">codesysMain</span><span class="params">()</span> &#123;</span><br><span class="line">  RTS_RESULT Result;</span><br><span class="line">  Result = CMInit(<span class="literal">NULL</span>, s_ComponentList);</span><br><span class="line">  <span class="keyword">while</span>(!s_bExitLoop) &#123;</span><br><span class="line">    CMCallHook( CH_COMM_CYCLE, <span class="number">0</span>, <span class="number">0</span>, FALSE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加系统调度相关文件：<code>CMConvToStr.c</code>、<code>CMEmbedded.c</code>.</p>
</li>
<li><p>把codesysMain添加到自己程序的main函数中，运行时候即可运行codesys，此处实现的是的裸机跑CodeSys，多任务后面在讲。</p>
</li>
</ul>
<pre><code>&gt;以上替换的几个.h .c .s和调度相关的文件，需要找CodeSys公司要。
</code></pre>
<h2 id="解决工程的ERROR"><a href="#解决工程的ERROR" class="headerlink" title="解决工程的ERROR"></a>解决工程的ERROR</h2><p>移植过程可能会出现一些编译器版本造成的error，例如下面。</p>
<ul>
<li>armcc和gcc版本造成的汇编语法不同，修改<code>callonstackASM.s</code>、<code>SysCpuHandlingArm_Cortex.s</code>文件的汇编代码。替换成gcc适配的（因为我使用的是STM32CubeIDE，若使用Keil MDK可能不会有此问题）。解决举例：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的</span></span><br><span class="line">  PRESERVE8</span><br><span class="line">  AREA    CALLONSTACK, <span class="selector-tag">CODE</span>, READONLY</span><br><span class="line">  THUMB</span><br><span class="line">        EXPORT callonstack</span><br><span class="line"></span><br><span class="line">callonstack</span><br><span class="line">    ldr r5, <span class="selector-attr">[sp, #+0]</span> </span><br><span class="line">    push &#123; lr &#125;</span><br><span class="line">    push &#123; r3-r7&#125;</span><br><span class="line">    mov r3, r0</span><br><span class="line">    mov r0, r1</span><br><span class="line">    mov sp, r2</span><br><span class="line">    BX  r3</span><br><span class="line">    pop &#123; r3-r7 &#125;</span><br><span class="line">    mov sp, r5</span><br><span class="line">    pop &#123; pc &#125;</span><br><span class="line">    END</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改好的</span></span><br><span class="line"><span class="selector-class">.text</span></span><br><span class="line"><span class="selector-class">.global</span> callonstack</span><br><span class="line"></span><br><span class="line">callonstack:</span><br><span class="line">    ldr r5, [sp, #<span class="number">0</span>]</span><br><span class="line">    push &#123;lr&#125;</span><br><span class="line">    push &#123;r3-r7&#125;</span><br><span class="line">    mov r3, r0</span><br><span class="line">    mov r0, r1</span><br><span class="line">    mov sp, r2</span><br><span class="line">    bx r3</span><br><span class="line">    pop &#123;r3-r7&#125;</span><br><span class="line">    mov sp, r5</span><br><span class="line">    pop &#123;pc&#125;</span><br></pre></td></tr></table></figure></li>
<li>可能还会出现其他奇怪报错，自行解决。</li>
</ul>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>解决工程报错后，组件的移植即完毕了，可以Debug测试一下，是否能进入<code>CMCallHook()</code>函数进行循环。ok的话即可进入适配工作。</p>
<h2 id="添加license-随意，不添加则只能运行2小时"><a href="#添加license-随意，不添加则只能运行2小时" class="headerlink" title="添加license(随意，不添加则只能运行2小时)"></a>添加license(随意，不添加则只能运行2小时)</h2><ol>
<li>复制<code>3S.bat</code>到<code>\Tools\ConvertFileToArray\Bin</code></li>
<li><code>ConvertFileToArray.exe</code>运行&#96;3S.bat，生成3S.txt</li>
<li>复制license到工程中的<code>sysdefines.h</code>文件内.  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LICENSEFILE_DAT  &#123;\</span><br><span class="line">0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\</span><br><span class="line">0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\</span><br><span class="line">0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\</span><br><span class="line">0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,\</span><br><span class="line">0xXX,0xXX,0xXX,0xXX,0xXX,0xXX,0xXX\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CodeSys</category>
      </categories>
      <tags>
        <tag>CodeSys</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】51劳动节の上海</title>
    <url>/blog/230501/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="25ccec19717472ebbf8534d8b3e05c014400451101b437b372a9433e7a3c452b">eef66fd449a307f3d6a4c72bf278b805dd00b3a1ff9a6b96764414421ea57e9e25aa989f03b42f8df94e5f8448c21c3d6927db08abf322c69b638fa4b45a73b29ae35a29c2f854e39ec13c5ad7a01909adf69229eebcdb5a47c9064aecc50aef3473effd337bd9d93aed92a486433f234303fa20d2b1abbb747633f11ad2eb334308eb26724bc8a4dafe917ffed03024cbcd70e3a4217b759ce6ab6d4ec724f582189a26700577ac6f1687512b30750ff70aae8e460a51330bf261470de3e973d84d091a7ded665548839783569874df148064ee8442ce7d466b9d5c96d43fb9a88975f6d5b9db8346895948ed0cdad9298a57e37196ad9de8bf7784154dd6524a4df385073e325bc1c51ed10d5aafbbbebda52093ffc613863ca8782f1819218c449f9073da2fafc2764ab22fb658ca83342e2c9f0614357c17882444d3028b720c57649c1e0c48bde97cf3edb948dc36cc90517af90dee3e79e10fa493c1cdc6340f74a46f4f53697721f6fe7f1572cf522295e98d4fcd5ae72335a2a9246fe3501de8ba364009dd6c089d7ccfe1cae8bbfc2d182c413f81645d9ad058b2eac2c904a2211fd02ae9decfdfd9ccf4a397b6645c195b77708d1619c3c013a207c26dcbf8895f892b71da594d4719731e9dd271a07baa68ef083b0108c7550ac940c5918685eca37919df6ee5f125c55e37b9d9cb3b284372b7252d9c8ae423a6a6c22d1fbc87fbc6cd3e55179455fee7f2d8eec1ac2b9c5f7c1c946c84524000f4bb16384c17b6787e72eeeb9d291cb3566a168aa43ab310ad7f8cc3aa2a34e58ff9e4f1eb80de06903cb306af74db5fae105b2ec128702a39d7feedd944fbc95308b0f09ec1ab747d2d1d79608e67078615bf00f2233d35e36aabaaf665e10d722cd8b1775e0181df261c781dd3ed59f8a9daf446647b33540f94ef0c8f9486b9edb041d0feca4308320db969027e805ad0a55dcc4d23e08e5fba503b4c40509b043ac4f5739739aba8ac21508bf2fd98f61dd287ed4b778f93c8b375a7eac93a8bb98097fad2c642063dede20cbf698bbc0ea9760e8cc19c5259d77f9e85f9a6241de409a103e322d676bb8f7b0a6c0093959970c60041a3327ffd23707f86fe675de3f4232361e294ce215ee136819fac2f0371189d926841834854418201e3762f797353e498973814aa3ed9d4d6eefafe3d8f5a6b7fb250f54989b1857c921696ca414a43d7674814e97231f55284a4d2a269643cc2e1afd17c73b4a1cc524d4211fe2034c55da029a5eeb1885ef394896110043bf5c2aa802fa59a801e0cf8c69491a7be4d8cdfcb54f8ac1fe67ab450a2977c5ba54658e4a4965a4a01dc8bceb0f1670c9158c44758dc1b593c410f6e8e6ac51819eec7a4b2b067cc3c0f53b657f03701ef767b2b828a1fcb7d4d0bbce1cdd259311d83e58494cbe7d221b1954ac94090cf1aae602a900aabdeda00501fd32c3a757764718b27e97ce966a94f129ac2698fb17ce671a23e8efd3cdd3364f8be4923863500192dbb5620bd26810e1d16af3887427c66e7f881d3292c386820e8ade69cdb5ba6dd170354b5a3bf8640b62db0c11c9e12daeb18ebc1fb5050fceb7c23f7317b12d8dd766ffec130c044c442b635ca58490521e6b5a03e1aca9fd4e26dd882dd977489a73b4295c5e7a3ec77d697e10f10556080f02f9b5840878edbb8c7ff4c6e60a80617dbbe9d34884c423e51286d6e2b7fa14b9f29aa927ff89f5a8942658ffddf6e1850edbae647f654bb27f5cf6a6c03a2066b19cb181782872712c301771a6f9eb66cdb9393745ccceb6cd60d796bdd8d458245f396dc1b4dbc42c1f5708e150591fd5ecbf593947351008ef5fe64094ea81199cc77d26caa4cf5f7c80dd379111c35692aba3bea5edb602de93edb78406ba3a9ac67638a452b3759d2cf57fb3c25fed44a959e04730fb78b7fd8fc2ca0759b6811fc487c294c9d35d3b6533df9b8106d396b7c7682edbcc58146b669a957dfc1c5064cbc0788269d57d22fc7dac6b4e7ac37bb61dc9882824b9d3eda01488a9930d437b7d75d68754c31c5a83442</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】51劳动节の千岛湖</title>
    <url>/blog/230429/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="178de5a7b5e9072e7c19fd5e1e41bd1c37d177fa7b7f971b685f5bd054dd30bc">eef66fd449a307f3d6a4c72bf278b805dd00b3a1ff9a6b96764414421ea57e9e25aa989f03b42f8df94e5f8448c21c3dfefa1e93aa8b165713c349cddfa4da8ef9ecfaf7b28e129dee0398a81ddc1d790f5399a797aef2d2a79d55208be5aff1165b7abd943b9c73a0ee190948d232646da601eed442b91452643d1c53bc0c89395bdce3ae6334b4bc0d6d4983a37be23c103cd98dffa631cf56d058083d30e4152cbc64cb17880464b9d99fcb62837e17294ea31b1149344b13fa8b6c63092f63f0d90ed86d2b4c6713e15cfafd0f3cb6f2434b5c5f0e584d0d0f4a0dad61ad9db8cca3f549a09b81bc43b2c3f6bb8cc9bcb2108970514f172c49ae42a872aa78f712adf0028365b5671a40bb80b7c7ffe723ca8eed79e04915b90d529aeba80b3411b7a3817f434cf67f6cf293cf97300323f9ce43334acab9c577952eb954a3cb87c2f140fa03660dcc5668562a7a83ba0ae77a644e4b53c2c43a1f7d77049f294a3bb26bbf365294fb9938100fd7defcb08191c6da9ad1d105f3a7cb58eb3d7da917f6a666e19745fbb9d2657f95c85f10b0b1d30dc87f9ed5bbacec2e1651a518bf23e117a4cc99fa6d3b4170e5207a212e77aefbeb178504a8f3326da707a99d3cfcbdb902a929310d89097fb738ba5bf1286b980d25d434af3abdf0451cc225b1371fc17244120fd7cb66a42306ac1b0378e2589fc2b9b64fa27ab21730c7d946fd597c739f3ba1f92c5a9d6bfd41a758adb4e3a14ee6ecb2530b3212784f146ea69b01c7fcb7e6d9a5158ffb6bda3c13cdc06ead8a98e7da6411612830d40700d98a15a7d0c10b6bd950f2d016ab1e4d946dee8dce7502cdfe7be0792fe9aa617b50f5c0662a343500eed655d7018fed4c0eadd307876e75415d05d8729e7cc6333d4efd70cfaca640a381962c7f62dba700fd9fd70b3619631094efb85cee53666b022da62485b55e0b59348c78d4b0f17005442eb93e04f8351f4388f9d686ee4c9cc07568f929cc0a697f4b4a830ee9f2649e22d19b62a7e06f6f6dba24ad6612a5ee8229c57bfb4546cb592cc95536c64fbbaa2bb7a7bd2ba255a9650568ccde23c36af807646e6a7cf3b8bca63822ce01739846d04bd6a66ac9cee7b0019a1b9aa297f9de381164303e3ff08d37e5611214a2785d44d42f4e6d8f4fabd328bc3b72329c9930c63926ce895298e1e174c748d7a35d339804f26ae07eb4dc7ada7510a8d9da36795dd47ed2ff95970a9e4ac193becb756684e67e3dbfeac272a0d7341527027d439ea8f86b4a06f0a9c13d6e2e95d6d70ec0ea6906aab946c2923d20e307d13038034a1abd2b99fd6b73a44530a0422dbee8f0b0a03b01640559f83381760e1a32182a295507990f3aedea30015163dec69bc6a07b5a74feae2d688f6a238e50741f99118a8007a68b170c7f5f493139b9e62ca8eb0f1b3f03a7006181d5812c5cd00e11936ecbcbd62992bbad1e2f18abda585e7592c539520a849c1a64c19cdb5d54303092907f946ea45e9ac945a405c4f4a7e50939cf718c8449e58a775ec1a7ea1281948c41d1296b05b20df088b452a56d331d649143b227aa0de216bc2050f856ba60a1435ddf2ac6624c40a44570b57849e1a31d60a7caf7d845bead6220f2703cfbd0d969751d5d71e9ed3425861ca860f24e5aadbbdd507028dc22aa7fa2553e69d60c41f7f96008fbfe2261eec5b1e7249f72f41d6d0084ba6dfbcff29cc158b59b6d405303ce4c13f47d61553a26daf04b4e3c9715317b8bafa73baac1c90fc532ddf877c7f023307184a71ff45e8e9a597089a51d5b3e1f6e5725aa379bb344c79114e28103cf833ae341bfa073eca6f53ceda1c062d7329108270d21785953f4acaa054b2118ac25a614be1f15153dbd80656a32a76a67e9d3d91c75baebb1f663d046d9926ac1abfd8fbb6930c5d3a921dda44f11344bbd6b5483c9449f2849cc19b2964f909547c65130c8a783280dbc866e698929cf6dfd04d98d80f1c6136e943bb7a34f2cab89a7fde4ac09aed01a4a06d71520a81eac588c157ab8fb20abc424ef9119f065c872055b48e45a282c8d70750b1b36d6ca59c7db21740f6f3a9e7b3c78cb4c242dff39b83ec1bfb2beff31627d9feab10ffb2a51b7712fd98c781d99a963407d6b4f5afa31a883a79881c0d9e9f857780ffcc8601fb1608b934f7ed798a4041621b1253317</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】高频问题（C和C+的区别）</title>
    <url>/blog/cPuls&amp;c/</url>
    <content><![CDATA[<h4 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h4><ol>
<li>malloc是一个函数；new是c++的操作符。</li>
<li>malloc只分配内存、不调用对象的构造函数；new会分配内存并且调用构造函数。</li>
<li>malloc返回类型是<code>void*</code>需要类型强制转换；new会返回适当类型的指针。</li>
<li>malloc失败时候会返回<code>NULL</code>；new失败时候会抛出<code>bad_alloc</code>异常，除非使用了nothrow。</li>
<li>malloc使用<code>free</code>释放内存；new使用<code>delete</code>释放内存。</li>
<li>malloc需要显式的分配字节大小；new会分局类型自动计算需要分配的大小。</li>
</ol>
<p>在C++中编写代码的话，建议使用new和delete，他们提供了更多面向对象的特性和安全性。</p>
<h4 id="malloc底层实现"><a href="#malloc底层实现" class="headerlink" title="malloc底层实现"></a>malloc底层实现</h4><p>malloc又称动态存储器分配器，维护着堆空间。且堆空间是向上增长的。</p>
<p>linux系统中malloc函数一般由glibc（GUN C Library）提供。且分配的是虚拟内存，如果分配后，内存未被访问，则不会映射到物理内存。当访问虚拟内存时候，查找页表发现没有对于应物理内存，则会触发缺页中断，建立虚拟和物理地址的映射。</p>
<p>申请内存时候可以根据大小被分为”小块“和”大块“，对应两种不同分配方式。（linux系统默认128k为区分大小快的界限）</p>
<ul>
<li><p>小块通过brk()系统调用从<strong>堆</strong>中分配内存。</p>
</li>
<li><p>大块则通过mmap()系统调用在<strong>文件映射区</strong>中分配内存。</p>
</li>
<li><p>使用brk()方式申请的内存，free不会把内存归还给操作系统，而是缓存在malloc内存池中，等下次使用，目的是下次使用会快速。退出进程时候系统会回收所有资源。</p>
</li>
<li><p>使用mmap()申请内存，free会把内存归还操作系统，真正释放。</p>
</li>
</ul>
<p><strong>mmap缺点：</strong>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。</p>
<p><strong>brk缺点：</strong>内存碎片导致泄露。</p>
<p>malloc之后的内存地址和堆空间的地址范围是不一致的。是因为还有一个内存块描述信息。通常是16字节。比如内存起始地址是 d73010，而 maps 文件显示堆内存空间的起始地址是 d73000，多出0x10字节。</p>
<h4 id="在4G物理内存的计算机是否能malloc-8G内存"><a href="#在4G物理内存的计算机是否能malloc-8G内存" class="headerlink" title="在4G物理内存的计算机是否能malloc 8G内存"></a>在4G物理内存的计算机是否能malloc 8G内存</h4><ol>
<li>操作系统位数，32 or 64？</li>
<li>申请8G后会不会使用&#x2F;访问内存。</li>
<li>系统是否开启Swap机制。</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><p>在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</p>
</li>
<li><p>在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：</p>
</li>
<li><ul>
<li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li>
<li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<h4 id="指针和引用区别、如何互相转换"><a href="#指针和引用区别、如何互相转换" class="headerlink" title="指针和引用区别、如何互相转换"></a>指针和引用区别、如何互相转换</h4><ol>
<li>指针是一个变量，保存了一个地址；引用是一个对象的别名。</li>
<li>指针可以指向一个对象或NULL，未初始化时候值是随机的（野指针）；引用必须在声明时初始化，且不能更改，不能为NULL。</li>
<li>指针可修改指向对象，引用不能修改。</li>
</ol>
<p>相互转换：</p>
<ul>
<li>引用到指针：使用<code>&amp;</code>操作符获取引用代表的地址。int &amp;ref &#x3D; x；int *p &#x3D; &amp;ref； </li>
<li>指针到引用：解引用一个指针来获取它指向的对象。int *p &#x3D; &amp;x；int &amp;r &#x3D; *p;</li>
</ul>
<h4 id="extern-”C“作用"><a href="#extern-”C“作用" class="headerlink" title="extern ”C“作用"></a>extern ”C“作用</h4><p><code>extern &quot;C&quot;</code> 是 C++ 中的一个链接修饰符。它的主要目的是确保 C++ 代码可以与 C 代码互操作，并在链接时能够正确地找到符号。</p>
<p>这里就涉及C&#x2F;C++的<strong>编译</strong>区别了。</p>
<ul>
<li>C++ 编译器编译函数时，为了支持函数重载，它会对函数名进行修饰或装饰。这意味着编译器会将函数名和其参数类型组合在一起，生成一个独特的名字。例如下面代码编译后，这两个 <code>foo</code> 函数可能会得到类似 <code>_foo_int</code> 和 <code>_foo_double</code> 这样的名称。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C 语言不支持函数重载，所以它没有名称修饰的概念。当 C 代码中的函数被编译时，它的名字保持不变。所以，<code>void foo(int)</code> 在 C 中可能只是 <code>foo</code>。</li>
</ul>
<p>当你在 C++ 中使用 <code>extern &quot;C&quot;</code>，你告诉 C++ 编译器不要为指定的代码进行名称修饰，而是使用 C 风格的链接。</p>
<p>比如下面：C++使用FFmpeg库（C语言库）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数参数压栈顺序"><a href="#函数参数压栈顺序" class="headerlink" title="函数参数压栈顺序"></a>函数参数压栈顺序</h4><ul>
<li>左到右（少见）</li>
<li>右到左（常用）</li>
</ul>
<h4 id="重写memcpy函数需要注意什么"><a href="#重写memcpy函数需要注意什么" class="headerlink" title="重写memcpy函数需要注意什么"></a>重写memcpy函数需要注意什么</h4><ol>
<li><strong>地址重叠</strong>：果源地址和目标地址重叠，<code>memcpy</code> 可能不会正确工作。对于处理重叠的情况，通常使用 <code>memmove</code>。</li>
<li><strong>类型安全</strong>: 为了通用性，<code>memcpy</code> 使用 <code>void*</code> 指针。但在使用这些指针时，需要确保进行适当的类型转换。</li>
<li><strong>效率</strong>: 标准库中的 <code>memcpy</code> 通常高度优化，使用各种技术（如单词复制，SIMD 指令等）来加速操作。</li>
<li><strong>错误检查</strong>: 在某些实现中，可能需要检查 <code>NULL</code> 指针等错误情况。</li>
</ol>
<p>下面是一个简单的 <code>memcpy</code> 实现：未考虑使用CPU指令、SIMD优化加速内存复制过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dest || !src) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 错误检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为字符指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* d = (<span class="type">unsigned</span> <span class="type">char</span>*)dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* s = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*)src;</span><br><span class="line">    <span class="comment">// 处理地址重叠问题</span></span><br><span class="line">    <span class="comment">// 当 s &lt; d 并且重叠时，从后往前复制</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt; d &amp;&amp; s + n &gt; d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = n; i != <span class="number">0</span>; i--) &#123;</span><br><span class="line">            d[i<span class="number">-1</span>] = s[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从前往后复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            d[i] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数组存放在哪里"><a href="#数组存放在哪里" class="headerlink" title="数组存放在哪里"></a>数组存放在哪里</h4><ul>
<li>栈：函数中声明局部变量，栈内存自动管理，函数返回时候释放数组内存。</li>
<li>堆：动态内存分配（new、malloc、calloc），需要人为显式释放。</li>
<li>静态存储区：全局变量或函数内使用static关键字。此区域存储全局变量、静态变量和常量。在程序的生命周期中一直存在。</li>
<li>常量区：字符串字面值（和其他常量）通常存储在常量区，这是一个特殊的内存区域，用于存储常量数据。这部分内存通常是只读的。如：<code>char* str = &quot;Hello, World!&quot;; </code></li>
</ul>
<h4 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h4><ul>
<li><p>默认访问权限：</p>
<ul>
<li><code>struct</code>默认的成员变量和基类的访问权限是 <code>public</code>；</li>
<li><code>class</code>默认的成员变量和基类的访问权限是 <code>private</code>。</li>
</ul>
</li>
<li><p>默认继承方式:</p>
<p>当使用 <code>struct</code> 继承时，基类的默认访问权限是 <code>public</code>。</p>
<p>当使用 <code>class</code> 继承时，基类的默认访问权限是 <code>private</code>。</p>
</li>
<li><p>C兼容性（特定场景）</p>
<ul>
<li>C 语言中，只有 <code>struct</code>，并且它不能包含函数。如果你在 C++ 中写了一个只包含数据的 <code>struct</code>。呢么C和C++可以兼容。</li>
<li>在C语言中，struct无法使用面向对象的编程，没有继承多态等概念。</li>
</ul>
</li>
</ul>
<h4 id="static的定义和用途"><a href="#static的定义和用途" class="headerlink" title="static的定义和用途"></a>static的定义和用途</h4><ul>
<li>局部变量使用：更改了储存位置（存放在静态存储区），不改变作用域（范围还在函数内）。</li>
<li>全局变量使用：不改变储存位置，改变作用域范围（限定在本文件，其他文件不可见）。</li>
<li><strong>类成员使用</strong>：<ul>
<li>​	静态成员变量：每个类都对应同一个变量副本。以前一个对象对应一个变量，现在多个对象对应一个变量。类似类中全局变量~</li>
<li>​	静态成员函数：不再属于类的任何特定对象。它只能访问<strong>静态成员变量</strong>或其他<strong>静态成员函数</strong>，<strong>不能访问类的非静态成员</strong>。</li>
</ul>
</li>
</ul>
<h4 id="const和-define区别"><a href="#const和-define区别" class="headerlink" title="const和#define区别"></a>const和#define区别</h4><ul>
<li>#define：是预处理指令，只在预处理阶段起作用。直接文本替换，然后进行编译操作。不涉及内存分配。</li>
<li>const：编译和运行时候都用到了，编译阶段确保程序没有修改const的值。运行阶段，会占用内存。并且初始化后无法进行修改，除非使用指针。</li>
</ul>
<h4 id="volatile作用和用法"><a href="#volatile作用和用法" class="headerlink" title="volatile作用和用法"></a>volatile作用和用法</h4><p><strong>作用：</strong></p>
<ol>
<li>防止编译器优化：编译器优化会根据上下文做假设，如果代码中没有明确的修改此变量，则值就不会改变并一次做优化。使用了<code>volatile</code> 则不会做假设&#x2F;优化了。</li>
<li>确保读写顺序：当对 <code>volatile</code> 变量进行读或写操作时，编译器不会重新排序这些操作。这确保了指令的执行顺序与源代码中的顺序匹配。</li>
</ol>
<p><strong>用法：</strong></p>
<ol>
<li>硬件寄存器访问：硬件状态随时会改变，使用<code>volatile</code>后，读取数据时候都会在物理地址获取，不会使用缓存的值。确保硬件数据是正确的。</li>
<li>多线程和中断服务程序：如果一个变量在主程序中被使用，并在中断服务程序中被修改，这个变量应该被声明为 <code>volatile</code>，以确保主程序总是读取最新的值。</li>
<li>信号：信号的变量通常是<code>volatile</code>，确保在信号处理器和主程序之间正确地传递数据。</li>
</ol>
<p>​        虽然 <code>volatile</code> 可以确保单个读或写操作不被其他操作中断，但它不提供复杂操作的原子性或内存屏障的功能。在多线程环境中，应该使用专门的并发原语，如互斥量、自旋锁或原子操作。</p>
<p>​        过度使用 <code>volatile</code> 可能导致不必要的性能开销，因为它会阻止编译器执行某些优化。</p>
<h4 id="常量浅析"><a href="#常量浅析" class="headerlink" title="常量浅析"></a>常量浅析</h4><h4 id="C-C-中变量的作用域"><a href="#C-C-中变量的作用域" class="headerlink" title="C&#x2F;C++中变量的作用域"></a>C&#x2F;C++中变量的作用域</h4><ul>
<li>局部作用域：{ }包含的代码区域，离开即销毁。</li>
<li>文件作用域：也就是全局变量，在所有文件中都可访问。（static全局变量除外，限定本文件访问）。</li>
<li>函数作用域：特殊！仅限于goto语句，在整个函数中都可见，不受局部作用域限制。</li>
<li>函数原型作用域：指的是函数输入参数作用域限定在该函数，类似函数作用域。</li>
<li>类作用域：C++才有。类的变量、函数，智能通过类的对象或类本身（const）访问。</li>
<li>命名空间作用域：防止命名冲突使用的，里面的变量函数，限定在其中。</li>
</ul>
<p>持续更新。。。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】仙英座流星雨</title>
    <url>/blog/230812/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b0d773dfdb1ebb31ab8ee08c93ff3298470ff8f272c78b4c7c2b50a048c76978">eef66fd449a307f3d6a4c72bf278b805ed43de884d2babf48b696b171279d940ce4407d5bb3a6dc069c2ad6799b8de8d35fe295167247ff403939b9458a346770a5b42612e1b4131e912c3c12187030a5c9c265dcf6956768c5228564f9eff22e988a94b6b632aa530ec4218bceff53971e440f1b1143abb742c4862bd172823d6a22855e36dc26a36b7b6a0c1a762cfe2be311d3fb57471d9be3fbc6340fdd63223235b0b308fbdb9229d009914424879c6c6f97255142bcc0d5e8a5130a887f689e54f06ceb8cc9d8a1279b06f5cea58c1fe6e9fb56fc32c4f1ad84037b69f5e3e7dc314d1f8e6d663cfeb1906f0c7f7ffe63e09f83b8dcae5fc7b7bc5644fb55a0548d39649512a7ebfe3b888cfeccad1370458f99775dfe9ab9031e2f8faa49f2e6c54af9f9c18c38ac0b94339c33e1e5f15ba0deeeb1c6a6fa0f025b211b857351e3e5377e7dc833c48cce5907f03d46e905111db924f7b03af2a9456cba87c2c470bfe7b2119560379e2f9a8c73f6a3335e69d0baa95abad30eab9af39e6a901493286590e37f770400c8c9fdc1c1b369cfcd5d6399e0f05f8fea1fcd1153c65ef20bf7c6064ee5ba3efb77f5a979b9e73bec588da19134a971e16cdc0efecd518958da5abce9ef37b3a2c3944c5ca2870712ab3fd84d90a5872617ad2d232fc9756c08896e003200c4073c949f4bf956d3b3846446217f0a3b6dd8d21503c43d7a6afb11c4fdba8feaefa0751b564ae82d3ffe70c04dd56458a3eac7f39bc05942d48dec77fd3648e1f2c0a705910efc0512368ff841194bcf72def53f67f6ae9c266214c5aa36e43a291aeaba7ebb1416fdfdd1473634f38f42ef0b5ed0ac20910ebb150f8b87dd22e7b56b5dadba2579cc4a1fdfcaf345fa034298bfb84891aa9b106c9b1785ca6c4588bab9541e317c27d57a746149f35f040cecc58a40fff0da2e885134bbb7f09d060a808fbf965e7e935533615efad565ffa39a2d688ad1a34409484ff89447752e6799ac25fcc9c09d86fae3f8149344619710878fcd9ee3038506ea711f7eeffeb756929fdf68c47f9f2ab70c6ee213ec2c92022342cf6fd8e34211b7732c88342e5eb4328ac6f6b456fcddd359c851c4c1e936656a1c3a4f6de9ed4204499ee523aa814c40d3ce936c95a82e202449fac6d350b1c1d83710a541805a087aef21dd58c0feadf0654a32af6cffb8adba37771ce0a6942f2fb5a9167927cddecc3153eba5ca82f7fc21119fcca9c1cddb0a69e21e0de92d48b93e934a1e7e24470a092bc2c9e41791b76e4c580ffa4ac52c9a5b3560493c12ad1a985f084f9062d4322b548e87f0da9237d91c912cea15b21230d069069de0fa4b322145abac9d66b7cadca0e8bad636f418ae8f142f89960f22114322b47bcfa9008c4857ea224c8ca6ebda56b5dcdef37936c314623e93709848455d789a8e9583a5482d1328c2c667dfc52efc49c94696be8d35ecaca8d4197d07baf19ac88cae026779e38c3645eb8f137b342933ecba705487ec530bdb324d9310c07068ad52b557295b1751b9cab98eabeca84934dddfef74e96a800a603089252e96d3db82cf83c01d029276c44d64e09c3a25472a97b706a4239e96b3efbd6fcd6b50d6e9fae177e0d678cae05612e3275cc863c75bc8213fdffda9a6c31f8fb4702eec5055fbc050f66a450d278a954669bc45e7bc63a16228359a4e4c136887ccfe8c5c4c3ee50bcd7b8dfda209316140b56fb185c4babcbb391d23d13fac5265b455e9d74decd8919f2e859c5f1f5c79543ddecce8dbd598db5a37e51bdfb96e4b08967ce77b015455b4683792314109c2e72158daf035567aa519f92a682f3f45f382c6edf3ffadf8be8d05524b34b68209079ec6ac6402d7eb7973d559890f4860bc11412857b16eef510ad670303dd94b2dbd69e5589e25bb9e19965cf0a99bf791a1a33ddef3c4799c1809721c24b54211cfa0088051acfadb7ec0a5f1b78bd152831a49c3222c440d34b6c1c52ddbec01408bd6382852249aaacccb30f31498031b6139249da013b469bcabf49e52e43a16a8f1b03e619c81820f6ebd3d2139c9e2a6a948f0f4ba9cdadee2e4aa49dbe0d2e1a3693564c6ee44f8487573ca3c123a55831a947f34f223425bc0420f0281e50d511e2a9feb57d66a91827972a6c0cd9fce7bb67cee13381c63bb49cd51fc2ed6c3a26c329e635d0ab23ea80ffd3426bc9861cb5e8cb6f7e3ecc5f67f822f7dba548b30cb128f8181558fe6fe18d176424ff51ee2e44904e839f3982e6a258d6619214068c76d2e9d00e3d5a3ea90aa6d81108b47abb8a75ae7e07164ea66082247eb33526b98bf4bff36e33161e479941561d77964d330f0f11631a2d91d1dec5213a437c1f69de19b9b10f70480ee13c68a78c5be33761fa5fb5295768a7634a22d60847b2485132671b414d257d19332363a95827ef434d44d1686f3f9294fef1fbda51a2458b2be286f11db10f4db99bac2ce2ddbbb9b2bcfc4d67714a6d76e23ba4f606e537f8d02943f8f91e9a94655dd807e7a826de48420aefeb7627076674c9164d576f9a36f799f4feb92d563339f6038ec3f22eb6c1ece5f7965c26da5b8b75179a6a8681fca030df9fa8de4817c9ba25b5c9215398600c6a7d4dc6641bf05587d58aef660e554686d50e0a617ec5d3b79e6170e6f30573720c783e62fa9341174514ba65759c5f2b708d0d51e1745497a2dc417e26df4009331dcdb91de9e0feb103111ef43fbf8683e6567e3052e42017441bd5ab10ea9fd9e020f978197c861af7c592506f3df8c1e9ddc8b115ccacd8db06818f1945f8dbb758fa8c6e9a1253f2c7e7ddd67a6a4eab89ae8829d71e044cf7691330aca882a33cc70d4664d2c8b0f5e96ec0233718e663436bad29f1a7bf460638e889ee756be66ebcee041b770c2aa0466434072c9bff0d647df2819c403f7465fb0a40306bb2316ecd027dd449e7a47c1193b8e587e6b0125fc1009ed8751b6f35fe1a66dd8166d9a818ec586774ace3b75032fe624a73dcabffca7540cd2c5c36dab786c23d24184743737d14e1576f8c7da9a4f2f575d1b5e4990ba77b1a4667ec2ad984c21eeef4a99f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】元旦の黄山</title>
    <url>/blog/221231/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="125da54d1b4ed5b953d729b28705f2e5cba948e79b92c0a4845ee7dece6b6606">eef66fd449a307f3d6a4c72bf278b805469b3055f12b5706a052a79803207a37fdfc5c879d2a04e992b903b4529470f9ae786b8ae3980f3da09b6d9f059713eac0bf8b4614aefd7946fd8141cf3777612f655b3e90afcf4ca0c3e65d677b37b9f7d2a112f7139db553385685eb13a84432fdc7cd5735417f3be76d22c2f2183465b39711fc63a6bfb60dab6596eeecd443974996abba50cf0613ec9b5bda9a7cc59957659d92ecb3fc8f9fc23131755f523196f2e544658ec74d100873635de1f2dc395ea14ac5580a5ab6bc5aebd32c67b6291b3cde81aba43ef6c4bfb7d1922de14a702d1d0fd6b0e5d1e117217d76405b25a21fc2320fa56cf34a4c4dfef7b3207566815c5b995ca04e3d2fa27e925453c51bc725250a678607c536a1da0c8adbb06a5d8bbd5af0589236d37079fc50a6cc7988d62ce9f467b368a3dd66b6838f6e447353ced8be962fee01f757394bf0c81cfccfe5021fd56a82d87fb4490c589ee7bf7ff06499727e66c367a341f8533387ed81b8bb4180ea4ae3a8154082203a2fa6a600c4631a88d6658f93418dcf79fea66866f2397b86d6e86ca5bce65bece5bc9870c2cef847c77034649acbc5dd755299626881188e65d9dc10c08f41b73b689ac5128ea3f58c1f3e274d2b742f4f113d92a84db6a05b9c1573e1e6d4552cbea3e93cc28ba5ac7230afd158ccc4577717bf2227948c509cbb784b111963290e6d4b00c6b8bf6ce8f8e64420bf52e36a773fd800372c631e8a2594ae5cde1f6985d124fe807a440441238a70a4eb62ac689b00894dda8e8b8ed942337988e5436274a4238bcfce0d986a6ad52c75e7d3f8fc2e2b24fa2e66bcbb2db31b72206eb85cc6e1a56b1d642f675ad66df4e3128c3566abfe83ca4977d7fe9d01936447548b44e9e1091e2a863c961d5772497f75a710f1846fb162a0bee3d97619e07b9acfc68c145cc0bd0334d8e51514124e3f3eaa3e75e00b4ce20f3d98429a19cf54bd5de28a602cce4969e8849b0371d36c7f10cfbf8269e475a112c151d820d24709f307d3b864a669288bb6e1f75cc1f27144b8d64761f28fa6679188fa9fff1756bfa53f961931e5fbe310df4e5a05134bd382b37c4c6bae3f67975e625455cc03f062370e34ccc633d46e2790e13fe9f28650de695c5cd33f6865361cd4ebc34c307ce0813bae46b165d5e71cc37236549c89fb9ccfbfe58f7ed83f4edf6497a120692a096abc9fa7f0bba2acaeacd9c544f90a1596e85bd5152b836b3dd1f8f365cef29233bd96b9ce0b45e1aa4630b662fe978e56df55e4618af9867987a2b18cff8b521ce1dda12cfffcf5894dee577c63da19627c45f7e5239a3a0c591d436117521f7bd2df50c8b0f3966c7989c94f70a2f8b047cbde855aadd464a58b754b0e99c31c53a60d6683e4c2925433058237cc9adf89a3754bd4b437e3110e4d408cc1bdf793f97b72389270c9462b76e48ce5f988e621be5bceecfa80cc3102625a1fa3a00b166ab111a9a0322b190626dd5d91a796ff36a87a81789f4e1f83506a2ee5ab01dde8ae90e12b883624cee99a0114a4a248431924841fc1a6242b35a159262d666310b4e702e18608bf7d94fe835f8bb09404db350f04d374cbcb3ef403c63920d2e4dec0dd7bd7b9bad03fb4407d2351a5315098a8b249d0c53b9e9d7ac91558dae57590570c77eecd7036fb0ead0b45b91dfe0ac62c53b6d569917dcdcd0921d83ac0aff7dc840de7bd69d358b58c1f5925c1d18d98178cfa0ae8f84dc9b7334cab860e962cc356f006189472a528d825adc4c3f0fbedde39cff074054f0af7b54f10dbe83c1d293cacaa36134333a8ae78656a1cb7a5a877b8b403c231098c89e8646f157faf741c8bc24978b8a6a39010d33f6d9bbb2f9fc81258f9d5fa49f4af49a0a5380a7f253d64f03803397f3db85975c3efb7f4e01e135f4e71a91ac3b90ef4668ad53a152673f5356c46ce8e32ea439d3c382547bcad0a758febeebdcfdfa6f69e012d3eeeef81e8a31a7065054efe4620a768893f8cfebcd662bd1898acc035b3625d2f691ba0f9d1e4c77428db930991eb48130b0c9fa8d276387cd2cef1bc2f8a66d173809f58b60494ef2f3377cbcb86b67112344241c413b4982c934479f7fa60767348dffdd35dd91414117195df1013dba3ff9b312a7bb842105cc89f31637708e68e5dcbdce10332ca0b34c4e2685a8f89d682673fc20cd57d3e50f0583ab47dc61a18c375e1781e4f5b154140e67926d477a8e4667240c29b9d4d0c101d7384133ab474193ebbc845b0819b6b7764049184af23c9098450b93b653c51033d6cc257372c688ed2e5400ae96b9e8bd77f9b83c0a331e607392aa268785abcc4a1b2eff191adead8f7e5f4af051dfd43976688aa5a86bf4667252f54b306e2bb0b1dacefbc44c821533698002ba8f442f8b82b1560616d9ece82d848d2a273789465ca7be669e63234d35c8ca21e1b37cb50ac459890571d3c115b5ad5b67aaacf7ece777393c889e220aefe6c2599f9b9da0ae36d954572f403ad7db1b11b69724fa3d1aac544f999d96ebacb851257c38f23af83f23c43c9009ae9e8c03f63d4a22ade3e5e7ba2eb35bf9bc3cdc8626aeb9a741101bf92b9eb69facad042f90efef360c859f31865abfe3de1fb2e892cb148ad3095a9b457e4cfc8d99fcc5e3eb6ec643f73b44db3e00ee926c1ad63834659792281998111187228b0028df0e66dbbb757dc1a661994a32ddbd550a1fdab5999ce5c3a27c6401494b150b9e1d870b5d888040b05e969cb921e3c83f65fb2368d1f9905e6cccdaafd8ca786852a25476499fde15d84a10ea07eb80ccea1113b6b9aa59701167d15535c4f70de867a9c9cb0f2405de257e1e0e501f4feb6879482da69165cfa3f5d23a83c7ea5580ea0b4280824ae522aa4f2383fe16f30a3718e4c140033db08631d8550547a365f2ff4081b9a01c6da3729a6c2733a1d40dbf09c3ec311d4d2f37a30d9814dbb4d78b545dae98407089e6e34d8f615649f7b450c29b3458ccd7940681fa8ae05c8ff69f64872f43a0157e7abe4e442d0ee89132acba959dde6f6fdd8bddc0858c61c09078c61b2fc34c4b7e4ec44d297328ad34c94cdebb41f10d39f7d22a3b1d30ba0a786f7ec618766c2185bc57d41226fedd1f8855547885864404e3085af90a2c5fe4a54aed605df49574e9007bed968798d846018d8e1f5ee5583847b371d6b1b9ebea084d91ffe9ea0fa25d47803b035ce203dc5998132d8ee8263e8826229cc5a826799610f6b4bc08eaab10feafb518d377b955f66fbbeb8e0979d6a5a10e6999ce769ec9dbde46eea67f1a4a0c65282a43fa6e7fbfa6e2a053bf8451e89966ef595fb029417c6c1f808251ed6ae3df0b200aa647faa2d3c3a8de5c2dd6745e1621fd15e1edcb231d9594de3dbdab75050a31ed7604263fc99dd87c09eb6240dd6b3b70fb0154e172ebe79e193fca228e3d86da9beeb5bcc4dc736f02747627c104fffd5181fccfe4cb18205769ca13b0a7e80a434f494975a698f37ccd58d3ef8d562fafea7f6893d2ff606eb9fe52280c51366af67fc39d371360db6081bea9472093cbfd0d033646bd64b64bb9b023f3d35cdcc2b8130116eb54aa33d30fffe27e4126b9bc21ce9677e995f70398e16d8febc976e91f8ba6687ec3d0fa3927ad317e2d5fd2fe5b98472ef73edd357dd7be9a117aa5bc044c4554c1532631719da08cf0bdece209653985875481350c2f70db95601cea340a047ba7f7945b1fc9cc838016cdd7c83e4623fb1850879a850a144c17ebbea06abd46d4548755c932c4b19983b9f6624a00eb72aa9dcf1685aa966f255f013adc5ea60c2dd1a9e79000bcaea34c1c08e6b3a4ba625543d097907627b535e5b61d1f2ddec21f725ed9c71a2fd83ba6abf523cca85eb4631fa9334b2484299521f682b6ca503d8f4b706a1ba51252fdcebb70c7cc421b237a19fee8016d885173c5566f0e3f173a3c1ef2a01f51b3b3cd2ee1116d72f9ea2fc216bcf2d46</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】十五拆弹</title>
    <url>/blog/230204/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="04d08556cb44a330cebb398c3b4c1b9037bdf6ce8233c2b9ed598b2a04526dad">eef66fd449a307f3d6a4c72bf278b8056bfc5e921b6229dd2a5ff536acabb0d71a2196c751f18db12c93461a8bb74403d3f61dc55eddff420aa0258115db5e7462f3aef87ea448f5e100b5843f75faed3eb72ee0a0a34a36feb03558b7884ac1504dc7e99ae231e3447b13d7c48e916a2a34e43411139357ee8e1f11c7b01645f93892895a1f13d0f38e336f8e393e8e4621ee7d35d16acd2c87e767f309c5a2e06f2dc099a1a2ce2f362cdd4f62afeb7543542e9e01644c52c31f665bac049992278f1ae5137b2b985a0ae21aae256c23e194085245d26e2cc7da4ce9d2de6cbb31a0a5874a92ba152db99d48f3e8f0c734db1ca4da647b2b4132934eb81302f560ef1295f799ed6ee3f3a09ddfd4afbf18df785426ffad05ecee29f18d9c5e2c4e612c9aa9e81bc861b3c0dfe5b12835d904ecc9b1192d750871ecfea5f2ff946db01204c7566b72676842a8abab1fa52edd48755d20341834a9d716f8ca5a026bc31e85cf9eff4e37f590c326f0d9db328c440eb284c63d7853f1e20d720b79932cca48eebbedffc6f371fdf80c603dbd55b721dca13446d8d2beec3fddda0dd1a8d316ddd0912ef54861dd0026bfc9a1332db0730677ef08c110490d4a707b5b8debfcb14ffc0dcab90e456bd08bac5907852f87e213adc874b04c898c3582e303a439646559bfa4d77296cbf0f4a1412e9eb48b596fa900cd5426b4636ffb897812a9ea638ae8e2552a3123457f1bda7ba0ed0f241cb2fc180393c595d264c28e0dafd462e6a135e4f263de5c8cc72f3c9faa7daaf5f24e07ba42fc65d6c9d6ff4ab2bad30775ea51daaa494a6ec6b089f10d480067942a564a31bc1d2ef78c05bf3b34d5e77e1a0f33967fc15f1a92161487c470b335fbf65ddd1bd060d2d9a83554d17b7d84fe7c0100182455db8431ee27ba58c316cbc4c25c4016a72d634395c6301371d12ea52ed4865bb1fc809a5ade9653c5691b42806d3ab5188be71bb85389e10d3395557da010ae35664c35a806e9af8e8f42f32685868fde0546b24b8ab0c273c98daab630d0685af0dcd28c7ea0f32bd2799dbc0a0d3701549b7d4ba6270076bd21db40d950a43e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】周末の莫干山</title>
    <url>/blog/230527/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f6ad41636ef0a04249f9c97914275f2e1aa375e645a3a83b534989d1982fe4e1">eef66fd449a307f3d6a4c72bf278b805ba1453df757cd7369619e6c5cf5f11afa1ae395d5f7b7fdb50d9e98f921ff2219e97f2607254b04d42ed44e0128e7644108b244e99ee3cbbbc3467e5d06be4a5c76e2c0ad0b2540efcafaa943854ec2e5a0d5910f946bfa745a759c69bf22c9fadce4c00c006da64527ac31b7ec26b261ff28470bcd34e6a1dedb90b87ae7d51c60568a725c75e2091188b971539311d70d26629200c37493f1c35a085490d6c089d59204df957911e3f6ee2f08f73d7bea733cfd1e5db7f0dd50f7a509fb7f6e052f5a3ea36a3a5db4a4295579ed6f1f650e0640092c7357223d0fb0c8560e7b07337302aa69cd43f1126ffa1f35cf742c149f7b0e96881b422d4823bd7ba3ad285694bda3882c255d8c81685bc90699ae3e86726df8159065a22050967c7b06e76470e041b99f9e29afaff375374a6ce31a9f93d66e02acd870768c56d7fc4e2c4d4833e878f5c5b01c4f5b18b9e51bf1f771c16a4f3b467c4b50a13ef29a0eeca154e03cd632c19987e2d6b503d523598f3ee827a0aff6b4d8f292a205a7528a5b04c716bae381972fdb8cbf309f4aea3ae8180f031393e2cec648387699b1312308db4303c774cdc4ee5cef22cd2987675f9b95549aa32736f0fe12d3cf8327aee1fee9239718294792101fd20f2add4dc988c6b599dbd26d576720c36dd9585b69bf4db0a3719a59fa4e9dfa4eb17b3d523f78396005903695df73446186bbbca2f9646994f0f585dbfb4686758b69ea6164083c06af307ea36b6bc1da2d6a86f9bd162ae0f83ce72c7222a5c5c6c5f1e7cd29a61216efed19c17c453aa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】周末の青山湖</title>
    <url>/blog/231021/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a1284b2e7d45f6c6d387296a9ba89cf3ada785813932892528120de9d120d564">eef66fd449a307f3d6a4c72bf278b805ba1453df757cd7369619e6c5cf5f11af932a721d941b69a4f91344f6b7612cae382dafd743f232fb0e6cedd431b27383fe394e8d9664288b5c1817e53d64eeb958980dc9019b9f91c8359e6e3f8c4cf7d9c2d4388866d03cb06ab9d939b2c39487edae0eabf5ac350e3d46a75b04228a39a70cb9c537b479379ed027c5ac0a25a7b4a82096a36754aed35160ae9ac51ff67b3f565120f74372fd97bded4d858bc6ca93e409189f7a622ee80da0feab5238b704e778c0138efd5bd2977a1c0cbf4b1e06855c8998e7f161ff2232929eb5cfc708d157dc19e10321fcce6b841430ce8c8d256c32ba9469f8e08b81925878beef8a1c73b8d48b1afb31486a498d58a3ee8257d425d3a74c7406bbd148c0b609943236895f26df8d24129bc1e97d6b3cb24ed3fb570b0c711c5b69d87e6347f700700ff31a44468d46dd52539c9e032c1630f618f9bf15efa95b19c698a916f7ef89ba6984ce1981109ba773bc45d2bcc58ebe9cde88d4a76ca218b022d2ac26add673a400003e320ce9d6b489de8192de033cbf051e41422fbc08cd9358e0e124d6d0485f9617102bcebf949df507cf570aec2ce8c9cfd205995c59b5ab05c0217b024d5c22a6d9ceaaa648a23c734db0547c3751e63fd7d9b07dd10cc2180eb6b760413d6b4fb2e68e913bb545daadedad50627b90dff254a9d4818334410220b182ed4b262c1541e4a21b50bef2b1827bba2000ee9bfcae87942591b19484e2b9a08cb1e9a1b0cd8562a5079993e1d9e4357f571a162587c30f6d87d1c0ad56413a1d3285ca7efd8ac1356bddddc59bcba62a8c4975027a74b351fc7eedfbc391e21b6d6a79164430a34c3d3f3a69ba9da8b682c07448327b0de3a72cf8cbd41ceb58ee6f8e664a1cb2d68a2c54db08a4ee711d68bf5365eafd6ecdb829818c18cfddd6fcec0f96a53de8677d45910b41ff179fd0ea5b69fc287d900369e9445450071ca468906fd13fa24531d9d46ff7665c304085ea31a255fff2b4af131daa56ce90ef8d5dc533afb9fbfd023715334bdb31d5fad84aa32362ce0710014fb5d5b3ea6032f21011af51b7e313cc38b2a1a0ada12543b9f71c85075022a9e14e28f5be67e7879e25637e1d54d44fde26593399f60fc6fe9221c63b44e26a6ce50ac402b3dd52f8ae17b90654fdab0ea195c4a49dea199c5ed22246429ea2b58db349dcf3cb04d91e9df47215d793574a4a1744d3069f5d0cfb2717667b528a8a49a5235a46eb2f8747b26553dfa667676639e4bed2eb5ca796aeeec411e85b88dfd76bf30e030fa791f6a4451a709b7e13d7b22cd211db0b41062dc8bb9af833ac3b92635cf61b02c80f2b87c77f134351c4d939ceee3c4606ae543d0562d84cf5843f1bcfc1dcc7cf326707f574db47ab2a8e9deed45b4ca0f03a1dc58af1e0d571d3b869ffe26146dbee77cbca1eb6c8be429402d535609782f5f6aca5f7b46c1902c4bd8556fb31c01d40ebced832f87dc36cb833d9a7ee1f090dc0707de72d5e9b846992b3b085d86aa1b52cfba2da37849956e4c7477de95197e657033347fca0f069934a1c66e20ed62365fcc98372f4fc42e0c285f2b9209062ca1f3f6384197dd43ac1ccc44bb49bebadbb3aed13f1cfe01c37eba983ff14b8fd63705fb2a1da5b461596c8c667863c0caa20c2907b746588abd4342e194024da132dc77cba86702d527e8f1b09f4e579661565f6540a36731f8bf60cc2a9c19a7efabb280bcf43725f992b48ece78591a687038a16a6083b2fde3f92b9ffa6683fbcdcdc4865568368e7785d30b4f2e1c3e49b912c8eb8b03c13d87f77e539f0cc0e79e0ce4c7c1620c7e720b11f983174c326b2bf84246ac1d25ef0e7179eb03428b26495f6b809cc6bf37ca7f6f5caf643e00acd06b632cfc865a178fb31ccf118c4178a899b74df2e46253f4c1030b543cd5d4025a81e7a8bf17ef719987b70147b828eab9ae2f840a2a115e7b252377d2f9d5010e3b9854168a1aa2a7c2fb00bb87cde705654bd3ea4ad836edd52216139e358620a7c88283e143520020fd7510d663ed11eff2cde1b6dec131d79417ce0661c4f55396c4d56ab7807569ccb5df752e9c88f913c301e2ef2ddeb53fe46324a8c1b3e6750e4b1f3f9168caffc36026c13b94153e269df7f9974869aa39169c473d16c7c2bce0237fb1ea8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】扬州三日游</title>
    <url>/blog/230307/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a917cf7926ab870173201ba86860ac022378b3c98ad12256f5ed82cf30188cd3">eef66fd449a307f3d6a4c72bf278b805bb33580f744fb9686f417136bc6f5056dff47f5f10635b16ff7b96c8e51ef812480de20e57b3ff3f2b16962d2379d3379d6c44d1922f61dbafcda429631b3c8affa3c2526e58b0e184a750d441b8acc1223e2722f209afb1c5c906f0c187cf8a34bba70d0c1ef30441e65a56cbd00429aa9475cb74c33f1a7b21bfcbb306a7489faa537a408c471b88a46694cb1971ca01be766a2ac8a44caa520659e7b2798c64da098f75d1526cc7491dddc2931d050b779b5946efde7a53aea7678e45d063bd6346cbcc3cc05c3fa06c94bfac95924a7c7c788b9f5f20c88ed12779f4ee063bd557ea696b1d3d4942f741578a3e9dd57ec16e9adfd5541f821af7e022c2d9d0658e23f974741847eea0af2e94a69a98a328a30e29a16ae133e6a28ab1826182652c646cca02a830310ffb3d86951e4b94d18b57584c97e66907cfb3d6c92c6b2f8880dc24b669ff5fd1345cde85575313df4a8a63dc0590925a215507407bd601bd3a282d90948cc49a0de3dfc000dfcfc21bdb4256694302991357ceca1b598fba970a8bbf1288bc7eaa6c5293f44ff543e988474296e2bfb77c6372551f394e5b73d3ce423429f91f2c90d417c0d2f1a2be4debc46e6b9166021153e92c438f9b1709f2a7543529336f1187f916ffabae895c050e04c52a6092aa5c50a23a719566a357b1cbc3ed5bda93766c80e9fdc7836261278d1fefe6877c1da90f36b52f91ff5e1e6985c1c4adb2e35a615035105f9652c0c6e40a227fd657f68d16269a537d5958384d6e99bc1f30e7c75b715449d2df772c21d2aaa051c658f39f5effbff31cc2a84ff610a25dfc6f2e6a1ff2efc279a7d493c1f76a6204000b68fe74a90bc006ac906c716b4b031ba33b17dca0cf4b5b929a99d9175c43647f5fff2c250be48cad8e2f9d93fa89b6252e23a6e67175b1c9dc5458d3fe2492ebbfc934a9df0c02c36e88cd54ebda176d127cf1cceeeb2bffbf1edf5b37d502d37f2f56938368d8609ddd6ac0aeba6587b655caca289d1ff50da07a4e6411a33be37a9529be9743a27a6e8cf62dab7acdbdc1b2468898b43c7730133e952e73fc60535911e26fb445ebc2fdfb817ec6186738475612534ebbd03c74a35c8b5bf2b5e45f680a9733457cec0ede600e32fbbf023a27ba1e97e8cc75b54b3717b54309264b8704110a66036c6e98e6bfdbc4087c9e4773e8d8996ee191282b5c09b617540f7abe2092b25ffbfc31902c27d289f7e4703445660af525a2633b4806c040630587c4f391879237976369bb55d031723724d5e72a52812e9aedc14735a0e48aadd18436bf78c8f54824791f1801b7dabd4625d8890d937124327ba665f84def1954ed5ad9f0e5ace15949c8f1ed149be8b7b5c985e1aadc9e3a1e3dbb0960df6245051b366ba0182a4a29ca8da746e018e0d5d06fb2a8ebe090a315057a86ab995500db8914bb5224693aad72892f20ce49a91f2c9b85970f3ec85d257bc81ccaf3ea0dcf2731aa35dfd1745b67186b7b2d18d9fe11879142e70f51bfd88b32815e59a198eda4db5e7cefd0bf9efa66488cbad289a886d9281270e7815fdefbc11bee95c14c341d860730411351dcf669cd693c5c9e7303d9968f1a68671e026c04627a819d5ca73e641f4a35dfc541983ac76499c98004de3e933bafbc9181214c46ea03bf4f72e5a336d67c1c4a856ae5a76e188bc0440cda004566bb2ef2df48223c4b4d87857bcbde4bd78ed037a7b00474b67e234bc8861490628a2a643eb97a433c3e0a7a9b2e6d6ec01057768b60f7c4058994b5b9d6dd394a75af7152745e907f39cff555a2d3eabbf0cb067220724f276d7b948bacfabf5d3630ebec29c80a7cfed7d539f4edf15f47b8128564642c5559d3883ad3236c3b4c9841c63b6b9a495d0a2bec4477d7dda14671a5db882125209d0aea50656559e11f467022312d5f7c456b3b800f059a216b0f567fa28c2cdfbcb3e2dc9625bbc091240a977bdf30684c9ae380471c3a3ee50f45d2e8bec23282eef4238723e97bf0c2a1789945022b5ca30dfe50b94d556761c2567cbaab966622450e523572be1374448d1eb8145fe5c2b956b5cf0af1b5a79ee5715335994ea4fe444e17db7b4cde3f827984051d5ad9fa56b68355719469653a904c22cedf24b6c2dd1a227235c6de7231467fe24fc08717e997f06e6c3a053e520c7ad2d4ee8156c7a05327b2ec7b8a8dc8b34cc97fb67bfe63d9eb544e8692518e6094c8ed444ac73276c3a02acdccbfbd47594adf2b5abc245328aa56147f1e940ffeef2de9df63d8037daba6430394d94e6a6cc9ff80cff64b4f9b79032c47b8c69f32e70f181d7f1008ced57cb4de70d49e93df6b4d1da5d2c6f3bfeed19c0702c094ab947a729eac2d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】逆子十五(2)</title>
    <url>/blog/230602/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1607674b824262b70687a567a8bb3adacca3aa913f4a2a4f6742ff8d90d30366">eef66fd449a307f3d6a4c72bf278b8050e1cf62c328531a7f1c163f402287b78461cda30976b689ed7a25f0daf298f9961956e08aa266afff8684aa2e0eb6f0602f2ee6b99b4e18fd4634565b99d9f54670ebca9c7acc4b1e50aa9d2da04b09e30ece6c6a1787f81cbe46f708ea36ee74341a5e801cbeaf393ff02b8286946d6fb536d0712184775a80c766f34f47eba9a09885c9f36306c04290ca9e713f695da53ac82e751da4aa61d07292bfbc3c1821e4965c0e74deb9e49c2c826140014ebe0f86aed298caa82b40cc90e9fd6e686dd447a7fea39f3ac3ec4cf576d472b8cbe64658a0e844c9fb086bf8eb871b320ec991a49beabd48a0c73b5eb1eb841a5e4d49e36a6c061f15ad96fe4e0b5d91844f9f4e2d3bee7b3440b84d3c0dd75303b0ec17cc823c854a197a89c81817119de20136759384a1c922b3083cd88d0fb67b5bfb4cb91844d16449a143e6a55f708d30aa18e4aef26c7f399451cc856ccd3acd7c3ae7b3a2eedeca00823c73adcd14a1946111403e3787ade9deb2f57e1744a16c9269f68e130d86ec036d082221f4e425f3dd7252f60f8fa7a7d05eeb0b2d94ab2e8927a85ecde5a750b5202d6282d4d9a13f5d3e637f30343faf22512c017c1ba925e8452e807aa79a5321281127537acd29ee04b7fdd7a66b9d5babf3342eb225dd1ebf21d12bc26c10555295836bb01f5a8d1d1f84b41530e2e479af3d17739c6f521e07439144730473a45ab9e5f380353fd2b6b097c80762795bc17d728a750105b78e4dc8e7c5b12c1a86ac29c5a768f22de4cd4082b8cecd11f405498e38b1e267b7acba5ff120623683672f8637c7f32c000d6560fd40fee55c627fba39a14d3001ae0d84ba53dbb650e39f899fab1e73201a1dc041d6f4be6aff5d984ef0b7a720f10e96f65bd7d23014d9ee9f289fa53fb21205176d6a7972b367197b9ae1e3eade9901a82998e254e126866df3041643e8a57bf5aa2466f2a3ef36e9053cb8158e65835fe822ae709b419bf8e28cce3790c485b6fa2c7f6978af8f0209d4c14e81fffb66325cbdf3881287f21ed4311c38fa67bfa8501e5a5d9aa11f7b048378853142cc7bee78fb5156bbba0266fe740029b3412509c69d989853cb4f2cce3ff6c2f961c490e977abce229192f42c271e0b5081ba613198160b12a65586dc75ec79e213f50c094cb73309cb941eeb08c52fb12e1b5bedafb87128ebba6fea653e607ecabfab8a06f9c1f77c2b14ac83c34a1671f920c34f1a03fe4e13c4333898964c222f8df8f674033a29d3101a1bac15c459476a0cdac079f4a8a766703d52af00f89b5e8d734308b59bd0c5f9a20d14a05dc994775d9c2d2bb4cac57c4ce8f837050fb0ce13bb2e10eb5f3fc59b5fd33de20a674f6087a89b6e9db768f66e69e6f85486545af5b241c908976e3f1714213e4120f9d026b4f409e45ab8899465ad548aa82180898a5f83486a32594562fd141ab7f651cabfd25ea07538af4f641e17a5c198dbb4d3bb06f3503a410c9819831a7dbb649db119d219d7a5421830f3e3030a144ee934700b5cba2132e6b5d4bbe6132ab76c8d773d236931a3d5a9bce344b100d51ece51d17989a00f0164ec4d4f7799072c6b02607f19b88aaee93360922fdbe892c1d22eaa61a4e558802dc6adb9cc59f8a31f6f24d6f888ed37fdeca71d032a40a9908813a9244c72dc5e8bd87866aee46f64c4ce9a1beeaeea9cc02bd460675cc5328b554f18281a5b31060d755d8133d8a9c4e37c111627bc64305f3c37ecfdaa38e04ba0f00f9fb8258baa93faee58e415e14be25a2344b46d1c7380becf1907385f6c5d6049fa05b79b9b22982ba30873c196781f351cac3a539231bef542eaa98a8becc68bb7f80b96b9848b73563fcfad5ce573ae862954ac97d809a81d00881b5e0d02af48cf07343ec29fe6c1cff6d2585d9ca955d5d91bf6412e4e755b891cf6cff6e0c1cfe4cb62270133b302b955275ad962cebea13ae195263c285b53607d8a7cae149ea0f531dba50f069f9be20b45f5b4336db91662d733fc1a1129d37585d1818a3563de3ff09469b9713d4d2fe3cdb812fe957bca68ca0b7fdb4bbddaab54dc7131ebfbbdb6fdd14ce59def6e1c7890ee99df42ad19c9ff21682c0a68fc0b665c61b18e30a92465ffa59476faf43381b2863e3f2de091bce0f61f31b9e94add77aaac6d4ebb6bcf65eeae022353db6f3bb3436466ba31cd13d554e5b30fb7f28bcac6bdbe914</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Life】逆子十五(1)</title>
    <url>/blog/230601/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c5c88f9e1868207a686f161f7fdaf6f11277fceba1dc8129a1d6f86113d3b86a">eef66fd449a307f3d6a4c72bf278b805721457e8f5acce43c77b0db1c9cce12351662832c33fa5374f2dc685847a02e10cd032dd9ffa2f6f8ff786d04a0d510be84d241dc539bff5e1832c70ce24c386c688427a892098aa8e27f82be0362804a127564bf17d0159f04602c30ae8c4b085ab9824c8cd4a95bf69e0aa5b9a260486efaa4511a5f5aa559a355be75713e988de49c8e80b92a891d025a30a3c20650e8ec4c6195fac79a2aa3ee521798be0002f9472e90b59c97ce715abdee2397b8e3ff8d768cc12f8cc538e3bd73bcff213d5ab0862c930c06701d388445a2b0951c738e48f62fc2c03b57ac590a74fd889cde281009af0b44198a2a794bdb769c9a4b2ced92a3772c09a027b9e61fcaa6f03b0b2dc24f9a29e1e73d65afd77f66ee5eecd5fb923c3259d00b05a024df6b63c3d878dcf5d3929a898a458872d074c5a0e792407bf9c8a75e2bede6158ab2a72d4c23bf777cabc6d8520c48d759877672f9d8d489fc4cc50b274daf0cb06a9dfe009f40e13a77a4865de348baa7ba7e1909dec0b0a8c386154cd9e5628d9f619983fa64659ae37feccd9e971302f288eb1d8e4610296d8fbddded8afa3e9c3176e5c2b5f8d05685db523e5a9f89e83b3fc7fb48ea1fc46c59f5581b273ed6f01a2141e60f5942c7e2a0286176f13f9b1208c421f75e739c2d629f80b73ac6ef7212b83b41fc86aa8add5f992ec72d413c1d08660c71d989bf11870f17fcb0ffb6f6ceee8f535416aeb4b5423b06ef9096bd57cfcf48b6e0bab9ecc571df10213d250956088b82206fcd33ae6de2b9d171d92e66ff43facfe341b1352db91</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】GDB调试</title>
    <url>/blog/LinuxGDB/</url>
    <content><![CDATA[<h2 id="GDB指令介绍"><a href="#GDB指令介绍" class="headerlink" title="GDB指令介绍"></a>GDB指令介绍</h2><h3 id="启动和退出"><a href="#启动和退出" class="headerlink" title="启动和退出"></a>启动和退出</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gdb &lt;program&gt;</td>
<td align="left">启动gdb并加载要调试的程序</td>
</tr>
<tr>
<td align="left">strat</td>
<td align="left">停放在main函数第一行前面，等待指令</td>
</tr>
<tr>
<td align="left">quit</td>
<td align="left">退出gdb调试器</td>
</tr>
</tbody></table>
<h3 id="执行和运行控制"><a href="#执行和运行控制" class="headerlink" title="执行和运行控制"></a>执行和运行控制</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">run</td>
<td align="left">执行程序</td>
</tr>
<tr>
<td align="left">continue&#x2F;c</td>
<td align="left">继续程序的执行，直到下一个断点或程序结束</td>
</tr>
<tr>
<td align="left">next&#x2F;n</td>
<td align="left">执行当前行并转到下一行</td>
</tr>
<tr>
<td align="left">step&#x2F;s</td>
<td align="left">单步执行并进入函数调用</td>
</tr>
<tr>
<td align="left">finish</td>
<td align="left">执行完当前函数并返回到调用者</td>
</tr>
<tr>
<td align="left">kill</td>
<td align="left">终止正在调试的进程</td>
</tr>
</tbody></table>
<h3 id="断点和调试控制："><a href="#断点和调试控制：" class="headerlink" title="断点和调试控制："></a>断点和调试控制：</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break &lt;line_number&gt;</td>
<td align="left">在指定行设置断点</td>
</tr>
<tr>
<td align="left">break &lt;function_name&gt;</td>
<td align="left">在指定函数设置断点</td>
</tr>
<tr>
<td align="left">break…if…</td>
<td align="left">设置条件断点</td>
</tr>
<tr>
<td align="left">delete &lt;breakpoint_number&gt;</td>
<td align="left">删除指定的断点</td>
</tr>
<tr>
<td align="left">disable &lt;breakpoint_number&gt;</td>
<td align="left">禁用指定的断点</td>
</tr>
<tr>
<td align="left">enable &lt;breakpoint_number&gt;</td>
<td align="left">启用指定的断点</td>
</tr>
<tr>
<td align="left">disable breakpoints</td>
<td align="left">禁用断点</td>
</tr>
<tr>
<td align="left">enable breakpoints</td>
<td align="left">启用断点</td>
</tr>
<tr>
<td align="left">info breakpoints</td>
<td align="left">显示当前设置的断点列表</td>
</tr>
</tbody></table>
<h3 id="变量和表达式："><a href="#变量和表达式：" class="headerlink" title="变量和表达式："></a>变量和表达式：</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">watch &lt;variable&gt;</td>
<td align="left">设置对变量的监视</td>
</tr>
<tr>
<td align="left">info watchpoints</td>
<td align="left">查看当前设置了哪些观察点</td>
</tr>
<tr>
<td align="left">print&#x2F;p &lt;variable&gt;</td>
<td align="left">打印变量的值</td>
</tr>
<tr>
<td align="left">display &lt;variable&gt;</td>
<td align="left">设置永久显示变量的值</td>
</tr>
<tr>
<td align="left">undisplay</td>
<td align="left">取消先前跟踪的变量</td>
</tr>
<tr>
<td align="left">set &lt;variable&gt; &#x3D; &lt;value&gt;</td>
<td align="left">设置变量的值</td>
</tr>
<tr>
<td align="left">whatis &lt;variable&gt;</td>
<td align="left">显示变量的类型</td>
</tr>
<tr>
<td align="left">info locals</td>
<td align="left">显示当前栈帧中的局部变量</td>
</tr>
</tbody></table>
<h3 id="堆栈和函数调用："><a href="#堆栈和函数调用：" class="headerlink" title="堆栈和函数调用："></a>堆栈和函数调用：</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">backtrace&#x2F;bt</td>
<td align="left">显示当前线程的函数调用堆栈</td>
</tr>
<tr>
<td align="left">frame &lt;frame_number&gt;</td>
<td align="left">切换到指定的栈帧</td>
</tr>
<tr>
<td align="left">up</td>
<td align="left">切换到上一个栈帧</td>
</tr>
<tr>
<td align="left">down</td>
<td align="left">切换到下一个栈帧</td>
</tr>
</tbody></table>
<h3 id="线程和并发调试："><a href="#线程和并发调试：" class="headerlink" title="线程和并发调试："></a>线程和并发调试：</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">info threads</td>
<td align="left">显示当前活动线程的列表和各个线程的ID</td>
</tr>
<tr>
<td align="left">thread &lt;thread_id&gt;</td>
<td align="left">切换到指定的线程</td>
</tr>
<tr>
<td align="left">set scheduler-locking on</td>
<td align="left">启用调度程序锁定</td>
</tr>
<tr>
<td align="left">set scheduler-locking off</td>
<td align="left">禁用调度程序锁定</td>
</tr>
</tbody></table>
<h3 id="调试核心转储文件："><a href="#调试核心转储文件：" class="headerlink" title="调试核心转储文件："></a>调试核心转储文件：</h3><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">core &lt;core_file&gt;</td>
<td align="left">加载核心转储文件进行调试</td>
</tr>
</tbody></table>
<h2 id="堆栈调试"><a href="#堆栈调试" class="headerlink" title="堆栈调试"></a>堆栈调试</h2><p>以下面的代码为例，funcA和funcB两个线程都会对sharedVariable进行递增操作，可能引发竞争条件。下面使用gdb进行堆栈调试来定位竞争条件的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="type">int</span> sharedVariable = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        sharedVariable++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sharedVariable++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(funcA)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(funcB)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared variable value: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>启动gdb，并加载程序：<code>$ gdb &lt;program&gt;</code></li>
<li>在gdb中设置断点，在funcB函数中设置断点：<code>(gdb) break funcB</code></li>
<li>运行程序<code>(gdb) run</code></li>
<li>程序停在funB时，可使用<code>info threads</code>查看当前活动线程列表和ID，然后使用&#96;&#96;thread 1&#96;切换到funA</li>
<li>使用<code>backtrace</code>or<code>bt</code>命令查看该线程的堆栈跟踪信息，以了解函数调用路径。</li>
<li>使用<code>frame &lt;frame_number&gt;</code>命令切换到特定的栈帧，并使用list命令查看相关的源代码。</li>
<li>使用<code>print sharedVariable</code>命令查看sharedVariable的值以及其他变量的状态。</li>
</ol>
<blockquote>
<p>实际调试过程比较复杂，基本上就是通过上面指令一顿操作分析，找问题。除此之外还可以结合其他工具，如静态分析工具cppcheck等。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】MISC设备驱动</title>
    <url>/blog/LinuxMiscDevDri/</url>
    <content><![CDATA[<h1 id="MISC设备驱动介绍"><a href="#MISC设备驱动介绍" class="headerlink" title="MISC设备驱动介绍"></a>MISC设备驱动介绍</h1><p>随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。</p>
<p>使用该驱动需要向linux注册一个miscdevice设备，miscdevice定义在文件 include&#x2F;linux&#x2F;miscdevice.h 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 子设备号 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 设备名字 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 设备操作集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">    <span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个 MISC 设备(miscdevice 类型)以后我们需要设置 minor、name 和 fops 这三个成员变量.</p>
<ul>
<li><p>minor： 表示子设备号</p>
<p>MISC 设备的主设备号固定为 10，需要用户指定子设备号，linux中已经预定义了一些 MISC 设备的子设备号，定义在</p>
<p>include&#x2F;linux&#x2F;miscdevice.h 文件中。使用时候可以从预定义的里卖弄挑选，也可以自己定义，只要不冲突即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PSMOUSE_MINOR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MS_BUSMOUSE_MINOR 2 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATIXL_BUSMOUSE_MINOR 3 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="comment">/*#define AMIGAMOUSE_MINOR 4 FIXME OBSOLETE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATARIMOUSE_MINOR 5 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN_MOUSE_MINOR 6 <span class="comment">/* unused */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MISC_DYNAMIC_MINOR 255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>name：此 MISC 设备名字，注册成功以后就会在&#x2F;dev 目录下生成一个名为 name的设备文件。</p>
</li>
<li><p>fops：字符设备的操作集合，也就是呢几个open、read、write等。</p>
</li>
</ul>
<h2 id="注册MISC设备"><a href="#注册MISC设备" class="headerlink" title="注册MISC设备"></a>注册MISC设备</h2><p>当设置好 miscdevice 以后就需要使用 misc_register 函数向系统中注册一个 MISC 设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">misc_register</span><span class="params">(<span class="keyword">struct</span> miscdevice * misc)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>misc</strong>：要注册的 MISC 设备。</li>
<li><strong>返回值：</strong>负数，失败；0，成功。</li>
</ul>
<p>注销MISC时候用 misc_deregister 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">misc_deregister</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>misc</strong>：要注销的 MISC 设备。</li>
<li><strong>返回值：</strong>负数，失败；0，成功</li>
</ul>
<h1 id="传统方法和MISC比较"><a href="#传统方法和MISC比较" class="headerlink" title="传统方法和MISC比较"></a>传统方法和MISC比较</h1><p>以前未使用MISC设备驱动的时候，我们需要调用一堆的函数去创建或删除 cdev、设备等等内容，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">传统的创建设备过程</span><br><span class="line"><span class="built_in">alloc_chrdev_region</span>(); <span class="comment">/* 申请设备号 */</span></span><br><span class="line"><span class="built_in">cdev_init</span>(); <span class="comment">/* 初始化 cdev */</span></span><br><span class="line"><span class="built_in">cdev_add</span>(); <span class="comment">/* 添加 cdev */</span></span><br><span class="line"><span class="built_in">class_create</span>(); <span class="comment">/* 创建类 */</span></span><br><span class="line"><span class="built_in">device_create</span>(); <span class="comment">/* 创建设备 */</span></span><br><span class="line"></span><br><span class="line">传统的注销设备过程</span><br><span class="line"><span class="built_in">cdev_del</span>(); <span class="comment">/* 删除 cdev */</span></span><br><span class="line"><span class="built_in">unregister_chrdev_region</span>(); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"><span class="built_in">device_destroy</span>(); <span class="comment">/* 删除设备 */</span></span><br><span class="line"><span class="built_in">class_destroy</span>(); <span class="comment">/* 删除类 */</span></span><br></pre></td></tr></table></figure>

<p>而现在，我们只需要使用简单一个函数即可完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">	<span class="built_in">misc_deregister</span>();</span><br><span class="line">注销：</span><br><span class="line">    <span class="built_in">misc_deregister</span>();</span><br></pre></td></tr></table></figure>





<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件略</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MISCLED_NAME <span class="string">&quot;miscled&quot;</span> <span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MISCLED_MINOR 144 <span class="comment">/* 子设备号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0 <span class="comment">/* 关 LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1 <span class="comment">/* 开 LED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscled_dev</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> <span class="comment">/* cdev */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line">    <span class="type">int</span> led_gpio; <span class="comment">/* led 所使用的 GPIO 编号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscled_dev</span> <span class="title">miscled</span>;</span> <span class="comment">/* led 设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_gpio_init</span><span class="params">(<span class="keyword">struct</span> device_node *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// dev tree get gpio</span></span><br><span class="line">    leddev.gpio_led = of_get_named_gpio(nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!gpio_is_valid(leddev.gpio_led)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;leddev: Failed to get led-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request gpio</span></span><br><span class="line">    ret = gpio_request(leddev.gpio_led, <span class="string">&quot;LED&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;led: Failed to request led-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set output mode and init </span></span><br><span class="line">    gpio_direction_output(leddev.gpio_led,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscled_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">miscled_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retvalue;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">    </span><br><span class="line">    retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ledstat = databuf[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (ledstat == LEDON) &#123;</span><br><span class="line">        led_switch(LEDON);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ledstat == LEDOFF) &#123;</span><br><span class="line">        led_switch(LEDOFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open  = miscled_open,</span><br><span class="line">    .write = miscled_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ！！！！！请对比传统注册字符设备驱动的方式，MISC简直YYDS</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscled_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;led driver and device was matched!\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = led_gpio_init(pdev-&gt;dev.of_node);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">//使用 MISC 注册设备驱动</span></span><br><span class="line">    ret = misc_register(&amp;led_miscdev);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    printk(<span class="string">&quot;misc device register failed!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> free_gpio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">free_gpio:</span><br><span class="line">    gpio_free(miscled.led_gpio);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ！！！！！请对比传统卸载字符设备驱动的方式，MISC简直YYDS</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscled_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注销设备的时候关闭 LED 灯 */</span></span><br><span class="line">    gpio_set_value(miscled.led_gpio, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 释放 LED */</span></span><br><span class="line">    gpio_free(miscled.led_gpio);</span><br><span class="line">    <span class="comment">/* 注销 misc 设备 */</span></span><br><span class="line">    misc_deregister(&amp;led_miscdev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;baku,led&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, led_of_match);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;rk3568-led&quot;</span>,			<span class="comment">//指定驱动程序的名称，可随意设置。</span></span><br><span class="line">        .of_match_table = led_of_match,	<span class="comment">//指定设备树兼容属性的匹配表，leds_of_match</span></span><br><span class="line">	&#125;,</span><br><span class="line">    .probe = miscled_probe,</span><br><span class="line">    .remove = miscled_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">miscled_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;led_driver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(miscled_init);</span><br><span class="line">module_exit(miscled_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Baku&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】Input子系统</title>
    <url>/blog/LinuxInput/</url>
    <content><![CDATA[<h1 id="Input子系统介绍"><a href="#Input子系统介绍" class="headerlink" title="Input子系统介绍"></a>Input子系统介绍</h1><p>Input子系统是Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等，这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。</p>
<p><img src="/picture/tech/linux%E9%A9%B1%E5%8A%A8Input%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png"></p>
<ul>
<li>中左边就是最底层的具体设备，比如按键、USB 键盘&#x2F;鼠标等</li>
<li>中间部分属于Linux 内核空间，分为驱动层、核心层和事件层</li>
<li>最右边的就是用户空间，所有的输入设备以文件的形式供用户应用程序使用</li>
</ul>
<p>编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层</p>
<ul>
<li>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。</li>
<li>核心层：承上启下，为驱动层提供输入设备 注册和操作接口。通知事件层对输入事件进行处理。</li>
<li>事件层：主要和用户空间进行交互。</li>
</ul>
<h1 id="编写Input驱动"><a href="#编写Input驱动" class="headerlink" title="编写Input驱动"></a>编写Input驱动</h1><p>input 核心层会向 Linux 内核注册一个字符设备，drivers&#x2F;input&#x2F;input.c就是 input 输入子系统的核心层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">input_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">    .devnode = input_devnode,</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">    err = class_register(&amp;input_class);<span class="comment">// 注册input类，会在/sys/class目录下有一个input子系统目录。</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = input_proc_init();</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    	<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个字符设备，主设备号为 INPUT_MAJOR，INPUT_MAJOR，定义在include/uapi/linux/major.h</span></span><br><span class="line">    <span class="comment">// 因此，input 子系统的所有设备主设备号都为 13，使用 input 子系统时候就需要去注册字符设备了，只需要向系统注册 input_device 即可。</span></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>), INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail2: input_proc_exit();</span><br><span class="line">fail1: class_unregister(&amp;input_class);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="input-dev介绍"><a href="#input-dev介绍" class="headerlink" title="input_dev介绍"></a>input_dev介绍</h2><p>使用 input 子系统的时候我们只需要注册一个 input 设备即可，体定义在 include&#x2F;linux&#x2F;input.h 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input_dev 结构体表示 input设备, include/linux/input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// evbit、keybit、relbit 等等都是存放不同事件对应的值。比如我使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span> <span class="comment">// evbit 表示输入事件类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)]; <span class="comment">/* sound 有关的位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="type">bool</span> devres_managed;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evbit 输入事件类型，include/uapi/linux/input.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如本章我们要使用到按键，那么就需要注册 EV_KEY 事件，如果要使用连按功能的话还需要注册 EV_REP 事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux 内核定义了很多按键值，这些按键值定义在 include/uapi/linux/input-event-codes.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line"><span class="comment">// 可以将板上的按键值设置为如上任意一个</span></span><br></pre></td></tr></table></figure>

<h2 id="注册input-dev"><a href="#注册input-dev" class="headerlink" title="注册input_dev"></a>注册input_dev</h2><ol>
<li><p>使用input_allocate_device 函数来申请一个 input_dev。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_dev *<span class="title function_">input_allocate_device</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>参数：无。</p>
<p>返回值：申请到的 input_dev。</p>
</li>
<li><p>初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。</p>
</li>
<li><p>使用input_register_device函数要向 Linux 内核注册 input_dev。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>

<p>dev：要注册的 input_dev 。</p>
<p>返回值：0，input_dev 注册成功；负值，input_dev 注册失败。</p>
</li>
<li><p>注销 input 驱动</p>
<ul>
<li>使用 input_unregister_device 函数来注销掉前面注册的 input_dev。</li>
</ul>
<p>		</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_unregister_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>

<p>dev：要注销的 input_dev 。</p>
<p>返回值：无。</p>
<ul>
<li>后使用 input_free_device 函数释放掉前面申请的 input_dev</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_free_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>

<p>dev：需要释放的 input_dev。</p>
<p>返回值：无。</p>
</li>
</ol>
<h2 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h2><h3 id="上报"><a href="#上报" class="headerlink" title="上报"></a>上报</h3><p>注册好 input_dev 后，还需要继续操作。input 设备都具有输入功能，但具体是什么样的输入值 Linux 内核不知道。我们需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核。不同的事件，其上报事件的 API 函数都不同。</p>
<p>首先是 input_event 函数，此函数用于上报指定的事件以及对应的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> type, </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> code, </span></span><br><span class="line"><span class="params">             <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>dev</strong>：需要上报的 input_dev。</li>
<li><strong>type:</strong> 上报的事件类型，比如 EV_KEY。</li>
<li><strong>code****：</strong>事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</li>
<li><strong>value</strong>：事件值，比如 1 表示按键按下，0 表示按键松开。</li>
<li><strong>返回值：</strong>无。</li>
</ul>
<p>input_event 函数可以上报所有的事件类型和事件值，Linux 内核也提供了其他的针对具体事件的上报函数。如上报按键所使用的input_report_key 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 本质就是 input_event 函数</span></span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他同类型的事件上报函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>

<p><strong>dev</strong>：需要上报同步事件的 input_dev。</p>
<p><strong>返回值：</strong>无。</p>
<h3 id="按键上报Demo"><a href="#按键上报Demo" class="headerlink" title="按键上报Demo"></a>按键上报Demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	  <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1，按下 */</span></span><br><span class="line">		input_sync(inputdev); 				 <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; 								<span class="comment">/* 按键松开 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0，松开 */</span></span><br><span class="line">		input_sync(inputdev); 				 <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="input-event结构体"><a href="#input-event结构体" class="headerlink" title="input_event结构体"></a>input_event结构体</h1><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件，定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件。</p>
<p>input_event 这个结构体非常重要，因为所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过 input_event 来获取到具体的输入事件或相关的值，比如按键值等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">	__u16 type;</span><br><span class="line">	__u16 code;</span><br><span class="line">	__s32 value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// time:  是此事件发生的时间,timeval中tv_sec 和 tv_usec 这两个成员变量都为 long 类型，代表秒和微秒</span></span><br><span class="line"><span class="comment">// type： 事件类型，比如 EV_KEY，表示此次事件为按键事件。</span></span><br><span class="line"><span class="comment">// code： 事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如：KEY_0、KEY_1等等这些按键。</span></span><br><span class="line"><span class="comment">// value：如 EV_KEY 事件中 value 就是按键值，表示按键有没有被按下。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h略</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_NAME <span class="string">&quot;keyinput&quot;</span> <span class="comment">/* 名字 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">idev</span>;</span> <span class="comment">/* 按键对应的 input_dev 指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span> <span class="comment">/* 消抖定时器 */</span></span><br><span class="line">    <span class="type">int</span> gpio_key; <span class="comment">/* 按键对应的 GPIO 编号 */</span></span><br><span class="line">    <span class="type">int</span> irq_key; <span class="comment">/* 按键对应的中断号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>;</span> <span class="comment">/* 按键设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(key.irq_key != irq)</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">    disable_irq_nosync(irq); <span class="comment">/* 禁止按键中断 */</span></span><br><span class="line">    mod_timer(&amp;key.timer, jiffies + msecs_to_jiffies(<span class="number">15</span>));<span class="comment">//消抖</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init key</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">key_gpio_init</span><span class="params">(<span class="keyword">struct</span> device_node *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> irq_flags;</span><br><span class="line">    <span class="comment">// from dev tree get gpio</span></span><br><span class="line">    key.gpio_key = of_get_named_gpio(nd, <span class="string">&quot;key-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!gpio_is_valid(key.gpio_key)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;key：Failed to get key-gpio\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//request gpio</span></span><br><span class="line">    ret = gpio_request(key.gpio_key, <span class="string">&quot;KEY0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;key: Failed to request key-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set  gpio mode</span></span><br><span class="line">    gpio_direction_input(key.gpio_key);</span><br><span class="line">    <span class="comment">// get gpio interrupt number</span></span><br><span class="line">    key.irq_key = irq_of_parse_and_map(nd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!key.irq_key)&#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取设备树中指定的中断触发类型</span></span><br><span class="line">    irq_flags = irq_get_trigger_type(key.irq_key);</span><br><span class="line">    <span class="keyword">if</span> (IRQF_TRIGGER_NONE == irq_flags)</span><br><span class="line">		irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// request interrup </span></span><br><span class="line">    ret = request_irq(key.irq_key, key_interrupt, irq_flags, <span class="string">&quot;Key0_IRQ&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        gpio_free(key.gpio_key);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  定时器服务函数，用于按键消抖</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">/* 读取按键值并上报按键事件 */</span></span><br><span class="line">    val = gpio_get_value(key.gpio_key);</span><br><span class="line">    input_report_key(key.idev, KEY_0, !val);	<span class="comment">//上报</span></span><br><span class="line">    input_sync(key.idev);	<span class="comment">//同步</span></span><br><span class="line">    enable_irq(key.irq_key);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/* 初始化 GPIO */</span></span><br><span class="line">    ret = key_gpio_init(pdev-&gt;dev.of_node);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">    timer_setup(&amp;key.timer, key_timer_function, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请 input_dev */</span></span><br><span class="line">    key.idev = input_allocate_device();</span><br><span class="line">    key.idev-&gt;name = KEYINPUT_NAME;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* 初始化 input_dev，设置产生哪些事件 */</span></span><br><span class="line">    __set_bit(EV_KEY, key.idev-&gt;evbit); <span class="comment">/* 设置产生按键事件 */</span></span><br><span class="line">    __set_bit(EV_REP, key.idev-&gt;evbit); <span class="comment">/* 重复事件，比如按下去不放开，就会一直输出信息 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化 input_dev，设置产生哪些按键 */</span></span><br><span class="line">    __set_bit(KEY_0, key.idev-&gt;keybit);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    key.idev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    key.idev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 表示一个输入设备支持哪些类型的事件</span></span><br><span class="line">    key.idev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    <span class="comment">// 将特定的事件类型和事件码的组合添加到输入设备</span></span><br><span class="line">    <span class="comment">// EV_REP 事件用于处理自动重复按键信号。此自动重复仅适用于已经注册的按键事件码，不用为EV_REP单独设置事件码。</span></span><br><span class="line">    input_set_capability(key.idev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向内核注册输入设备 */</span></span><br><span class="line">    ret = input_register_device(key.idev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;register input device failed!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> free_gpio;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">free_gpio:</span><br><span class="line">    free_irq(key.irq_key,<span class="literal">NULL</span>);</span><br><span class="line">    gpio_free(key.gpio_key);</span><br><span class="line">    del_timer_sync(&amp;key.timer);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    free_irq(key.irq_key,<span class="literal">NULL</span>); <span class="comment">/* 释放中断号 */</span></span><br><span class="line">    gpio_free(key.gpio_key); <span class="comment">/* 释放 GPIO */</span></span><br><span class="line">    del_timer_sync(&amp;key.timer); <span class="comment">/* 删除 timer */</span></span><br><span class="line">    input_unregister_device(key.idev); <span class="comment">/* 释放 input_dev */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">key_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;baku,key&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="comment">/* Sentinel */</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">atk_key_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;rk3568-key&quot;</span>,</span><br><span class="line">        .of_match_table = key_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = key_probe,</span><br><span class="line">    .remove = key_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(atk_key_driver);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Baku&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】Pinctrl和GPIO子系统</title>
    <url>/blog/LinuxPinctrl&amp;Gpio/</url>
    <content><![CDATA[<h1 id="回顾与对比"><a href="#回顾与对比" class="headerlink" title="回顾与对比"></a>回顾与对比</h1><p>使用princtrl子系统之前，实现led驱动都是直接操作寄存器实现的，无论是在驱动直接定义寄存器还是使用设备树定义寄存器。这样无法做到驱动分离分层。</p>
<p><strong>先回顾之前如何实现led驱动的~大概步骤如下：</strong></p>
<ol>
<li>修改设备树，添加节点，设置reg，添加GPIO相关的所有寄存器。</li>
<li>驱动中使用函数获取reg属性的寄存器地址。</li>
<li>初始化寄存器地址，设置io的复用，上下拉等等。</li>
<li>控制IO。</li>
</ol>
<p>概括就是以上四个步骤，除去第一步，其实类似传统裸机配置IO。但是这种配置方式比较繁琐、而且容易出问题(比如 pin 功能冲突)。pinctrl 子系统就是为了解决这个问题而引入的！！</p>
<p>如若使用pinctrl方式的话，步骤大致可分为如下：</p>
<ol>
<li>获取设备树pin信息。</li>
<li>根据获取的pin信息来设置复用。</li>
<li>根据获取的pin信息来设置电气属性，驱动能力。</li>
<li>控制IO</li>
</ol>
<p>基本上就不需要我们手动去操作寄存器进行初始化等等了~</p>
<p>接下来开始介绍Pinctrl子系统。</p>
<hr>
<h1 id="Pinctrl子系统"><a href="#Pinctrl子系统" class="headerlink" title="Pinctrl子系统"></a>Pinctrl子系统</h1><p>Pinctrl (Pin Control) 子系统主要用于配置引脚复用选项，设置引脚的电气属性（如上拉&#x2F;下拉电阻，驱动强度等）。</p>
<h2 id="PIN配置信息"><a href="#PIN配置信息" class="headerlink" title="PIN配置信息"></a>PIN配置信息</h2><p>使用pinctrl之前，我们需要在设备树中设置PIN配置信息。这个不用多说吧，不设置的话，子系统也不知道你要用啥。一般会在设备树里面创建一个节点来描述 PIN 的配置信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3568.dtsi</span></span><br><span class="line">pinctrl: pinctrl &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span>;</span><br><span class="line">    rockchip,grf = &lt;&amp;grf&gt;;</span><br><span class="line">    rockchip,pmu = &lt;&amp;pmugrf&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;	<span class="comment">// pinctrl 下的子节点 reg 第一位加第二位是起始地址</span></span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;		<span class="comment">// 第三位加第四位为长度</span></span></span><br><span class="line">    ranges;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    gpio0: gpio@fdd60000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        clocks = &lt;&amp;pmucru PCLK_GPIO0&gt;, &lt;&amp;pmucru DBCLK_GPIO0&gt;;gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">        gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    省略...	<span class="comment">// 此处省略 gpio1~gpio4，说明有五组 GPIO</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处并不完整，其他的配置在rk3568-pinctrl.dtsi中追加~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3568-pinctrl.dtsi</span></span><br><span class="line"><span class="comment">// 此文件里面包含了所有外设的gpio配置，此处仅以CAN做分析</span></span><br><span class="line">can0 &#123;</span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		can0m0_pins: can0m0-pins &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* can0_rxm0 */</span></span><br><span class="line">				&lt;<span class="number">0</span> RK_PB4 <span class="number">2</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* can0_txm0 */</span></span><br><span class="line">				&lt;<span class="number">0</span> RK_PB3 <span class="number">2</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		can0m1_pins: can0m1-pins &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* can0_rxm1 */</span></span><br><span class="line">				&lt;<span class="number">2</span> RK_PA2 <span class="number">4</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* can0_txm1 */</span></span><br><span class="line">				&lt;<span class="number">2</span> RK_PA1 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>此处定义了两组引脚配置，<code>can0m0_pins</code>和<code>can0m1_pins</code>。也就是复用~</p>
<p>在<code>rockchip,pins</code>中<code>&lt;0 RK_PB4 2 &amp;pcfg_pull_none&gt;,</code>的第一个<code>0</code>代表引脚位于设备的GPIO bank 0，<code>RK_PB4</code>: 指定了具体的引脚号，<code>2</code>: 应该是代表复用号，接到同一个can控制器。最后一个参数则是上下拉。</p>
<h3 id="追加涉及的小知识点："><a href="#追加涉及的小知识点：" class="headerlink" title="追加涉及的小知识点："></a>追加涉及的小知识点：</h3><ul>
<li>设备树通常包含了一系列的节点，每个节点代表一个硬件设备或资源，这些节点之间通过父子关系或者引用关系来描述硬件设备的组织结构和连接关系。</li>
<li>pinctrl（引脚控制）是设备树中的一种特殊节点，它用来描述硬件引脚的功能和配置。在设备树中，pinctrl节点包含了一组引脚状态的定义，每个状态描述了一种引脚的功能和属性，比如将某个引脚配置为GPIO、设置引脚的驱动强度、上拉&#x2F;下拉等。</li>
<li>在Linux中，设备树（Device Tree）的设计允许硬件描述信息（如设备节点、pinctrl节点等）以分散的方式组织在多个文件中。目的如下：<ul>
<li>模块化和可维护性：每个硬件模块可以有独立的设备树文件，开发人员可以专注于编辑与自己模块相关的设备树文件，而不会影响其他模块。</li>
<li>可重用性：一个SOC可能在不同的硬件平台上使用相同的设备节点和pinctrl配置。通过将这些信息分开存放，可以方便地重用和共享，而不必为每个硬件平台都编写完整的设备树。</li>
<li>动态加载和覆盖：分散的设备树允许系统在运行时动态加载和覆盖设备树的部分。例如，某些硬件可能是可插拔的，或者需要根据外部设备的连接状态动态调整引脚配置。通过将硬件描述信息分开存放，系统可以在运行时加载新的设备树片段，或者替换现有的设备树片段，以适应不同的硬件配置或用户需求。</li>
</ul>
</li>
</ul>
<h3 id="PIN-BANK"><a href="#PIN-BANK" class="headerlink" title="PIN_BANK"></a>PIN_BANK</h3><p>PIN_BANK 就是 PIN 所属的组，RK3568 一共有 5 组 PIN：GPIO0~GPIO4。</p>
<h3 id="PIN-BANK-IDX"><a href="#PIN-BANK-IDX" class="headerlink" title="PIN_BANK_IDX"></a>PIN_BANK_IDX</h3><p>PIN_BANK_IDX 是组内的编号，以 GPIO0 组为例，一共有 A0<del>A7、B0</del>B7、C0<del>C7、D0</del>D7, 这 32 个 PIN。可以在<code>include/dt-bindings/pinctrl/rockchip.h</code>中查看具体定义。</p>
<h3 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a>MUX</h3><p>MUX 就是设置 PIN 的复用功能，一个 PIN 最多有 16 个复用功能，<code>include/dt-</code></p>
<p><code>bindings/pinctrl/rockchip.h</code>中可以查看具体定义。</p>
<p>查看 RK3568 数据手册便可知道某个GPIO支持那种复用情况，例如GPIO_C0:</p>
<p><img src="/picture/tech/linux%E9%A9%B1%E5%8A%A8pinctrl/pinctrl1.jpg"></p>
<p>如上，GPIO_C0有四个复用！！需要设置哪个就设置那个，可参考上面Can的一组设置2，另一组设置4。</p>
<h3 id="phandle"><a href="#phandle" class="headerlink" title="phandle"></a><strong>phandle</strong></h3><p>描述一些引脚的通用配置信息，在<code>scripts/dtc/include-prefixes/arm/rockchip-pinconf.dtsi</code> 中查看。主要是配置上下拉的。</p>
<h2 id="设备树中添加pinctrl节点模板"><a href="#设备树中添加pinctrl节点模板" class="headerlink" title="设备树中添加pinctrl节点模板"></a>设备树中添加pinctrl节点模板</h2><p>比如，我需要在节点下加一个i2c2节点，然后在uart2中创建一个i2c2_pins节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;pinctrl &#123;</span><br><span class="line">    i2c2_pins: i2c2-pins &#123;</span><br><span class="line">        /omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">        rockchip,pins =</span><br><span class="line">            &lt;<span class="number">3</span> RK_PB0 <span class="number">2</span> &amp;pcfg_pull_up&gt;,</span><br><span class="line">            &lt;<span class="number">3</span> RK_PB1 <span class="number">2</span> &amp;pcfg_pull_up&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>/omit-if-no-ref/</code> 用于优化设备树的大小，如果没有其他地方引用到这个节点，那么在编译生成最终的设备树二进制（DTB）文件时，这个节点可以被省略不包含在内。</p>
<p><code>i2c2_pins: i2c2-pins</code>左标签，右节点~</p>
<h2 id="使用Pinctrl子系统"><a href="#使用Pinctrl子系统" class="headerlink" title="使用Pinctrl子系统"></a>使用Pinctrl子系统</h2><p>刚刚上面设置了iic的pinctrl节点，现在来使用它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用给默认状态，即pinctrl节点设置的。如果想配置多种模式，修改修改pinctrl。然后在这里在加入一个模式，在添加一个pinctrl-1，指定引脚控制配置</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;	</span><br><span class="line">    <span class="comment">// 指定设备在其默认状态下使用的引脚控制配置</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c2_pins&gt;;	</span><br><span class="line">    clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line">    <span class="comment">//链接到一个iic传感器设备</span></span><br><span class="line">    sensor@<span class="number">68</span> &#123;	</span><br><span class="line">        compatible = <span class="string">&quot;some,sensor&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x68</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="关于RK3568的Pinctrl"><a href="#关于RK3568的Pinctrl" class="headerlink" title="关于RK3568的Pinctrl"></a>关于RK3568的Pinctrl</h2><p>正常来说，当你想要将一个引脚（PIN）用作通用输入输出（GPIO）功能时，你通常需要在设备树（Device Tree）中为这个引脚创建一个对应的<code>pinctrl</code>（PIN control）节点。这个<code>pinctrl</code>节点用来配置引脚的属性，比如电气特性（上拉、下拉电阻等），并且你需要在这个节点中指定将这个引脚复用为GPIO功能。</p>
<p>但是</p>
<p>对于RK3568这款Rockchip的处理器来说，情况有所不同。当你将一个引脚用作GPIO功能时，你不需要在设备树中为这个引脚创建一个对应的<code>pinctrl</code>节点。也就是说，这款处理器允许你直接使用引脚作为GPIO，而不需要进行额外的设备树配置。</p>
<p>这样使得设备树非常的简洁，不需要过多配置。</p>
<hr>
<h1 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h1><p>GPIO (General-Purpose Input&#x2F;Output) 子系统主要用于IO控制，比如控制 LED 灯，读取按钮状态，控制电机，与其他简单外设通信等。</p>
<h2 id="设备树中的GPIO子系统信息"><a href="#设备树中的GPIO子系统信息" class="headerlink" title="设备树中的GPIO子系统信息"></a>设备树中的GPIO子系统信息</h2><p><code>rk3568.dtsi</code>中可看到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio0: gpio@fdd60000 &#123;</span><br><span class="line">    <span class="comment">//告诉内核这个设备与“rockchip,gpio-bank”兼容。内核将使用这个信息来选择正确的驱动程序。</span></span><br><span class="line">    compatible = <span class="string">&quot;rockchip,gpio-bank&quot;</span>;	</span><br><span class="line">    <span class="comment">//定义了设备的寄存器地址和长度</span></span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    <span class="comment">//定义了设备的中断号和类型</span></span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    <span class="comment">//这定义了GPIO控制器需要的时钟源，引用了pmucru节点下的PCLK_GPIO0和DBCLK_GPIO0两个时钟源</span></span><br><span class="line">    clocks = &lt;&amp;pmucru PCLK_GPIO0&gt;, &lt;&amp;pmucru DBCLK_GPIO0&gt;;</span><br><span class="line">	<span class="comment">//表明这个节点是一个GPIO控制器。</span></span><br><span class="line">    gpio-controller;</span><br><span class="line">    <span class="comment">//配置GPIO引脚时需要两个参数。（引脚号，引脚功能）</span></span><br><span class="line">    <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="comment">//定义了GPIO号码的范围</span></span><br><span class="line">    gpio-ranges = &lt;&amp;pinctrl <span class="number">0</span> <span class="number">0</span> <span class="number">32</span>&gt;;</span><br><span class="line">    <span class="comment">//表明这个节点也是一个中断控制器</span></span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="comment">//这表明配置中断时需要两个参数。（中断号，中断类型）</span></span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>绑定文档<code>Documentation/devicetree/bindings/gpio/gpio.txt</code> 详细描述了 gpio 控制器节点各个属性信息。</p>
<h2 id="使用GPIO控制器。"><a href="#使用GPIO控制器。" class="headerlink" title="使用GPIO控制器。"></a>使用GPIO控制器。</h2><p>接下来就是使用gpio控制器。</p>
<ul>
<li><p>设备节点配置GPIO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;	</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c0_default_pins&gt;;	<span class="comment">//指定控制组</span></span><br><span class="line">    clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line"></span><br><span class="line">    sensor@<span class="number">1</span>a &#123;</span><br><span class="line">        compatible = <span class="string">&quot;example,sensor&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x1a</span>&gt;;</span><br><span class="line">        <span class="comment">//此用于配置设备的复位引脚</span></span><br><span class="line">        reset-gpios = &lt;&amp;gpio0 <span class="number">23</span> GPIO_ACTIVE_LOW&gt;;  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设备节点中断配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">    sensor@<span class="number">1</span>a &#123;</span><br><span class="line">        compatible = <span class="string">&quot;example,sensor&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x1a</span>&gt;;</span><br><span class="line">        <span class="comment">//用于指定中断控制器</span></span><br><span class="line">        interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">        <span class="comment">//此属性用于配置设备的中断引脚</span></span><br><span class="line">        interrupts = &lt;<span class="number">16</span> IRQ_TYPE_EDGE_FALLING&gt;;  <span class="comment">// 示例中断配置</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GPIO子系统API函数介绍"><a href="#GPIO子系统API函数介绍" class="headerlink" title="GPIO子系统API函数介绍"></a>GPIO子系统API函数介绍</h2><ul>
<li><p><strong>gpio_request</strong> 函数</p>
<p>申请一个 GPIO 管脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>gpio：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信息，此函数会返回这个 GPIO 的标号。</p>
</li>
<li><p>label：给 gpio 设置个名字。</p>
</li>
<li><p>返回值：0，申请成功；其他值，申请失败。</p>
</li>
</ul>
</li>
<li><p><strong>gpio_free</strong> 函数</p>
<p>释放GPIO引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>gpio：要释放的 gpio 标号。</li>
</ul>
</li>
<li><p><strong>gpio_direction_input</strong> 函数</p>
<p>设置某个 GPIO 为输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>gpio：要设置为输入的 GPIO 标号。</p>
</li>
<li><p>返回值：0，设置成功；负值，设置失败。</p>
</li>
</ul>
</li>
<li><p><strong>gpio_direction_output</strong> 函数</p>
<p>于设置某个 GPIO 为输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>gpio：要设置为输出的 GPIO 标号</p>
</li>
<li><p>value：GPIO默认值。</p>
</li>
<li><p>返回值：0，设置成功；负值，设置失败。</p>
</li>
</ul>
</li>
<li><p><strong>gpio_get_value</strong>函数</p>
<p>获取某个 GPIO 的值(0 或 1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>gpio：要获取的 GPIO 标号。</p>
</li>
<li><p>返回值：0，设置成功；负值，设置失败。</p>
</li>
</ul>
</li>
<li><p><strong>gpio_set_value</strong>函数</p>
<p>设置某个 GPIO 的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>gpio：要设置的 GPIO 标号。</li>
<li>value：要设置的值</li>
</ul>
</li>
</ul>
<h2 id="GPIO相关OF函数介绍"><a href="#GPIO相关OF函数介绍" class="headerlink" title="GPIO相关OF函数介绍"></a>GPIO相关OF函数介绍</h2><ul>
<li><p><strong>of_gpio_named_count</strong> <strong>函数</strong></p>
<p>获取设备树某个属性里面定义了几个 GPIO 信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_named_count</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>np</strong>：设备节点。</p>
</li>
<li><p><strong>propname</strong>：要统计的 GPIO 属性。</p>
</li>
<li><p><strong>返回值：</strong>正值，统计到的 GPIO 数量；负值，失败。</p>
</li>
</ul>
</li>
<li><p><strong>of_gpio_count</strong> <strong>函数</strong></p>
<p>和上面的函数一样，不同是后者统计<code>“gpios”</code>属性，前者统计任意属性的 GPIO 信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_count</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>np</strong>：设备节点。</p>
</li>
<li><p><strong>返回值：</strong>正值，统计到的 GPIO 数量；负值，失败。</p>
</li>
</ul>
</li>
<li><p><strong>of_get_named_gpio</strong> <strong>函数</strong></p>
<p>获取 GPIO 编号,此函数会将设备树中类似&lt;&amp;gpio4 RK_PA1 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的GPIO 编号，驱动中经常使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio</span><span class="params">(  <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> 						<span class="type">const</span> <span class="type">char</span> *propname, </span></span><br><span class="line"><span class="params">						<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>np</strong>：设备节点。</p>
</li>
<li><p><strong>propname</strong>：包含要获取 GPIO 信息的属性名。</p>
</li>
<li><p><strong>返回值：</strong>正值，统计到的 GPIO 数量；负值，失败。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><p>以RK3568开发板为例。创建LED节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpioled &#123; </span><br><span class="line">    compatible = <span class="string">&quot;myhled,led&quot;</span>; </span><br><span class="line">    led-gpio = &lt;&amp;gpio0 RK_PC0 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建后，还需要在内核中有一个匹配 <code>compatible</code> 字符串 “myhled,led” 的设备驱动。驱动将解析设备树中的信息，并正确地初始化和控制 LED。</p>
<p>此处的话，需要涉及platform device和driver，本章还未介绍，所以Demo鸽了~~~hhhh</p>
<p>如果不使用platform，可以采用普通方法，访问gpioled节点，然后规规矩矩的初始化IO，使用IO，涉及的api和of函数都已经介绍过了。具体例子就不写了嘿嘿。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】Platform结合设备树</title>
    <url>/blog/LinuxPlatform&amp;DevTrees/</url>
    <content><![CDATA[<p>上章讲解的是传统的platform方法，即不使用设备树。新版本的linux都支持设备树，所以再设备树下编写platform也十分重要。</p>
<p>本章讲解的是传统的platfoem方法，即不使用设备树！</p>
<h1 id="设备树下的platform驱动介绍"><a href="#设备树下的platform驱动介绍" class="headerlink" title="设备树下的platform驱动介绍"></a>设备树下的platform驱动介绍</h1><p>正常我们实现platform需要编写并注册 platform_device 和 platform_driver，分别代表设备和驱动。在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可！</p>
<h2 id="创建设备pinctrl节点"><a href="#创建设备pinctrl节点" class="headerlink" title="创建设备pinctrl节点"></a>创建设备pinctrl节点</h2><p>在 platform 驱动框架下必须使用 pinctrl 来配置引脚复用功能，以配置RK3568的LED为例子，编写 LED0 引脚的 pinctrl 配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3568-pinctrl.dtsi</span></span><br><span class="line">led-gpios&#123;</span><br><span class="line">    /omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">    led_gpio: led-pin &#123;</span><br><span class="line">        rockchip,pins = &lt;<span class="number">0</span> RK_PC0 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备树中创建设备节点"><a href="#设备树中创建设备节点" class="headerlink" title="设备树中创建设备节点"></a>设备树中创建设备节点</h2><p>在设备树中创建设备节点来描述设备信息，重点是要设置好 compatible 属性的值，因为 platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！切记！！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpioled &#123;</span><br><span class="line">    compatible = <span class="string">&quot;baku,led&quot;</span>;	<span class="comment">// 兼容信息，用于匹配</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;led_gpio&gt;;	<span class="comment">// pinctrl节点</span></span><br><span class="line">    led-gpio = &lt;&amp;gpio0 RK_PC0 GPIO_ACTIVE_HIGH&gt;;	<span class="comment">// io的引脚、上下拉、</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="编写platform驱动时候检查兼容属性"><a href="#编写platform驱动时候检查兼容属性" class="headerlink" title="编写platform驱动时候检查兼容属性"></a>编写platform驱动时候检查兼容属性</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_match</span>[] =</span> &#123;	</span><br><span class="line">    <span class="comment">//一个驱动可以和多个设备匹配</span></span><br><span class="line">    <span class="comment">//驱动中的 compatible 属性和设备中的 compatible 属性相匹配</span></span><br><span class="line">    &#123; .compatible = <span class="string">&quot;baku,led&quot;</span> &#125;, </span><br><span class="line">    <span class="comment">//在编写 of_device_id 的时候最后一个元素一定要为空！</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明一下 led_of_match 这个设备匹配表</span></span><br><span class="line">MODULE_DEVICE_TABLE(of, led_of_match);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;rk3568-led&quot;</span>,			<span class="comment">//指定驱动程序的名称，可随意设置。</span></span><br><span class="line">        .of_match_table = led_of_match,	<span class="comment">//指定设备树兼容属性的匹配表，leds_of_match</span></span><br><span class="line">	&#125;,</span><br><span class="line">    .probe = led_probe,</span><br><span class="line">    .remove = led_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="检查引脚复用"><a href="#检查引脚复用" class="headerlink" title="检查引脚复用"></a>检查引脚复用</h2><p>打个比方，我们使用GPIO0_C0，则再rk3568-pinctrl.dtsi中搜，<code>RK_PC0 1</code>，看一下没有没此引脚有没有被用到其他地方~如果被其他地方服用了，我们则需要换引脚，或禁用以前的复用，否则会导致有一个因为申请不到 GPIO 而导致驱动无法工作。同时也要检查设备树中，是否有其他设备也使用到了这个 GPIO。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h略</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_CNT 1 <span class="comment">/* 设备号长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_NAME <span class="string">&quot;dtsplatled&quot;</span> <span class="comment">/* 设备名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> <span class="comment">/* cdev */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span> <span class="comment">/* LED 设备节点 */</span></span><br><span class="line">    <span class="type">int</span> gpio_led; <span class="comment">/* LED 灯 GPIO 标号 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span> <span class="title">leddev</span>;</span> <span class="comment">/* led 设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sta == LEDON )</span><br><span class="line">		gpio_set_value(leddev.gpio_led, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDOFF)</span><br><span class="line">		gpio_set_value(leddev.gpio_led, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_gpio_init</span><span class="params">(<span class="keyword">struct</span> device_node *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// dev tree get gpio</span></span><br><span class="line">    leddev.gpio_led = of_get_named_gpio(nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!gpio_is_valid(leddev.gpio_led)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;leddev: Failed to get led-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request gpio</span></span><br><span class="line">    ret = gpio_request(leddev.gpio_led, <span class="string">&quot;LED&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;led: Failed to request led-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set output mode and init </span></span><br><span class="line">    gpio_direction_output(leddev.gpio_led,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static int led_open(struct inode *inode, struct file *filp)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retvalue;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">    </span><br><span class="line">    retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ledstat = databuf[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (ledstat == LEDON) &#123;</span><br><span class="line">        led_switch(LEDON);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ledstat == LEDOFF) &#123;</span><br><span class="line">        led_switch(LEDOFF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open  = <span class="literal">NULL</span>,</span><br><span class="line">    .write = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(<span class="string">&quot;led driver and device was matched!\r\n&quot;</span>);</span><br><span class="line">	<span class="comment">// init gpio</span></span><br><span class="line">    ret = led_gpio_init(pdev-&gt;dev.of_node);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// set dev number</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;leddev.devid, <span class="number">0</span>, LEDDEV_CNT, LEDDEV_NAME);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s Couldn&#x27;t alloc_chrdev_region, ret=%d\r\n&quot;</span>, LEDDEV_NAME, ret);</span><br><span class="line">        <span class="keyword">goto</span> free_gpio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init cdev 关联字符设备操作相关的数据和操作函数</span></span><br><span class="line">    leddev.cdev.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line">    <span class="comment">// add cdev 创建并绑定设备号</span></span><br><span class="line">    ret = cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> del_unregister;</span><br><span class="line">    <span class="comment">// create class 创建设备类</span></span><br><span class="line">    leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> del_cdev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create dev 为设备自动创建设备节点/dev/dtsplatled</span></span><br><span class="line">    leddev.device = device_create(leddev.class, <span class="literal">NULL</span>, leddev.devid, <span class="literal">NULL</span>, LEDDEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> destroy_class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">destroy_class:</span><br><span class="line">    class_destroy(leddev.class);</span><br><span class="line">del_cdev:</span><br><span class="line">	cdev_del(&amp;leddev.cdev);</span><br><span class="line">del_unregister:</span><br><span class="line">	unregister_chrdev_region(leddev.devid, LEDDEV_CNT);</span><br><span class="line">free_gpio:</span><br><span class="line">	gpio_free(leddev.gpio_led);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    gpio_set_value(leddev.gpio_led, <span class="number">0</span>);<span class="comment">/* 卸载驱动的时候关闭 LED */</span></span><br><span class="line">    gpio_free(leddev.gpio_led); <span class="comment">/* 注销 GPIO */</span></span><br><span class="line">    cdev_del(&amp;leddev.cdev); <span class="comment">/* 删除 cdev */</span></span><br><span class="line">    unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line">    device_destroy(leddev.class, leddev.devid); <span class="comment">/* 注销设备 */</span></span><br><span class="line">    class_destroy(leddev.class); <span class="comment">/* 注销类 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;baku,led&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, led_of_match);</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;rk3568-led&quot;</span>,			<span class="comment">//指定驱动程序的名称，可随意设置。</span></span><br><span class="line">        .of_match_table = led_of_match,	<span class="comment">//指定设备树兼容属性的匹配表，leds_of_match</span></span><br><span class="line">	&#125;,</span><br><span class="line">    .probe = led_probe,</span><br><span class="line">    .remove = led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">leddriver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">leddriver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;led_driver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Baku&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结过程"><a href="#总结过程" class="headerlink" title="总结过程"></a>总结过程</h1><ol>
<li><p>修改设备树文件</p>
<ul>
<li>在设备树中为LED设备添加节点，指定硬件相关信息，如GPIO引脚号等。</li>
<li>定义并引用pinctrl设置，用来配置GPIO引脚的行为（如输出、上拉、下拉等）。</li>
</ul>
</li>
<li><p>修改设备树pinctrl节点</p>
<ul>
<li>创建pinctrl子节点，定义不同的引脚状态，例如默认状态和睡眠状态。</li>
<li>将这些pinctrl状态关联到LED设备的节点上。</li>
</ul>
</li>
<li><p>定义Platform设备结构体</p>
<ul>
<li>在驱动程序中定义一个<code>struct platform_driver</code>类型的变量，填充其成员，包括设备名、匹配表、探测函数、移除函数等。</li>
</ul>
</li>
<li><p>实现probe函数</p>
<ul>
<li>获取设备树节点，获取各种信息。</li>
<li>进行GPIO初始化、请求GPIO资源啊，设置GPIO为输出模式，并初始化LED状态</li>
</ul>
</li>
<li><p>实现remove函数</p>
<ul>
<li>释放之前请求的资源（要按顺序）。</li>
</ul>
</li>
<li><p>编写文件操作函数（file_operations结构）</p>
<ul>
<li>实现<code>open</code>、<code>write</code>等操作函数</li>
</ul>
</li>
<li><p>初始化Platform驱动</p>
<ul>
<li>驱动模块的初始化函数中，使用<code>platform_driver_register()</code>函数注册Platform驱动</li>
</ul>
</li>
<li><p>退出Platform驱动</p>
<p>​	驱动模块的退出函数中，使用<code>platform_driver_unregister()</code>函数注销Platform驱动。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】Platform设备驱动</title>
    <url>/blog/LinuxPlatformDevDri/</url>
    <content><![CDATA[<p>本章讲解的是传统的platfoem方法，即不使用设备树！</p>
<h1 id="linux驱动层的分离分层"><a href="#linux驱动层的分离分层" class="headerlink" title="linux驱动层的分离分层"></a>linux驱动层的分离分层</h1><p>开始具体讲解platform之前，需要先说说驱动的分离分层，帮助更好理解paltform。</p>
<h2 id="分隔与分离"><a href="#分隔与分离" class="headerlink" title="分隔与分离"></a>分隔与分离</h2><p>假如现在有三个SOC平台A、B、C，如何如同裸机开发，则会出现下图情况，一个平台一个驱动，然后还另需实现相同的MPU6050驱动。</p>
<p><img src="/picture/tech/linux%E9%A9%B1%E5%8A%A8platform/platform1.jpg"></p>
<p>这种情况是不能发生在linux内核中的，必须做到代码可复用。最好的做法就是每个平台的 I2C 控制器都提供一个统一的接口(也叫做主机驱动)，每个设备的话也只提供一个驱动程序(设备驱动)，每个设备通过统一的I2C接口驱动来访问，这样就可以大大简化驱动文件。<br>简化后如下图</p>
<p><img src="/picture/tech/linux%E9%A9%B1%E5%8A%A8platform/platform2.jpg"></p>
<p>开发中，SOC的I2C驱动由厂家编写，设备驱动由设备器件的厂家编写好了（大多数），我们只要提供设备信息即可，比如让 I2C 设备接到哪个 I2C 接口上，I2C速度多少等等。把设备信息从设备驱动中剥离开来，驱动使用标准方法从设备树中获取到设备信息，然后始化设备。<br>驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。</p>
<p>再优化一下图就变成了platform的总线驱动设备模式了，如下：</p>
<p><img src="/picture/tech/linux%E9%A9%B1%E5%8A%A8platform/platform3.jpg"></p>
<p>所有的SOC驱动都可以通过总线方式使用。当开发需要注册驱动时候，会再左侧查找是否有匹配的设备，有的话就连接起来！就是通过设备树中的<code>compatible = &quot;myhled,led&quot;;</code>来匹配设备。</p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>网络有7层模型，Linux驱动也类似。目的都是一致的，为了在不同的层处理不同的内容。<br>此处以input(输入子系统)为例，简单介绍一下驱动的分层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">设备驱动层 -&gt; 核心层 -&gt; 应用层 -&gt; 其他</span><br><span class="line">获取输入设备的原始值 --(输入事件)--&gt; input核心层 --(系统调用)--&gt; 应用层</span><br></pre></td></tr></table></figure>

<p>我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的，我们不用管。可以看出借助分层模型可以极大的简化我们的驱动编写，对于驱动编写来说非常的友好。</p>
<hr>
<h1 id="platform平台驱动模型介绍"><a href="#platform平台驱动模型介绍" class="headerlink" title="platform平台驱动模型介绍"></a>platform平台驱动模型介绍</h1><p>为了实现以上说到的分离分层，Linux 提出了 platform 这个虚拟总线，相应的就有 platform_driver 和 platform_device。</p>
<h2 id="platform总线"><a href="#platform总线" class="headerlink" title="platform总线"></a>platform总线</h2><p>Linux系统内核使用bus_type结构体表示总线，此结构体定义在文件include&#x2F;linux&#x2F;device.h。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus</span> _<span class="title">type</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> <span class="number">1</span> *name; </span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *dev_name; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span> </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span> </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span> </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span> </span><br><span class="line">  <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);  <span class="comment">//用于匹配驱动和设备驱动！！</span></span><br><span class="line">  <span class="type">int</span> (*uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env); </span><br><span class="line">  <span class="type">int</span> (*probe)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*remove)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*online)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*offline)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state); </span><br><span class="line">  <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*num_vf)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">int</span> (*dma_configure)(<span class="keyword">struct</span> device *dev); </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span> </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span> </span><br><span class="line">  <span class="type">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中match函数是完成设备和驱动之间匹配的，每一条总线都必须实现此函数。此函数有两个参数“dev”和“drv”，<br>platform则是bus_type的一个实例。定义在文件 drivers&#x2F;base&#x2F;platform.c。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123; </span><br><span class="line">  .name = <span class="string">&quot;platform&quot;</span>, </span><br><span class="line">  .dev_groups = platform_dev_groups, </span><br><span class="line">  .match = platform_match, </span><br><span class="line">  .uevent = platform_uevent, </span><br><span class="line">  .dma_configure = platform_dma_configure, </span><br><span class="line">  .pm = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 platform_match 就是匹配函数。如果对驱动和设备是如何匹配的感兴趣可以在，drivers&#x2F;base&#x2F;platform.c 中查看此函数。<br>简单来说就是以下几步，是顺序执行，如果直接匹配不对，就是匹配失败了~</p>
<ol>
<li>设备树匹配(使用of函数)。</li>
<li>ACPI匹配。</li>
<li>id_table匹配。</li>
<li>直接(strcmp)匹配。</li>
</ol>
<h2 id="platform驱动"><a href="#platform驱动" class="headerlink" title="platform驱动"></a>platform驱动</h2><p>platform_driver结构体表示platform驱动，这玩意定义在文件include&#x2F;linux&#x2F;platform_device.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span> </span><br><span class="line">  <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">  <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">  <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">  <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span> </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span> </span><br><span class="line">  <span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处的<code>probe</code>、<code>remove</code>函数是驱动和设备匹配和释放后会执行的函数。</p>
<p>id_table表，这是上面提到的匹配方式。这个表是个数组，类型为platform_device_id，里面存储设备名字和驱动数据。</p>
<p>platform_driver结构体中包含了device_driver结构体，这个结构体供了基本的驱动框架，然后又添加了很多其他特有变量，属于面向对象的方式~</p>
<p>device_driver中有一个元素是of_device_id。这是采用设备树匹配使用用的匹配表。</p>
<p>综上，编写platform驱动首先定义一个 platform_driver 结构体变量，然后实现结构体中的各个成员变量。重点是实现匹配方法以及 probe 函数。当驱动和设备匹配成功以后 probe函数就会执行，具体的驱动程序在 probe 函数里面编写，比如字符设备驱动等等</p>
<p>当定义并初始化完platform_driver后，便可在驱动入口函数中向linux注册一个platform驱动。</p>
<p>使用的注册函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_driver_register</span> <span class="params">(<span class="keyword">struct</span> platform_driver *driver)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>driver：要注册的 platform 驱动。</li>
<li>返回值：负数，失败；0，成功。</li>
</ul>
<p>卸载函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_driver_unregister</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>drv：要卸载的 platform 驱动。</li>
<li>返回值：无。</li>
</ul>
<h3 id="platform驱动框架"><a href="#platform驱动框架" class="headerlink" title="platform驱动框架"></a>platform驱动框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span>&#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> </span><br><span class="line">  <span class="comment">/* 设备结构体其他具体内容 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxxdev</span> <span class="title">xxxdev</span>;</span> <span class="comment">/* 定义个设备结构体变量 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 函数具体内容 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">xxx_write</span><span class="params">( <span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 函数具体内容 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符设备驱动操作集</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> =</span> &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .open = xxx_open,</span><br><span class="line">  .write = xxx_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//platform 驱动的 probe 函数驱动与设备匹配成功以后此函数就会执行</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span>&#123; </span><br><span class="line">  ......</span><br><span class="line">  cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); <span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">  <span class="comment">/* 函数具体内容 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  cdev_del(&amp;xxxdev.cdev);<span class="comment">/* 删除 cdev */</span></span><br><span class="line">  <span class="comment">/* 函数具体内容 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配列表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ofdeviceid</span> <span class="title">xxxofmatch</span>[] =</span> &#123;</span><br><span class="line">  &#123; .compatible = <span class="string">&quot;xxx-gpio&quot;</span> &#125;，</span><br><span class="line">  &#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform 平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">xxx_driver</span> =</span> &#123;</span><br><span class="line">  .driver = &#123;</span><br><span class="line">    .name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    .of_match_table = xxx_of_match,</span><br><span class="line">  &#125;,</span><br><span class="line">  .probe = xxx_probe,</span><br><span class="line">  .remove = xxx_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动模块加载 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxdriver_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> platform_driver_register(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动模块卸载 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxxdriver_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  platform_driver_unregister(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxxdriver_init);</span><br><span class="line">module_exit(xxxdriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULEAUTHOR(<span class="string">&quot;hahahah&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="platform设备"><a href="#platform设备" class="headerlink" title="platform设备"></a>platform设备</h2><p>platform_device这个结构体表示platform设备，platform_device 结构体定义在文件<code>include/linux/platform_device.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span> </span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">//设备名字，需要和platform中的一样，否则无法匹配。</span></span><br><span class="line">  <span class="type">int</span> id; </span><br><span class="line">  <span class="type">bool</span> id_auto; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> </span><br><span class="line">  u32 num_resources;        <span class="comment">//资源数量，即resource的大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span><span class="comment">//描述资源，也就是设备信息，这个结构体可以选择资源类型，包括资源名字、类型，起始结束信息。</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span> </span><br><span class="line">  <span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span><span class="comment">/* MFD cell pointer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span> <span class="comment">/* arch specific additions */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编写platform_device变量来描述设备信息后，需要用户把这个设备信息注册到linux中。<br>注册函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_device_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pdev：要注册的 platform 设备。</li>
<li>返回值：负数，失败；0，成功。<br>注销函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">platform_device_unregister</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br></pre></td></tr></table></figure></li>
<li>pdev：要注销的 platform 设备。</li>
<li>返回值：无。</li>
</ul>
<h4 id="platform设备框架"><a href="#platform设备框架" class="headerlink" title="platform设备框架"></a>platform设备框架</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH1_REGISTER_BASE (0X20000000) <span class="comment">/* 外设 1 寄存器首地址 */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH2_REGISTER_BASE (0X020E0068) <span class="comment">/* 外设 2 寄存器首地址 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_LENGTH 4 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">xxx_resources</span>[] =</span> &#123;</span><br><span class="line">  [<span class="number">0</span>] = &#123; </span><br><span class="line">    .start = PERIPH1_REGISTER_BASE,</span><br><span class="line">    .end = (PERIPH1_REGISTER_BASE + REGISTER_LENGTH - <span class="number">1</span>),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">  &#125;, </span><br><span class="line">  [<span class="number">1</span>] = &#123;</span><br><span class="line">    .start = PERIPH2_REGISTER_BASE,</span><br><span class="line">    .end = (PERIPH2_REGISTER_BASE + REGISTER_LENGTH - <span class="number">1</span>),</span><br><span class="line">    .flags = IORESOURCE_MEM,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform 设备结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">xxxdevice</span> =</span> &#123;</span><br><span class="line">  .name = <span class="string">&quot;xxx-gpio&quot;</span>,</span><br><span class="line">  .id = <span class="number">-1</span>,</span><br><span class="line">  .num_resources = ARRAY_SIZE(xxx_resources),</span><br><span class="line">  .resource = xxx_resources,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备模块加载 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxdevice_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> platform_device_register(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备模块注销 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxxdevice_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  platform_device_unregister(&amp;xxxdevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxxdevice_init);</span><br><span class="line">module_exit(xxxdevice_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULEAUTHOR(<span class="string">&quot;hahah&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般没有设备树的才会使用这个旧方式，建议支持设备树就改用设备树描述把~ 顺势而为。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】VsCode使用CMake配置C++环境</title>
    <url>/blog/LinuxCplusConfig/</url>
    <content><![CDATA[<h1 id="VsCode需要安装的插件"><a href="#VsCode需要安装的插件" class="headerlink" title="VsCode需要安装的插件"></a>VsCode需要安装的插件</h1><pre><code>1、Tabnine: AI Autocomplete &amp; Chat for Javascript, Python, Typescript, PHP, Go, Java &amp; more 
2、Makefile Tools
3、CMake Tools
4、CMake Language Support
5、CMake
6、Chinese (Simplified) (简体中文) Language Pack for Visual 7、Studio Code
8、C/C++ Themes
9、C/C++ Project Generator
10、C/C++ Extension Pack
11、C/C++
12、Better C++ Syntax
13、NET Install Tool for Extension Authors
</code></pre>
<h1 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h1><p>多文件、多目录</p>
<p><img src="/picture/tech/vscode%E9%85%8D%E7%BD%AEc%E7%8E%AF%E5%A2%83/vscode_cmake1.png" alt="工程目录"></p>
<h2 id="根目录CMakeLists-txt"><a href="#根目录CMakeLists-txt" class="headerlink" title="根目录CMakeLists.txt"></a>根目录CMakeLists.txt</h2><pre><code>#CMake 最低版本号要求
cmake_minimum_required(VERSION 3.0)

#指定工程名
project(SoliderFire)

#包含目录
include_directories($&#123;PROJECT_SOURCE_DIR&#125;/inc)

#链接子目录CMakeFiles.txt
add_subdirectory(src)

#链接静态库
link_libraries(src)

#指定C/C++编译器
set(CMAKE_C_COMPILER &quot;/usr/bin/gcc&quot;)
set(CMAKE_CXX_COMPILER &quot;/usr/bin/g++&quot;)

#指定C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

#指定编译选项
set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;)
set(CMAKE_BUILD_TYPE Debug)

#生成可执行文件 main
add_executable(myexe main.cpp)
#add_executable($&#123;PROJECT_NAME&#125; main.cpp)
</code></pre>
<h2 id="次级目录CMakeLists-txt"><a href="#次级目录CMakeLists-txt" class="headerlink" title="次级目录CMakeLists.txt"></a>次级目录CMakeLists.txt</h2><pre><code>cmake_minimum_required(VERSION 3.0)
project(src)

#搜索源文件
aux_source_directory(./ SRC)

#编译静态库文件
add_library(src $&#123;SRC&#125;)
</code></pre>
<h1 id="vscode配置"><a href="#vscode配置" class="headerlink" title=".vscode配置"></a>.vscode配置</h1><h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>includePath：添加文件路径，写代码时候vscode就不会有红色波浪线。<br>compilerPath：g++目录，实际而定。</p>
<hr>
<pre><code>&#123;
    &quot;configurations&quot;: [
        &#123;
            &quot;name&quot;: &quot;Linux&quot;,
            &quot;includePath&quot;: [
                &quot;$&#123;workspaceFolder&#125;/**&quot;,
                &quot;$&#123;workspaceFolder&#125;/**/inc&quot;,
                &quot;$&#123;workspaceFolder&#125;/**/src&quot;
            ],
            &quot;defines&quot;: [],
            &quot;compilerPath&quot;: &quot;/usr/bin/g++&quot;,
            &quot;cStandard&quot;: &quot;c17&quot;,
            &quot;cppStandard&quot;: &quot;c++14&quot;,
            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;
        &#125;
    ],
    &quot;version&quot;: 4
&#125;
</code></pre>
<h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><p>vscode生成的，略微修改即可<br>修改成cmake生成的执行文件目录。</p>
<blockquote>
<p>“program”: “${workspaceFolder}&#x2F;build&#x2F;myexe”</p>
</blockquote>
<p>运行vscode时候执行的任务名字，与tasks.json有关联</p>
<blockquote>
<p>“preLaunchTask”: “Build”</p>
</blockquote>
<p>gdb路径</p>
<blockquote>
<p>“miDebuggerPath”:”&#x2F;usr&#x2F;bin&#x2F;gdb”</p>
</blockquote>
<p>name，随便写，debug时候别选错就行</p>
<blockquote>
<p>“name”: “g++ cmake 启动”</p>
</blockquote>
<hr>
<pre><code>&#123;
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        &#123;
            &quot;name&quot;: &quot;g++ cmake 启动&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/myexe&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                &#123;
                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                &#125;,
                &#123;
                    &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;,
                    &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;,
                    &quot;ignoreFailures&quot;: true
                &#125;
            ],
            &quot;preLaunchTask&quot;: &quot;Build&quot;,
            &quot;miDebuggerPath&quot;:&quot;/usr/bin/gdb&quot;
        &#125;

    ]
&#125;
</code></pre>
<h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><ul>
<li>cwd：在此目录生成执行文件</li>
<li>shell任务执行：cmake ..</li>
<li>make任务执行：make</li>
<li>build任务执行：shell和make</li>
<li>build任务在launch.json中执行。</li>
</ul>
<hr>
<pre><code>&#123;
   &#123;
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;options&quot;: &#123;
        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;
    &#125;,
    &quot;tasks&quot;: [
        &#123;
            &quot;label&quot;: &quot;mkdir&quot;,
            &quot;command&quot;: &quot;mkdir&quot;,
            &quot;args&quot;: [
                &quot;-p&quot;,
                &quot;build&quot;
            ]
        &#125;,
        &#123;
            &quot;label&quot;: &quot;cmake&quot;,
            &quot;command&quot;: &quot;cmake&quot;,
            &quot;args&quot;: [
                &quot;-B&quot;, 
                &quot;$&#123;workspaceFolder&#125;/build&quot;, 
                &quot;-S&quot;, 
                &quot;.&quot;
            ]
        &#125;,
        &#123;
            &quot;label&quot;: &quot;make&quot;,
            &quot;group&quot;: &#123;
                &quot;kind&quot;: &quot;build&quot;,
                &quot;isDefault&quot;: true
            &#125;,
            &quot;command&quot;: &quot;make&quot;,
            &quot;args&quot;: [],
            &quot;options&quot;: &#123;
                &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot;
            &#125;
        &#125;,
        &#123;
            &quot;label&quot;: &quot;Build&quot;,
            &quot;dependsOrder&quot;: &quot;sequence&quot;,
            &quot;dependsOn&quot;: [
                &quot;mkdir&quot;,
                &quot;cmake&quot;,
                &quot;make&quot;
            ]
        &#125;
    ]
&#125;
</code></pre>
<h1 id="Debug代码"><a href="#Debug代码" class="headerlink" title="Debug代码"></a>Debug代码</h1><p><img src="/picture/tech/vscode%E9%85%8D%E7%BD%AEc%E7%8E%AF%E5%A2%83/vscode_cmake2.png" alt="调试界面"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>c-plus</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】多线程喂狗</title>
    <url>/blog/LinuxDog/</url>
    <content><![CDATA[<h3 id="多线程喂狗实现原理"><a href="#多线程喂狗实现原理" class="headerlink" title="多线程喂狗实现原理"></a>多线程喂狗实现原理</h3><ol>
<li>创建看门狗线程，用于监控各个线程</li>
<li>为每个需要喂狗的线程定义一个信号&#x2F;事件&#x2F;结构体。</li>
<li>线程中定期给出信号或事件，使用结构体则修改其内容。</li>
<li>看门狗线程根据线程的操作，判断是否正常，从而选择是否重启程序或重启线程。</li>
</ol>
<h3 id="单内核操作系统（linux）"><a href="#单内核操作系统（linux）" class="headerlink" title="单内核操作系统（linux）"></a>单内核操作系统（linux）</h3><p>linux可以使用<code>eventfd</code>、<code>信号量</code>、<code>互斥量</code>实现多线程看门狗，此处使用<code>互斥量</code>。</p>
<p>多个线程需要在程序中定期调用Watchdog::heartbeat，来告诉看门狗，我还活着。若退出某线程，退出前务必调用Watchdog::removeThread。否则会一直提示看门狗超时。代码仅供参考，在应用环境还需要做更多处理。</p>
<p>一个完整的看门狗线程需要包含：心跳检测、超时机制、恢复措施、日志通知、参数可配置、清理与管理、安全机制、互斥并发。此处代码仅实现：心跳检查、超时机制、清理、互斥并发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watchdog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>: <span class="type">int</span> efd;</span><br><span class="line">    <span class="keyword">private</span>: std::map&lt;std::string, std::chrono::time_point&lt;std::chrono::steady_clock&gt;&gt; lastHeartbeats;<span class="comment">// 使用模板类，用名字索引，内容是上次心跳的时间。</span></span><br><span class="line">    <span class="keyword">private</span>: std::mutex heartbeatMutex;</span><br><span class="line">    <span class="keyword">private</span>: std::thread watchThread;</span><br><span class="line">    <span class="keyword">private</span>: std::condition_variable cv;</span><br><span class="line">    <span class="keyword">private</span>: <span class="type">bool</span> shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>: <span class="function"><span class="type">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(heartbeatMutex)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>), [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">return</span> shutdown;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : lastHeartbeats) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now  - pair.second).<span class="built_in">count</span>() &gt; std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)) &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;Watchdog triggered. No heartbeat received from &quot;</span> &lt;&lt; pair.first &lt;&lt; std::endl;</span><br><span class="line">                    <span class="comment">// 你可以在这里加入恢复措施，比如重启线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">Watchdog</span>() &#123;</span><br><span class="line">        watchThread = std::<span class="built_in">thread</span>(&amp;Watchdog::watch, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: ~<span class="built_in">Watchdog</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(heartbeatMutex)</span></span>;</span><br><span class="line">            shutdown = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">if</span> (watchThread.<span class="built_in">joinable</span>())</span><br><span class="line">            watchThread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">heartbeat</span><span class="params">(<span class="type">const</span> std::string&amp; threadName)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(heartbeatMutex)</span></span>;</span><br><span class="line">        lastHeartbeats[threadName] = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Heartbeat received from &quot;</span> &lt;&lt; threadName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">removeThread</span><span class="params">(<span class="type">const</span> std::string&amp; threadName)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(heartbeatMutex)</span></span>;</span><br><span class="line">        lastHeartbeats.<span class="built_in">erase</span>(threadName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work1_thread</span><span class="params">(Watchdog&amp; watchdog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">        watchdog.<span class="built_in">heartbeat</span>(<span class="string">&quot;work1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work2_thread</span><span class="params">(Watchdog&amp; watchdog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">        watchdog.<span class="built_in">heartbeat</span>(<span class="string">&quot;work2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Watchdog watchdog;</span><br><span class="line">  	<span class="function">std::thread <span class="title">work1</span><span class="params">(&amp;work1_thread, std::ref(watchdog))</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">work2</span><span class="params">(&amp;work2_thread, std::ref(watchdog))</span></span>;</span><br><span class="line"></span><br><span class="line">    work1.<span class="built_in">join</span>();</span><br><span class="line">    work2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="微内核操作系统（FreeRTOS）"><a href="#微内核操作系统（FreeRTOS）" class="headerlink" title="微内核操作系统（FreeRTOS）"></a>微内核操作系统（FreeRTOS）</h3><p>FreeRTOS可以使用<code>事件</code>方式来实现多线程看门狗。以下代码只保留核心部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义事件组</span></span><br><span class="line">EventGroupHandle_t watchdogEventGroup;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK1_WATCHDOG (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK2_WATCHDOG (1 &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看门狗任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">watchdogTask</span><span class="params">(<span class="type">void</span>* arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> TickType_t xMaxBlockTime = pdMS_TO_TICKS(MAX_TIME_MS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待所有任务的事件位都被设置</span></span><br><span class="line">        EventBits_t uxBits = xEventGroupWaitBits(</span><br><span class="line">            watchdogEventGroup,             <span class="comment">// 事件组句柄</span></span><br><span class="line">            TASK1_WATCHDOG|TASK2_WATCHDOG,  <span class="comment">// 等待的事件位</span></span><br><span class="line">            pdTRUE,                         <span class="comment">// 清除所有设置的事件位</span></span><br><span class="line">            pdTRUE,                         <span class="comment">// 等待所有指定的事件位都被设置</span></span><br><span class="line">            xMaxBlockTime                   <span class="comment">// 最大阻塞时间</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((uxBits &amp; (TASK1_WATCHDOG | TASK2_WATCHDOG)) == (TASK1_WATCHDOG | TASK2_WATCHDOG)) &#123;</span><br><span class="line">            <span class="comment">// 所有任务都正常喂了狗</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 至少有一个任务没有喂狗，可以采取相应的措施</span></span><br><span class="line">            <span class="keyword">if</span> ((uxBits &amp; TASK1_WATCHDOG) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 任务1没有喂狗</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((uxBits &amp; TASK2_WATCHDOG) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 任务2没有喂狗</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更多的任务检查...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要监控的线程</span></span><br><span class="line"><span class="type">void</span> workerTask1(<span class="type">void</span>* arg) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行...</span></span><br><span class="line">        <span class="comment">// 喂狗：设置任务1的事件位</span></span><br><span class="line">        xEventGroupSetBits(watchdogEventGroup, TASK1_WATCHDOG);</span><br><span class="line">        vTaskDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">workerTask2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行...</span></span><br><span class="line">        <span class="comment">// 喂狗：设置任务2的事件位</span></span><br><span class="line">        xEventGroupSetBits(watchdogEventGroup, TASK2_WATCHDOG);</span><br><span class="line">        vTaskDelay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 硬件初始化，如时钟、中断等...</span></span><br><span class="line">    <span class="comment">// 创建事件组</span></span><br><span class="line">    watchdogEventGroup = xEventGroupCreate();</span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    xTaskCreate(workerTask1, <span class="string">&quot;WorkerTask1&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, PRIORITY1, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(workerTask2, <span class="string">&quot;WorkerTask2&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, PRIORITY2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建看门狗任务</span></span><br><span class="line">    xTaskCreate(watchdogTask, <span class="string">&quot;WatchdogTask&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, WATCHDOG_PRIORITY, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 启动调度器</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    <span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】新字符设备驱动</title>
    <url>/blog/LinuxCharDevise/</url>
    <content><![CDATA[<h1 id="新旧字符设备驱动的差别"><a href="#新旧字符设备驱动的差别" class="headerlink" title="新旧字符设备驱动的差别"></a>新旧字符设备驱动的差别</h1><ol>
<li><p>注册设备方式</p>
<ul>
<li>旧：用register_chrdev函数来注册字符设备。这个函数需要设备号、设备名和一个指向file_operations结构体的指针</li>
<li>新：使用alloc_chrdev_region、cdev_init和cdev_add等函数来注册字符设备。</li>
</ul>
</li>
<li><p>设备文件</p>
<ul>
<li>旧：设备文件（通常位于&#x2F;dev目录）需要手动创建。这可以使用mknod命令来完成。</li>
<li>新：利用udev系统自动创建设备文件。</li>
</ul>
</li>
<li><p>设备号</p>
<ul>
<li>旧：旧式驱动通常使用静态设备号。静态设备号可能会导致设备号冲突，且浪费。</li>
<li>新：新式驱动使用动态分配的设备号，这减少了设备号冲突的可能性。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="新字符设备驱动实现方式"><a href="#新字符设备驱动实现方式" class="headerlink" title="新字符设备驱动实现方式"></a>新字符设备驱动实现方式</h1><h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><p>分配设备号有动态和静态两个方式。<br>如果给定了主次设备号，使用静态分配，调用如下函数：</p>
<p><code>int register_chrdev_region(dev_t from, unsigned count, const char *name)  // 不建议使用</code></p>
<p>静态分配设备号存在以下问题：</p>
<ul>
<li>需要主动确定未被使用的主设备号。</li>
<li>一个字符设备会消耗掉一个住设备号下所有的次设备号。（浪费）</li>
</ul>
<p>为了解决了这个问题，最好使用动态方式，在需要使用设备号时候向Linux内核申请，需要几个申请几个。由 Linux 内核分配设备可以使用的设备号，调用的函数如下：</p>
<p><code>int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</code></p>
<p>销毁字符设备时候释放设备号都是调用以下函数。</p>
<p><code>void unregister_chrdev_region(dev_t from, unsigned count)</code></p>
<hr>
<h2 id="新字符设备注册方法"><a href="#新字符设备注册方法" class="headerlink" title="新字符设备注册方法"></a>新字符设备注册方法</h2><h3 id="字符设备结构体"><a href="#字符设备结构体" class="headerlink" title="字符设备结构体"></a>字符设备结构体</h3><p>Linux 中使用 cdev 结构体表示一个字符设备，cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="comment">// 用于管理内核对象的生命周期以及提供设备模型（Device Model）支持</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> </span><br><span class="line">    <span class="comment">//指向拥有这个字符设备的内核模块，防止在字符设备仍在使用时卸载内核模块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> </span><br><span class="line">    <span class="comment">// 操作函数集合</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> </span><br><span class="line">    <span class="comment">// 用于将字符设备插入到内核管理的字符设备链表中的链表头。通过这个链表，内核能够管理和查找系统中的所有字符设备。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> </span><br><span class="line">    <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">dev_t</span> dev;  </span><br><span class="line">    <span class="comment">// 记录字符设备占用的设备号范围的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; </span><br><span class="line">&#125; __randomize_layout;<span class="comment">//编译时布局进行随机化处理，安全</span></span><br></pre></td></tr></table></figure>



<h3 id="注册和添加设备函数：cdev-init-和cdev-add"><a href="#注册和添加设备函数：cdev-init-和cdev-add" class="headerlink" title="注册和添加设备函数：cdev_init()和cdev_add()"></a>注册和添加设备函数：cdev_init()和cdev_add()</h3><p>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化。随后使和cdev_add函数向 Linux 系统添加这个字符设备。用例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">myCdev</span>;</span>、</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">myFops</span> =</span> &#123; </span><br><span class="line">    .owner =    THIS_MODULE, </span><br><span class="line">    <span class="comment">/* 其他具体的初始项 */</span></span><br><span class="line">&#125;;</span><br><span class="line">myCdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;myCdev, &amp;myFops); <span class="comment">/* 初始化 cdev 结构体变量 */</span></span><br><span class="line">cdev_add(&amp;myCdev, devid, <span class="number">1</span>); <span class="comment">/* 添加字符设备 */</span></span><br></pre></td></tr></table></figure>
<p>如果再加上面中分配设备号的程序，相当于 <code>register_chrdev</code> 函数的功能。</p>
<h3 id="卸载驱动函数：cdev-del"><a href="#卸载驱动函数：cdev-del" class="headerlink" title="卸载驱动函数：cdev_del()"></a>卸载驱动函数：cdev_del()</h3><p>卸载驱动的时候要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备。</p>
<p>函数：<code>cdev_del(&amp;myCdev); /* 删除 cdev */</code></p>
<p><code>cdev_del </code>和 <code>unregister_chrdev_region </code>这两个函数合起来的功能相当于 <code>unregister_chrdev</code> 函<br>数。</p>
<hr>
<h2 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h2><h3 id="启用udev"><a href="#启用udev" class="headerlink" title="启用udev"></a>启用udev</h3><p>这个不需要我们主动开启，开机会自动开启的，此处仅介绍他的用处~</p>
<p>udev 是 Linux 系统中用于管理设备节点的守护进程，运行在用户空间。<br>其作用可粗略分为以下：</p>
<ol>
<li>管理 &#x2F;dev&#x2F; 目录下的设备节点：当新设备被添加到系统时，udev 会根据规则文件来创建相应的设备节点。相应地，当设备被移除时，udev 会删除设备节点。</li>
<li>设备持久命名：通过创建持久的、一致的设备节点名称，udev 确保了设备名称在系统重启或设备重新插拔后保持不变。</li>
<li>运行设备特定的初始化和配置脚本：udev 可以根据规则文件配置设备或运行初始化脚本。</li>
<li>加载或关闭额外的设备驱动或固件。（modprobe、rmmod）</li>
</ol>
<h3 id="创建和删除类"><a href="#创建和删除类" class="headerlink" title="创建和删除类"></a>创建和删除类</h3><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添<br>加自动创建设备节点相关代码。首先要创建一个 class 类。定义在<code>include/linux/device.h</code>。<br>创建和删除的函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class *<span class="title function_">class_create</span> <span class="params">(<span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h3><p>创建类后，还需要创建设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此为可变参函数</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> class *class,    <span class="comment">// 创建到哪个class</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *parent,  <span class="comment">// 父设备，一般为NULL</span></span></span><br><span class="line"><span class="params">    <span class="type">dev_t</span> devt,             <span class="comment">// 设备号</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *drvdata,          <span class="comment">// 可以用来传递设备驱动的私有数据，不需要则NULL</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *fmt, ...    <span class="comment">//设备名字，如果设置 fmt=xxx，会生成/dev/xxx设备文件</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p>如果需要卸载，则使用删除函数：</p>
<p><code>void device_destroy(struct class *cls, dev_t devt)</code></p>
<h3 id="参考示例"><a href="#参考示例" class="headerlink" title="参考示例"></a>参考示例</h3><p>在入口函数中创建类与设备，出口函数删除类和设备：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 创建类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;XXXX&quot;</span>)</span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, <span class="string">&quot;XXXX&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除设备</span></span><br><span class="line">    device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">    <span class="comment">// 删除类</span></span><br><span class="line">    class_destroy(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】设备树</title>
    <url>/blog/LinuxDevTree/</url>
    <content><![CDATA[<h1 id="何为设备树"><a href="#何为设备树" class="headerlink" title="何为设备树"></a>何为设备树</h1><p>也就是用树形结构描述板级设备，描述设备树的文件后缀是DTS(Device Tree Source)。示意图如下：</p>
<p><img src="/picture/tech/linux%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%AE%BE%E5%A4%87%E6%A0%911.jpg"></p>
<h1 id="DTS、DTB、DTC"><a href="#DTS、DTB、DTC" class="headerlink" title="DTS、DTB、DTC"></a>DTS、DTB、DTC</h1><ul>
<li><p>DTS：设备树源文件</p>
</li>
<li><p>DTB：源文件编译得到的二进制文件，用于烧录</p>
</li>
<li><p>DTC：把DTS编译成DTB的工具</p>
<p>  使用此文件只需进入linux源码目录，执行：</p>
<p>  <code>make ARCH=arm64 all</code>或<code>make ARCH=arm64 dtbs</code>或<code>make ARCH=arm64 xxxxx.dtb</code></p>
</li>
</ul>
<p>如果我们自己添加了dts文件，需要进入<code>arch/arm64/boot/dts/rockchip/Makefile</code>中把我们新建的dts和需要生成的dtb添加到Makefile中，这样编译时候就会自动编译进去了。</p>
<h1 id="DTS相关介绍"><a href="#DTS相关介绍" class="headerlink" title="DTS相关介绍"></a>DTS相关介绍</h1><p>详细的设备树语法请参考以下手册：</p>
<blockquote>
<p>《 Devicetree SpecificationV0.2.pdf 》<br>《Power_ePAPR_APPROVED_v1.12.pdf》</p>
</blockquote>
<h2 id="头文件（-dtsi）"><a href="#头文件（-dtsi）" class="headerlink" title="头文件（.dtsi）"></a>头文件（.dtsi）</h2><p>设备树源文件dts中，可以通过#include来引用.h和.dtsi文件，如果我们需要自行编写，最好使用dtsi。</p>
<p>一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范<br>围，比如 UART、IIC 等等。比如 rk3568.dtsi 就是描述 RK3568 芯片本身的外设信息，以下是rk3568.dtsi 片段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3568&quot;</span>;</span><br><span class="line">    interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    aliases &#123;</span><br><span class="line">        csi2dphy0 = &amp;csi2_dphy0;</span><br><span class="line">        csi2dphy1 = &amp;csi2_dphy1;</span><br><span class="line">        csi2dphy2 = &amp;csi2_dphy2;</span><br><span class="line">        dsi0 = &amp;dsi0;</span><br><span class="line">        spi3 = &amp;spi3;</span><br><span class="line">        spi4 = &amp;sfc; <span class="comment">// for U-Boot</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cpus &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">        cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">            device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">            compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0x0</span> <span class="number">0x0</span>&gt;;</span><br><span class="line">            enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">            clocks = &lt;&amp;scmi_clk <span class="number">0</span>&gt;;</span><br><span class="line">            operating-points-v2 = &lt;&amp;cpu0_opp_table&gt;;</span><br><span class="line">            cpu-idle-states = &lt;&amp;CPU_SLEEP&gt;;</span><br><span class="line">            <span class="meta">#cooling-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">            dynamic-power-coefficient = &lt;<span class="number">187</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line"></span><br><span class="line">        cpu3: cpu@<span class="number">300</span> &#123;</span><br><span class="line">            device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">            compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0x0</span> <span class="number">0x300</span>&gt;;</span><br><span class="line">enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">            clocks = &lt;&amp;scmi_clk <span class="number">0</span>&gt;;</span><br><span class="line">            operating-points-v2 = &lt;&amp;cpu0_opp_table&gt;;</span><br><span class="line">            cpu-idle-states = &lt;&amp;CPU_SLEEP&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        idle-states &#123;</span><br><span class="line">            entry-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">            CPU_SLEEP: cpu-sleep &#123;</span><br><span class="line">                compatible = <span class="string">&quot;arm,idle-state&quot;</span>;</span><br><span class="line">                local-timer-stop;</span><br><span class="line">                arm,psci-suspend-param = &lt;<span class="number">0x0010000</span>&gt;;</span><br><span class="line">                entry-latency-us = &lt;<span class="number">100</span>&gt;;</span><br><span class="line">                <span class="built_in">exit</span>-latency-us = &lt;<span class="number">120</span>&gt;;</span><br><span class="line">                min-residency-us = &lt;<span class="number">1000</span>&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>上边描述了RK3568<br>这颗 SOC 所有的 CPU 信息，一共有 4 个 CPU，也就是 4 核，架构是 cortex-A55。</p>
<h2 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h2><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，节点都通过一些属性信息来描述节点信息，属性就是键—值对。</p>
<p>设备树中节点命<br>名格式如下，node-name是节点名字，unit-address是设备的地址或寄<br>存器首地址。</p>
<p><code>node-name@unit-address</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">    device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0x0</span>&gt;;</span><br><span class="line">    enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">    clocks = &lt;&amp;scmi_clk <span class="number">0</span>&gt;;</span><br><span class="line">    operating-points-v2 = &lt;&amp;cpu0_opp_table&gt;;</span><br><span class="line">    cpu-idle-states = &lt;&amp;CPU_SLEEP&gt;;</span><br><span class="line">    <span class="meta">#cooling-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    dynamic-power-coefficient = &lt;<span class="number">187</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>cpu0: cpu@0 ：cpu0是节点标签，后面是节点命名。引入了标签(label)后可以直接用过&amp;label访问这个节点，不需要输入完整节点。</li>
</ul>
<p>设备树源码中，常用的几种数据形式如下：</p>
<ul>
<li>字符串：<code>compatible = &quot;rockchip,rk3568&quot;;</code>.</li>
<li>字符串列表：<code>compatible = &quot;rockchip,rk3568-evb &quot;, &quot;rockchip,rk3568&quot;;</code>.</li>
<li>字符串：<code>reg = &lt;0&gt;;</code>或<code>reg = &lt;0 0x123456 100&gt;;</code>.</li>
</ul>
<h3 id="设备节点中的标准属性介绍"><a href="#设备节点中的标准属性介绍" class="headerlink" title="设备节点中的标准属性介绍"></a>设备节点中的标准属性介绍</h3><ol>
<li><p>compatible</p>
<p>提供了设备的兼容性信息，用于设备和驱动绑定起来。这个可以是多属性值。</p>
<p><code>compatible = &quot;ilitek,ili9881d&quot;, &quot;simple-panel-dsi&quot;;</code></p>
<p> 设备首先使用第一个兼容值在 Linux 内核（od匹配表）里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值。</p>
</li>
<li><p>model</p>
<p> 用于属性描述开发板的名字或者设备模块信息。</p>
<p> <code>model = &quot;I love u model&quot;;</code></p>
</li>
<li><p>status</p>
<p> 和设备状态有关</p>
<ul>
<li>okay：表明设备是可操作的</li>
</ul>
</li>
</ol>
<ul>
<li>disabled：表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备<ul>
<li>fail：设备不可操作，设备检测到了一系列的错误</li>
</ul>
</li>
<li>fail-sss：含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</li>
</ul>
<ol start="4">
<li><p>#address-cells 和#size-cells 属性</p>
<p> 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。</p>
<ul>
<li>#address-cells：子节点 reg 属性中地址信息所占用的字长(32 位)。</li>
<li>#size-cells ：子节点 reg 属性中长度信息所占的字长(32 位)。</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起始地址所占用的字长为 2，地址长度所占用的字长为 2。</span></span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>reg属性</p>
<p> reg 属性的值一般是(address，length)对。reg 属性一般用于描述设备地址空间资源信息或者设备地址信，如息uart器件的设备地址。rk3568.dtsi 中:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uart5: serial@fe690000 &#123;</span><br><span class="line">    compatible = &quot;rockchip,rk3568-uart&quot;, &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">    reg = &lt;0x0 0xfe690000 0x0 0x100&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru SCLK_UART5&gt;, &lt;&amp;cru PCLK_UART5&gt;;</span><br><span class="line">    clock-names = &quot;baudclk&quot;, &quot;apb_pclk&quot;;</span><br><span class="line">    reg-shift = &lt;2&gt;;</span><br><span class="line">    reg-io-width = &lt;4&gt;;</span><br><span class="line">    dmas = &lt;&amp;dmac0 10&gt;, &lt;&amp;dmac0 11&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;uart5m0_xfer&gt;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> uart5 的父节点“&#x2F;”设置了#address-cells &#x3D; &lt;1&gt;、#size-cells &#x3D; &lt;1&gt;（此处未体现）</p>
<p> 所以地址信息长度、长度信息长度都要设置。就有了<code>reg = &lt;0x0 0xfe690000 0x0 0x100&gt;;</code>。</p>
</li>
<li><p>ranges 属性</p>
<p>ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度</p>
<p>这三部分组成：</p>
<ul>
<li><strong>child-bus-address</strong>：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址</li>
</ul>
<p>所占用的字长。</p>
<ul>
<li><strong>parent-bus-address</strong>：父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物</li>
</ul>
<p>理地址所占用的字长。</p>
<ul>
<li><strong>length</strong>：地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长。</li>
</ul>
<p>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。 RK3568 的子地址空间和父地址空间完全相同，因此会在 rk3568.dtsi 中找到大量的值为空的 ranges 属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl: pinctrl &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span>;</span><br><span class="line">    rockchip,grf = &lt;&amp;grf&gt;;</span><br><span class="line">    rockchip,pmu = &lt;&amp;pmugrf&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">    ranges;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>name属性</p>
<p>name 属性值为字符串，name 属性用于记录节点名字，name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。</p>
</li>
<li><p>device_type属性</p>
<p>device_type 属性值为字符串，IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设</p>
<p>备树没有 FCode，所以此属性也被抛弃了。</p>
<p>且此属性只能用于 cpu 节点或者 memory 节点。上面代码的cpu0节点使用了次属性值~</p>
</li>
</ol>
<h3 id="根节点compatible属性"><a href="#根节点compatible属性" class="headerlink" title="根节点compatible属性"></a>根节点compatible属性</h3><ul>
<li>​	设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序。</li>
<li>​	Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。</li>
</ul>
<p>比如<code>rk3568-atk-evb1-ddr4-v10.dtsi</code> 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">	......</span><br><span class="line">	compatible = <span class="string">&quot;rockchip,rk3568-evb1-ddr4-v10&quot;</span>,<span class="string">&quot;rockchip,rk3568&quot;</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>rockchip：描述硬件设备名字。</li>
<li>rk3568-evb1-ddr4-v10、rk3568：设备所使用的 SOC。</li>
</ul>
<p>在代码<code>include/linux/rockchip/cpu.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">cpu_is_rk3568</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (rockchip_soc_id)</span><br><span class="line">		<span class="keyword">return</span> (rockchip_soc_id &amp; ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3568;</span><br><span class="line">	<span class="keyword">return</span> of_machine_is_compatible(<span class="string">&quot;rockchip,rk3568&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu_is_rk3568函数判断当前是否为 RK3568，使用 <code>of_machine_is_compatible</code>函数判断根节点 <code>compatible</code> 值里面是否有<code>rockchip,rk3568</code>。根据示例代码 8.3.4.1 可知，根节点的 compatible 中有<code>rockchip,rk3568</code>，所以匹配。</p>
<h3 id="向节点追加or修改内容"><a href="#向节点追加or修改内容" class="headerlink" title="向节点追加or修改内容"></a>向节点追加or修改内容</h3><p>注意以下几点：</p>
<ol>
<li><p>比如需要在I2C5节点添加六轴传感器。不可直接在<code>rk3568.dtsi</code>中添加，这个是共有的设备树头文件，别的设备不一定有这个传感器。</p>
</li>
<li><p>需要在自己板子的设备树文件中追加内容。如：i2c5 节点追加一个名为 fxls8471 的子节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3568-atk-evb1-ddr4-v10.dtsi</span></span><br><span class="line">&amp;i2c5 &#123; </span><br><span class="line">    <span class="comment">/* 追加状态时钟频率 */</span></span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line">    <span class="comment">/* 追加fxls8471子节点 */</span></span><br><span class="line">    fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容。</p>
</li>
</ol>
<h1 id="练习：创建设备树模板"><a href="#练习：创建设备树模板" class="headerlink" title="练习：创建设备树模板"></a>练习：创建设备树模板</h1><p>这个设备树没有实际的意义，做这个的目的是为了掌握设备树的语法。仅编写了 RK3568 的外设控制器节点，</p>
<p>节点下的属性不写出来。以RK3568为例。我们需要在设备树里面描述的内容如下：</p>
<ol>
<li>这个芯片是由四个 Cortex-A55 架构的 64 位 CPU 组成。</li>
<li>RK3568 内部 uart2，起始地址为 0xfe660000，大小为 256B(0x100)。 </li>
<li>RK3568 内部 spi0，起始地址为 0xfe610000，大小为 4KB(0x1000)。 </li>
<li>RK3568 内部 i2c5，起始地址为 0xfe5e0000，大小为 4KB(0x1000)。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    <span class="comment">// 根节点compatible 属性</span></span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3568-evb1-ddr4-v10&quot;</span>,<span class="string">&quot;rockchip,rk3568&quot;</span>;</span><br><span class="line">    <span class="comment">/*---------- 添加CPU节点 ----------*/</span></span><br><span class="line">    cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x0</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    cpu1: cpu@<span class="number">1</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    cpu2: cpu@<span class="number">2</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x200</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    cpu3: cpu@<span class="number">3</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a55&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x300</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*---------- 添加uart2节点 ----------*/</span></span><br><span class="line">    uart2: serial@fe660000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3568-uart&quot;</span>, <span class="string">&quot;snps,dw-apb-uart&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe660000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*---------- 添加spi0节点 ----------*/</span></span><br><span class="line">    spi0: spi@fe610000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3568-spi&quot;</span>, <span class="string">&quot;rockchip,rk3066-spi&quot;</span>;</span><br><span class="line">        reg =  &lt;<span class="number">0x0</span> <span class="number">0xfe610000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*---------- 添加i2c5节点 ----------*/</span></span><br><span class="line">    i2c5: i2c@fe5e0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3568-i2c&quot;</span>, <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5e0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="设备树在系统的体现"><a href="#设备树在系统的体现" class="headerlink" title="设备树在系统的体现"></a>设备树在系统的体现</h1><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的<code>/proc/device-tree</code> 目录下根据节点名字创建不同文件夹。</p>
<p>可以进入<code>/proc/device-tree</code> 目录下查看各子节点和属性信息。</p>
<p>但是需要注意两个特殊节点</p>
<ul>
<li><strong>aliases</strong> 子节点：</li>
</ul>
<p>  aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label 来访问节点</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3568.dtsi 文件中</span></span><br><span class="line">aliases &#123;</span><br><span class="line">    i2c0 = &amp;i2c0;</span><br><span class="line">    i2c1 = &amp;i2c1;</span><br><span class="line">    i2c2 = &amp;i2c2;</span><br><span class="line">    i2c3 = &amp;i2c3;</span><br><span class="line">    ...</span><br><span class="line">    dphy0 = &amp;csi_dphy0;</span><br><span class="line">    dphy1 = &amp;csi_dphy1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>chosen子节点：</p>
<p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重</p>
<p>点是 bootargs 参数。一般.dts 文件中 chosen 节点通常为空或者内容很少，rk3568-linux.dtsi 中</p>
<p>chosen 节点内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chosen: chosen &#123;</span><br><span class="line">	bootargs = <span class="string">&quot;earlycon=uart8250,mmio32,0xfe660000 console=ttyFIQ0 root=PARTUUID=614e0000-0000 rw rootwait&quot;</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>如果在<code>/proc/device-tree</code> 目录下查看<code>chosen</code>，出现的属性值是是 uboot 下 bootargs 环境变量的值加设备树里面 bootargs 属性的值！拼接出来的</p>
</li>
</ul>
<h1 id="绑定信息文档"><a href="#绑定信息文档" class="headerlink" title="绑定信息文档"></a>绑定信息文档</h1><p>我们在设备树中添加一个硬件对应的节点可以在<code>Linux 源码目录/Documentation/devicetree/bindings</code>中查看做绑定文档信息。</p>
<p>比如我们现在要想在 RK3568 这颗 SOC 的 I2C 下添加一个节点，那么就可以查看Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-rk3x.txt，此文档详细的描述了瑞芯微出品的 SOC 如何在设备树中添加 I2C 设备节点，文档内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* Rockchip RK3xxx I2C controller</span><br><span class="line">    </span><br><span class="line">This driver interfaces with the native I2C controller present in </span><br><span class="line">Rockchip</span><br><span class="line">RK3xxx SoCs.</span><br><span class="line">    </span><br><span class="line">Required properties : </span><br><span class="line">- reg : Offset and length of the <span class="keyword">register</span> <span class="built_in">set</span> <span class="keyword">for</span> the device</span><br><span class="line">- compatible: should be one of the following:</span><br><span class="line">     - <span class="string">&quot;rockchip,rv1108-i2c&quot;</span>: <span class="keyword">for</span> rv1108</span><br><span class="line">     - <span class="string">&quot;rockchip,RK3568-i2c&quot;</span>: <span class="keyword">for</span> RK3568</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3066-i2c&quot;</span>: <span class="keyword">for</span> rk3066</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3188-i2c&quot;</span>: <span class="keyword">for</span> rk3188</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3228-i2c&quot;</span>: <span class="keyword">for</span> rk3228</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3288-i2c&quot;</span>: <span class="keyword">for</span> rk3288</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3328-i2c&quot;</span>, <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>: <span class="keyword">for</span> rk3328</span><br><span class="line">     - <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>: <span class="keyword">for</span> rk3399</span><br><span class="line">- interrupts : interrupt number</span><br><span class="line">- clocks: See ../clock/clock-bindings.txt</span><br><span class="line">     - For older <span class="title function_">hardware</span> <span class="params">(rk3066, rk3188, rk3228, rk3288)</span>:</span><br><span class="line">     	- There is one clock that&#x27;s used both to derive the functional </span><br><span class="line">clock</span><br><span class="line">	 <span class="keyword">for</span> the device and as the bus clock.</span><br><span class="line"> - For newer <span class="title function_">hardware</span> <span class="params">(rk3399)</span>: specified by name</span><br><span class="line">     - &quot;i2c&quot;: This is used to derive the functional clock.</span><br><span class="line">     - &quot;pclk&quot;: This is the bus clock.</span><br><span class="line">Required on RK3066, RK3188 :</span><br><span class="line">- rockchip,grf : the phandle of the syscon node <span class="keyword">for</span> the general </span><br><span class="line"><span class="keyword">register</span></span><br><span class="line"> 	<span class="title function_">file</span> <span class="params">(GRF)</span> </span><br><span class="line">- on those SoCs an alias with the correct I2C bus <span class="title function_">ID</span> <span class="params">(bit offset in </span></span><br><span class="line"><span class="params">the GRF)</span></span><br><span class="line"> 	is also required.</span><br><span class="line">Optional properties : </span><br><span class="line">- clock-frequency : SCL frequency to <span class="title function_">use</span> <span class="params">(in Hz)</span>. If omitted, 100kHz</span><br><span class="line">is used. </span><br><span class="line">- i2c-scl-rising-time-ns : Number of nanoseconds the SCL signal takes </span><br><span class="line">to <span class="title function_">rise</span></span><br><span class="line">     <span class="params">(t(r) in I2C specification)</span>. If not specified this is assumed to be</span><br><span class="line">     the maximum the specification <span class="title function_">allows</span><span class="params">(<span class="number">1000</span> ns <span class="keyword">for</span> Standard-mode,</span></span><br><span class="line"><span class="params">     <span class="number">300</span> ns <span class="keyword">for</span> Fast-mode)</span> which might cause slightly slower </span><br><span class="line">communication. </span><br><span class="line">    - i2c-scl-falling-time-ns : Number of nanoseconds the SCL signal takes </span><br><span class="line">to <span class="title function_">fall</span></span><br><span class="line"> 	<span class="params">(t(f) in the I2C specification)</span>. If not specified this is assumed to</span><br><span class="line">     be the maximum the specification <span class="title function_">allows</span> <span class="params">(<span class="number">300</span> ns)</span> which might cause</span><br><span class="line">     slightly slower communication.</span><br><span class="line"> - i2c-sda-falling-time-ns : Number of nanoseconds the SDA signal takes </span><br><span class="line">to <span class="title function_">fall</span></span><br><span class="line">     <span class="params">(t(f) in the I2C specification)</span>. If not specified we&#x27;ll use the SCL</span><br><span class="line">     value since they are the same in nearly all cases.</span><br><span class="line">     </span><br><span class="line">Example:</span><br><span class="line">aliases &#123;</span><br><span class="line"> 	i2c0 = &amp;i2c0; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c0: i2c@<span class="number">2002</span>d000 &#123;</span><br><span class="line">     compatible = <span class="string">&quot;rockchip,rk3188-i2c&quot;</span>;</span><br><span class="line">     reg = &lt;<span class="number">0x2002d000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">     interrupts = &lt;GIC_SPI <span class="number">40</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">     <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">     <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">     rockchip,grf = &lt;&amp;grf&gt;;</span><br><span class="line">     clock-names = <span class="string">&quot;i2c&quot;</span>;</span><br><span class="line">     clocks = &lt;&amp;cru PCLK_I2C0&gt;;</span><br><span class="line">     i2c-scl-rising-time-ns = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">     i2c-scl-falling-time-ns = &lt;<span class="number">100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="设备树常用OF操作函数"><a href="#设备树常用OF操作函数" class="headerlink" title="设备树常用OF操作函数"></a>设备树常用OF操作函数</h1><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p>
<h2 id="查找节点OF函数"><a href="#查找节点OF函数" class="headerlink" title="查找节点OF函数"></a>查找节点OF函数</h2><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 device_node 结构体来描述一个节点。结构体定义在文件 include&#x2F;linux&#x2F;of.h 中</p>
<ul>
<li><p><strong>of_find_node_by_name</strong> <strong>函数</strong></p>
<p>通过节点名字查找指定的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>from</strong>：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
</ul>
<p>	</p>
</li>
<li><p><strong>name</strong>：要查找的节点名字。</p>
<ul>
<li><strong>返回值：</strong>找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li><p><strong>of_find_node_by_type</strong> <strong>函数</strong></p>
<p>通过 device_type 属性查找指定的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。</li>
<li>返回值：找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li><p><strong>of_find_compatible_node</strong> <strong>函数</strong></p>
<p>根据 device_type 和 compatible 这两个属性查找指定的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</p>
</li>
<li><p>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示</p>
<p>忽略掉 device_type 属性。</p>
</li>
<li><p>compat<strong>：</strong>要查找的节点所对应的 compatible 属性列表。</p>
</li>
<li><p>返回值：找到的节点，如果为 NULL 表示查找失败。</p>
</li>
</ul>
</li>
<li><p><strong>of_find_matching_node_and_match</strong> <strong>函数</strong></p>
<p>根据 device_type 和 compatible 这两个属性查找指定的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>matches：of_device_id 匹配表，也就是在此匹配表里面查找节点</li>
<li>match<strong>：</strong>找到的匹配的 of_device_id。</li>
<li>返回值：找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li><p><strong>of_find_node_by_path</strong> <strong>函数</strong></p>
<p>通过路径来查找指定的节点.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>path：带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个</p>
<p>节点的全路径。</p>
</li>
<li><p>返回值：找到的节点，如果为 NULL 表示查找失败。</p>
</li>
</ul>
</li>
</ul>
<h2 id="查找父-子节点的-OF-函数"><a href="#查找父-子节点的-OF-函数" class="headerlink" title="查找父&#x2F;子节点的 OF 函数"></a>查找父&#x2F;子节点的 OF 函数</h2><ul>
<li><p><strong>of_get_parent</strong> <strong>函数</strong></p>
<p>用于获取指定节点的父节点(如果有父节点的话）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>node：要查找的父节点的节点。</li>
<li>返回值：找到的父节点。</li>
</ul>
</li>
<li><p><strong>of_get_next_child</strong> <strong>函数</strong></p>
<p>用迭代的查找子节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>node：父节点</p>
</li>
<li><p>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为</p>
<p>NULL，表示从第一个子节点开始。</p>
</li>
<li><p>返回值：找到下一个节点</p>
</li>
</ul>
</li>
</ul>
<h2 id="提取属性值的-OF-函数"><a href="#提取属性值的-OF-函数" class="headerlink" title="提取属性值的 OF 函数"></a><strong>提取属性值的</strong> <strong>OF</strong> <strong>函数</strong></h2><ul>
<li><p><strong>of_find_property</strong> <strong>函数</strong></p>
<ul>
<li>数用于查找指定的属性</li>
</ul>
</li>
<li><p><strong>of_property_count_elems_of_size</strong> <strong>函数</strong></p>
<ul>
<li><p>用于获取属性中元素的数量，比如 reg 属性值是一个</p>
<p>数组，那么使用此函数可以获取到这个数组的大小</p>
</li>
</ul>
</li>
<li><p><strong>of_property_read_u32_index</strong> <strong>函数</strong></p>
<ul>
<li><p>用于从属性中获取指定标号的 u32 类型数据值(无符号 32</p>
<p>位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值</p>
</li>
</ul>
</li>
<li><p><strong>of_property_read_u8_array</strong> <strong>函数</strong></p>
<ul>
<li><p>u8可改成u16、u32、u64</p>
</li>
<li><p>分别是读取属性中 u8、u16、u32 和 u64 类型的<strong>数组</strong>数据，比如大多数的 reg 属</p>
<p>性都是数组数据，可以使用这 4 个函数一次读取出 reg 属性中的所有数据</p>
</li>
</ul>
</li>
<li><p><strong>of_property_read_u8</strong> <strong>函数</strong></p>
<ul>
<li>u8可改成u16、u32、u64</li>
<li>有些属性只有一个整形值，这四个函数就是用于读取这种只有一个整形值的属性</li>
</ul>
</li>
<li><p><strong>of_property_read_string</strong> <strong>函数</strong></p>
<ul>
<li>数用于读取属性中字符串值</li>
</ul>
</li>
<li><p><strong>of_n_addr_cells</strong> *<em>函数</em></p>
<ul>
<li>用于获取#address-cells 属性值</li>
</ul>
</li>
<li><p><strong>of_n_size_cells</strong> <strong>函数</strong></p>
<ul>
<li>用于获取#size-cells 属性值</li>
</ul>
</li>
</ul>
<h1 id="其他常用的-OF-函数"><a href="#其他常用的-OF-函数" class="headerlink" title="其他常用的 OF 函数"></a><strong>其他常用的</strong> <strong>OF</strong> <strong>函数</strong></h1><ul>
<li><p><strong>of_device_is_compatible</strong> <strong>函数</strong></p>
<ul>
<li><p>用于查看节点的 compatible 属性是否有包含 name 指定的字符</p>
<p>串，也就是检查设备节点的兼容性</p>
</li>
</ul>
</li>
<li><p><strong>of_get_address</strong> <strong>函数</strong></p>
<ul>
<li><p>数用于获取地址相关属性，主要是“reg”或者“assigned-addresses”属性</p>
<p>值</p>
</li>
</ul>
</li>
<li><p><strong>of_translate_address</strong> <strong>函数</strong></p>
<ul>
<li>数负责将从设备树读取到的物理地址转换为虚拟地址</li>
</ul>
</li>
<li><p><strong>of_address_to_resource</strong> <strong>函数</strong></p>
<ul>
<li>此函数看名字像是从设备树里面提取资源值，但是本质上就是提取 reg 属性值，然后将其转换为 resource 结构体类型</li>
<li>这个牵扯复杂一点，简单来说就是GPIO、IIC等外设有自己的寄存器，这些寄存器实际就是一组内存空间，linux使用一个resource（资源）结构体来描述这个内存空间。使用这个函数后，把设备树节点中描述的地址信息转换为内核中的资源（resource）结构体。资源结构体通常包含了设备的物理地址、大小和其他相关信息，这样驱动就可以通过这个正确访问硬件设备。</li>
<li>使用场景：驱动程序在初始化阶段会调用这个函数，以获取设备的物理地址和大小等信息。得到这些信息后，驱动可以进行进一步的初始化，比如映射物理内存到虚拟地址空间，或者配置设备寄存器等。</li>
</ul>
</li>
<li><p><strong>of_iomap</strong> <strong>函数</strong></p>
<ul>
<li><p>数用于直接内存映射</p>
</li>
<li><p>是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参</p>
<p>数指定要完成内存映射的是哪一段</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】线程进程</title>
    <url>/blog/LinuxThread/</url>
    <content><![CDATA[<h1 id="进程线程概念"><a href="#进程线程概念" class="headerlink" title="进程线程概念"></a>进程线程概念</h1><h2 id="what‘s-a-线程-进程"><a href="#what‘s-a-线程-进程" class="headerlink" title="what‘s a 线程&amp;进程"></a>what‘s a 线程&amp;进程</h2><p>进程和线程是操作系统中关于任务管理和调度的基本概念。</p>
<ul>
<li><p>进程</p>
<p>1、进程是一个独立的、在内存中运行的程序实例，它拥有自己的地址空间、代码、开放的文件句柄、系统资源和独立的系统上下文。</p>
<p>2、每个进程都有自己独立的地址空间。</p>
<p>3、创建、销毁或切换进程的开销比线程要大。</p>
</li>
<li><p>线程</p>
<p>1、线程是进程内的一个执行单元或控制流，它共享该进程的地址空间和资源，但拥有自己的调用堆栈、寄存器和程序计数器。</p>
<p>2、线程间它们共享相同的内存空间。所以线程崩溃会影响比较大（进程崩溃、资源泄露、数据不一致等）。</p>
<p>3、创建、销毁或切换线程的开销比进程小。</p>
</li>
<li><p>主要区别</p>
<p>1、<strong>独立性</strong>：进程是独立的，它们拥有自己的地址空间和资源；而线程是进程内的轻量级实体，它们共享进程的地址空间和资源。</p>
<p>2、<strong>通信</strong>：由于进程之间的隔离，它们之间的通信比线程间的通信更复杂。</p>
<p>3、<strong>开销</strong>：进程的生命周期（创建、切换和销毁）的开销通常比线程大。</p>
<p>4、<strong>数据共享</strong>：线程可以直接访问进程中的数据，因为它们共享相同的地址空间。而进程则需要使用特定的通信机制来共享数据。</p>
</li>
</ul>
<h2 id="多线程进程的优缺点"><a href="#多线程进程的优缺点" class="headerlink" title="多线程进程的优缺点"></a>多线程进程的优缺点</h2><p><strong>多进程优点</strong></p>
<ol>
<li>隔离性、稳定性：进程有<strong>独立内存地址</strong>（虚拟内存），进程崩溃一般不影响其他进程。由	于隔离好所以，进程的一些错误，内存泄漏不会影响其他进程。</li>
<li>通信模型简单：在某些情况下，进程间的通信（如使用管道或消息队列）可能比线程间的同步（如使用锁或条件变量）更简单。</li>
</ol>
<p><strong>多进程缺点</strong></p>
<ol>
<li>开销：创建、维护、终止的开销都比线程大。</li>
<li>通信成本：进程间的通信（IPC）通常比线程间的通信慢，因为它涉及到进程间的上下文切换和数据复制。</li>
<li>资源共享：直接共享内存或资源在进程间更为复杂，通常需要使用共享内存、文件映射或其他方法。</li>
</ol>
<p><strong>多线程优点</strong></p>
<ol>
<li>低开销：创建、维护和终止线程的开销通常比进程小。</li>
<li>共享内存：线程共享同一地址空间，线程间的通信（如通过共享内存）通常比进程间的通信快。简化了数据交换和同步。</li>
<li>效率：上下文切换快。</li>
</ol>
<p><strong>多线程缺点</strong></p>
<ol>
<li>安全性：由于线程共享内存和资源，可能会导致并发问题，如数据竞争、死锁等。</li>
<li>稳定性：一个线程中的错误（如对无效内存的访问）可能会影响同一进程中的所有其他线程。</li>
<li>复杂的同步机制：在多线程程序中确保线程安全通常需要复杂的同步机制，如锁、信号量、条件变量等。</li>
</ol>
<h2 id="线程进程什么时候使用"><a href="#线程进程什么时候使用" class="headerlink" title="线程进程什么时候使用"></a>线程进程什么时候使用</h2><p><strong>进程：</strong></p>
<ol>
<li>隔离性：需要确保任务都在彼此隔离的环境运行。</li>
<li>稳定性：希望进程崩溃不影响其他的进程。</li>
<li>不同地址空间：需要运行的任务有独立的内存地址空间，比如隔离的子系统（沙箱应用）。</li>
<li>简化编程模型：对于某些应用，使用进程和进程间通信（如消息传递）可能比多线程和锁编程更简单。</li>
<li>安全性：特定的安全应用可能要求使用多进程来隔离敏感操作，以防止潜在的内存篡改或泄露。</li>
<li>CPU密集型任务：对于分布在多个核心或计算机上的CPU密集型任务，使用进程可以更容易地实现并行计算，特别是当任务之间的通信较少时。</li>
</ol>
<p><strong>线程：</strong></p>
<ol>
<li>共享内存：任务需要频繁地访问和修改共享的数据结构，线程比较好，因为线程共享地址空间。</li>
<li>低延迟通信：线程间的通信（如通过条件变量或共享内存）通常比进程间的通信快。</li>
<li>轻量级并发：如需要大量并发任务，但每个任务的计算和内存需求都相对较小，线程的低的开销可能比较好。</li>
<li>紧密交互任务：如果应用的不同组件需要紧密交互和同步，使用线程可能会更为简单和高效。</li>
<li>资源限制：在资源受限的环境中，线程可能由于其较小的开销而更为合适。</li>
<li>IO密集型任务：许多I&#x2F;O密集型任务（如网络服务或数据库查询），使用多线程可以更有效地管理并发，因为在等待I&#x2F;O操作完成时，其他线程可以继续执行。</li>
</ol>
<h2 id="多进程间通讯"><a href="#多进程间通讯" class="headerlink" title="多进程间通讯"></a>多进程间通讯</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>匿名管道：通信范围是存在父子关系的进程。</p>
<p>命名管道：不相关的进程间也能相互通信。</p>
<p>优点：</p>
<ol>
<li>简单：管道的接口和相对简单，易于使用。</li>
<li>数据流式传输：管道为数据提供了一个流式接口，这使得读&#x2F;写操作变得简单。</li>
<li>对于父子进程或兄弟进程之间的通信，管道通常提供了足够的速度和效率。</li>
<li>和标准输入输出结合：管道可以很容易地与进程的标准输入和输出结合使用，这在shell编程中特别有用，如<code>command1 | command2</code>。（可以在程序中，使用shell的指令，并解析指令）</li>
</ol>
<p>缺点：</p>
<ol>
<li>单项通信，不支持广播等多路通信。</li>
<li>缓冲区大小限制，管道满时候会阻塞。</li>
<li>总的来说通信效率低，不适合进程间频繁交换数据</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​	<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>优点：</p>
<ol>
<li>程序解耦，发送者和接受者程序解耦，互不影响。</li>
<li>支持优先级消息。</li>
<li>持久性~</li>
</ol>
<p>缺点：</p>
<ol>
<li>通信不及时，异步。</li>
<li>大小有限制，小队列长度和队列总大小都有限制。不适合大数据传输。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</li>
<li>高吞吐场景效率不如其他IPC机制（共享内存）效率高。</li>
<li>消息队列通信时候，存在用户态和内核态的数据拷贝开销。</li>
</ol>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>​	<strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process1.png" alt="共享内存"></p>
<p>优点：</p>
<ol>
<li>高效：IPC机制中最快的，直接内存中访问数，无数据复制开销。</li>
<li>容量大：相比消息队列和管道，共享内存通常可以容纳更大的数据量。</li>
<li>灵活：可以使用任何数据结构（如数组、哈希表或其他）。</li>
<li>多进程并发访问：多个进程可以同时读写共享内存。</li>
</ol>
<p>缺点：</p>
<ol>
<li>同步：多进程并发访问会导致竞争，须使用信号量或互斥等同步机制确保数据完整性。</li>
<li>复杂：与消息队列或管道相比，共享内存更加复杂，尤其是考虑到同步和并发访问时。</li>
<li>安全：由于直接内存访问，进程可能会不小心破坏其他进程的数据或状态。</li>
<li>持久性：共享内存通常不是持久的。一旦所有进程都分离或结束，共享内存段通常会被系统自动删除。</li>
</ol>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​	为了防止多进程竞争共享资源，而造成的数据错乱，需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。<strong>信号量</strong>就实现了这一保护机制。</p>
<p>​	<strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>信号量使用方法简单分为两种。如图。</p>
<p>1、互斥使用</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process2.png" alt="互斥使用"></p>
<p>2、同步使用</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process3.png" alt="同步使用"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>​	上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>​	在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 SIGINT 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
<p>​		在C++中，信号是一种特殊的事件，通常是由操作系统产生的，用于通知进程某些特定类型的事件已经发生，例如：尝试除以零、尝试访问无效内存、外部进程请求进程终止等。当这些事件发生时，操作系统会中断进程的正常流程，先处理这些信号，然后可能返回正常的执行或终止进程。</p>
<p>​		虽然信号提供了一种处理异常和其他事件的方法，但通常不建议使用它们来处理程序逻辑。信号最好用作他们原本的目的：响应操作系统发送的异常或事件。对于复杂的事件处理或进程间通信，使用其他IPC机制或事件处理库通常更为合适。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>​		若需要跨越不同主机进行进程间通信，据需要Socket通信了。实际上Socket也可以在同一个主机上进行进程间通信。我们来看看创建 socket 的系统调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocal)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li>
<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li>
<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li>
</ul>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p><strong>接下来，简单说一下这三种通信的编程模式。</strong></p>
<p>​	针对 TCP 协议通信的 socket 编程模型</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process4.png" alt="TCP"></p>
<ul>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<p>针对 UDP 协议通信的 socket 编程模型</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process5.png" alt="UDP"></p>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
<p>针对本地进程间通信的 socket 编程模型</p>
<p>本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p>
<ul>
<li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li>
<li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li>
</ul>
<p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p>
<p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p>
<p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>
<h2 id="多线程冲突"><a href="#多线程冲突" class="headerlink" title="多线程冲突"></a>多线程冲突</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>​		<strong>互斥（mutualexclusion），也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</strong>，说白了，就是这段代码执行过程中，最多只能出现一个线程。</p>
<p>​		互斥在多线程、多进程竞争共享资源时候同样适用。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​		<strong>同步（synchronization），就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。</strong>即b执行需要先等待a完成。</p>
<ul>
<li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li>
<li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；</li>
</ul>
<h3 id="互斥、同步的实现和使用"><a href="#互斥、同步的实现和使用" class="headerlink" title="互斥、同步的实现和使用"></a>互斥、同步的实现和使用</h3><p>​		其实就是使用好信号量、互斥量、原子操作。此处不展开。请看其他章节介绍。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h4><p>​		互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p>
<p>​		比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process6.png" alt="产生互斥的条件关系图"></p>
<h4 id="请求保持条件"><a href="#请求保持条件" class="headerlink" title="请求保持条件"></a>请求保持条件</h4><p>​		当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process7.png" alt="请求保持条件"></p>
<p>​		破局：一次申请全部条件，不逐个获取。</p>
<h4 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h4><p>​		不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process8.png" alt="不可剥夺条件"></p>
<p>​		破局：当进程发现资源被其他进程占用，释放自己已获得的资源。</p>
<h4 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h4><p>​		环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p>
<p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p>
<p><img src="/picture/tech/linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/Thread_of_process9.png" alt="环路等待条件"></p>
<h2 id="并发，同步，异步，互斥，阻塞，非阻塞的理解"><a href="#并发，同步，异步，互斥，阻塞，非阻塞的理解" class="headerlink" title="并发，同步，异步，互斥，阻塞，非阻塞的理解"></a>并发，同步，异步，互斥，阻塞，非阻塞的理解</h2><h3 id="1、什么是线程同步和互斥"><a href="#1、什么是线程同步和互斥" class="headerlink" title="1、什么是线程同步和互斥"></a>1、什么是线程同步和互斥</h3><p>​		线程同步和互斥都是多线程编程中常见的概念，用于确保数据的完整性和准确性，以及保证多个线程之间的有序执行。</p>
<p><strong>线程同步：</strong></p>
<p>​		线程同步是指多个线程按照特定的顺序执行某些任务，以确保数据的准确性和完整性。这通常是为了防止多个线程同时访问共享资源，或确保某些任务按照预期的顺序执行。如（信号量、条件变量）。</p>
<p><strong>互斥：</strong></p>
<p>​		互斥（或互斥锁）是一种同步机制，确保任何时候只有一个线程能够访问特定的代码段或资源。互斥是为了防止多个线程同时修改共享资源，从而可能导致数据的不一致状态。</p>
<p><strong>区别：</strong></p>
<ul>
<li><strong>互斥</strong>重点关注确保任何时候只有一个线程可以访问特定的资源或代码段。</li>
<li><strong>同步</strong>更加广泛，除了互斥外，它还涉及确保线程按预期的顺序执行，等待条件等。</li>
</ul>
<h3 id="2、线程同步与阻塞的关系"><a href="#2、线程同步与阻塞的关系" class="headerlink" title="2、线程同步与阻塞的关系"></a>2、线程同步与阻塞的关系</h3><p>​		线程同步和阻塞是多线程编程中的两个概念，它们经常在一起使用，但它们的意义是不同的。</p>
<p><strong>线程同步：</strong></p>
<p>​		线程同步涉及到协调多个线程，以确保它们以适当和预期的方式访问共享资源或执行任务。同步通常用于防止多个线程同时访问共享资源，从而可能导致不一致的数据状态。</p>
<p><strong>线程阻塞</strong>：</p>
<p>​		线程阻塞是指线程在等待某个条件成真时停止执行。这可能是由于等待资源可用、等待其他线程完成工作或其他原因。在阻塞状态下，线程不会执行任何操作，直到被唤醒。</p>
<p><strong>同步一定阻塞吗？</strong></p>
<p>​		不一定。虽然许多同步机制会导致线程阻塞（例如，当一个线程尝试获取已被其他线程持有的互斥锁时），但有些同步策略不涉及阻塞。例如，”spinlocks”（自旋锁）是一种线程在等待获取锁时持续检查（自旋）的同步方法，而不是真正的阻塞。</p>
<p><strong>阻塞一定同步吗？</strong></p>
<p>​		不一定。线程可以因多种原因而被阻塞，不仅仅是为了同步目的。例如，线程可能因为等待I&#x2F;O操作完成、等待外部事件或只是调用<code>sleep</code>函数而被阻塞。</p>
<h3 id="3、并发"><a href="#3、并发" class="headerlink" title="3、并发"></a>3、并发</h3><ul>
<li>描述了系统或应用程序同时处理多个任务的能力。</li>
<li>注意并发不一定意味着这些任务是“同时”执行的。它可能是通过快速在任务之间切换来模拟同时执行（如单核CPU上的多线程）。</li>
</ul>
<h3 id="4、总结："><a href="#4、总结：" class="headerlink" title="4、总结："></a>4、总结：</h3><p>​		<strong>并发</strong>描述了多任务处理的情境，不一定需要多个任务同时执行。</p>
<p>​		<strong>同步</strong>和<strong>阻塞</strong>经常在一起使用，并且它们在许多情况下都是相互关联的，但它们描述的是不同的概念。同步涉及到协调多个线程的行为，而阻塞描述了线程的一种非活动状态。不是所有的同步操作都导致线程阻塞，同样，不是所有的阻塞操作都是为了同步目的。</p>
<p>​		<strong>互斥</strong>是一种同步机制，确保对共享资源的独占访问。</p>
<h2 id="孤儿进程、僵尸进程、守护进程的概念"><a href="#孤儿进程、僵尸进程、守护进程的概念" class="headerlink" title="孤儿进程、僵尸进程、守护进程的概念"></a>孤儿进程、僵尸进程、守护进程的概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><strong>孤儿进程 (Orphan Process)</strong>:<ul>
<li><strong>基本</strong>: 当一个父进程在其子进程之前结束时，这些子进程会成为孤儿进程。</li>
<li><strong>概念</strong>: 孤儿进程不再有一个父进程与之关联，但它们仍然在执行。在父进程结束后，孤儿进程的父进程ID(PID)会被设置为1，这意味着它们被init进程（或在某些系统上是systemd进程）“收养”。init进程会周期性地回收完成的孤儿进程，从而防止它们成为僵尸进程。</li>
</ul>
</li>
<li><strong>僵尸进程 (Zombie Process)</strong>:<ul>
<li><strong>基本</strong>: 当一个子进程完成其执行并退出，但父进程尚未回收它的终止状态时，该子进程称为僵尸进程。</li>
<li><strong>概念</strong>: 僵尸进程实际上不消耗任何系统资源（如CPU和内存），但仍会在进程表中保留一个条目。这是为了保留子进程的退出状态，以便父进程可以随后查询。僵尸进程存在的问题是，如果生成了大量的僵尸进程且它们未被清除，可能会导致进程表满，从而无法创建新的进程。通常，父进程通过调用<code>wait()</code>或<code>waitpid()</code>函数来回收子进程的状态并清除僵尸进程。</li>
</ul>
</li>
<li><strong>守护进程 (Daemon Process)</strong>:<ul>
<li><strong>基本</strong>: 守护进程是一种在后台运行的进程，通常用于提供某种服务或功能，如日志记录、网络服务等。</li>
<li><strong>概念</strong>: 守护进程通常在系统启动时启动，并持续运行，直到系统关闭。它们不与终端或用户会话关联，并且经常将其父进程设置为init进程（PID 1）。守护进程通常不直接与用户交互，而是通过文件、套接字或其他守护进程进行通信。</li>
</ul>
</li>
</ol>
<h3 id="如何创建守护进程"><a href="#如何创建守护进程" class="headerlink" title="如何创建守护进程"></a>如何创建守护进程</h3><p>​		Linux系统中，创建守护进程涉及一系列步骤，以确保该进程完全在后台运行，与任何终端或用户会话无关，并正确处理资源和信号。</p>
<ol>
<li><strong>创建新的进程</strong>: 使用<code>fork()</code>创建新进程并终止父进程。</li>
<li><strong>创建新的会话</strong>: 使用<code>setsid()</code>为新进程创建新的会话。</li>
<li><strong>更改当前工作目录</strong>: 通常更改为根目录，确保守护进程不会锁定任何文件系统。</li>
<li><strong>关闭所有打开的文件描述符</strong>。</li>
<li><strong>重新打开标准输入、输出、错误描述符</strong>，通常重定向到&#x2F;dev&#x2F;null。</li>
<li><strong>处理信号</strong>: 例如，处理SIGHUP以重新读取配置</li>
</ol>
<p>此代码创建一个守护进程，它仅在后台运行并每60秒执行一个操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// Step 1: Fork off the parent process</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 2: Create a new session</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsid</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ignore signals</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP, SIG_IGN);</span><br><span class="line">    <span class="comment">// Step 3: Fork again to ensure the daemon is not a session leader</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 4: Change working directory</span></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="comment">// Step 5: Close all open file descriptors</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="built_in">sysconf</span>(_SC_OPEN_MAX); x &gt;= <span class="number">0</span>; x--) &#123;</span><br><span class="line">        <span class="built_in">close</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Reopen stdin, stdout, stderr</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dup</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">daemonize</span>();</span><br><span class="line">    <span class="comment">// Daemon process logic starts here</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Your daemon code here</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何处理僵尸进程"><a href="#如何处理僵尸进程" class="headerlink" title="如何处理僵尸进程"></a>如何处理僵尸进程</h3><p>​		僵尸进程本身并不消耗任何系统资源（除了进程表中的一个条目），但如果大量的僵尸进程没有被清除，进程表可能会填满，从而导致系统无法创建新的进程。</p>
<p>以下是处理僵尸进程的几种方法：</p>
<ol>
<li><p><strong>使用<code>wait()</code>或<code>waitpid()</code>函数</strong>:</p>
<ul>
<li>父进程可以通过调用<code>wait()</code>或<code>waitpid()</code>函数来回收已完成的子进程的终止状态。这将从进程表中删除对应的子进程条目，从而防止它们成为僵尸进程。</li>
</ul>
</li>
<li><p><strong>处理<code>SIGCHLD</code>信号</strong>:</p>
<ul>
<li>当子进程终止时，操作系统会向其父进程发送一个<code>SIGCHLD</code>信号。父进程可以捕获这个信号并调用<code>wait()</code>或<code>waitpid()</code>来回收子进程的状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cCopy codevoid sigchld_handler(int signo) &#123;</span><br><span class="line">    while (waitpid(-1, NULL, WNOHANG) &gt; 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGCHLD, sigchld_handler);</span><br></pre></td></tr></table></figure>

<p><code>WNOHANG</code>标志使<code>waitpid()</code>在没有子进程终止时立即返回，从而允许处理器函数清除所有僵尸进程。</p>
</li>
<li><p><strong><code>double fork</code>技巧</strong>:</p>
<ul>
<li>父进程首先<code>fork</code>一个子进程，然后立即等待它终止。而这个子进程再<code>fork</code>另一个子进程并立即终止。这样，第二个子进程将被init进程（或在某些系统上是systemd进程）“收养”，并且当它终止时，init进程将负责清除其状态，从而确保它不会成为僵尸进程。</li>
</ul>
</li>
<li><p><strong>使子进程脱离父进程</strong>:</p>
<ul>
<li>子进程可以调用<code>setsid()</code>函数来开始一个新的会话，并与其父进程断开连接。这样，子进程将不再有父进程，因此在终止时不会成为僵尸进程。</li>
</ul>
</li>
</ol>
<p>总之，为了避免僵尸进程，重要的是父进程应该负责回收其所有已完成的子进程的状态，或者确保有其他机制来完成这项工作。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】U-BOOT启动流程</title>
    <url>/blog/Rk3568Uboot/</url>
    <content><![CDATA[<h1 id="【RK3568】U-BOOT启动流程"><a href="#【RK3568】U-BOOT启动流程" class="headerlink" title="【RK3568】U-BOOT启动流程"></a>【RK3568】U-BOOT启动流程</h1><p>RK平台的U-Boot 启动流程如下，仅列出⼀些重要步骤：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">start.s</span><br><span class="line">    <span class="comment">// 汇编环境</span></span><br><span class="line">    =&gt; IRQ/FIQ/lowlevel/vbar/errata/cp15/gic	<span class="comment">// ARM架构相关的lowlevel初始化</span></span><br><span class="line">    =&gt; _main</span><br><span class="line">        =&gt; stack 								<span class="comment">// 准备好C环境需要的栈</span></span><br><span class="line">        <span class="comment">// 【第⼀阶段】C环境初始化，发起⼀系列的函数调⽤</span></span><br><span class="line">            =&gt; board_init_f: init_sequence_f[]</span><br><span class="line">            initf_malloc</span><br><span class="line">            arch_cpu_init 						<span class="comment">// 【SoC的lowlevel初始化】</span></span><br><span class="line">            serial_init 						<span class="comment">// 串口初始化</span></span><br><span class="line">            dram_init 							<span class="comment">// 【获取ddr容量信息】</span></span><br><span class="line">            reserve_mmu 						<span class="comment">// 从ddr末尾开始往低地址reserve内存</span></span><br><span class="line">            reserve_video</span><br><span class="line">            reserve_uboot</span><br><span class="line">            reserve_malloc</span><br><span class="line">            reserve_global_data</span><br><span class="line">            reserve_fdt</span><br><span class="line">            reserve_stacks</span><br><span class="line">            dram_init_banksize</span><br><span class="line">            sysmem_init</span><br><span class="line">            setup_reloc 						<span class="comment">// 确定U-Boot⾃⾝要reloc的地址</span></span><br><span class="line">        <span class="comment">// 汇编环境</span></span><br><span class="line">        =&gt; relocate_code 						<span class="comment">// 汇编实现U-Boot代码的relocation</span></span><br><span class="line">        <span class="comment">// 【第⼆阶段】C环境初始化，发起⼀系列的函数调⽤</span></span><br><span class="line">        =&gt; board_init_r: init_sequence_r[]</span><br><span class="line">            initr_caches 						<span class="comment">// 使能MMU和I/Dcache</span></span><br><span class="line">            initr_malloc</span><br><span class="line">            bidram_initr</span><br><span class="line">            sysmem_initr</span><br><span class="line">            initr_of_live 						<span class="comment">// 初始化of_live</span></span><br><span class="line">            initr_dm 							<span class="comment">// 初始化dm框架</span></span><br><span class="line">            board_init 							<span class="comment">// 【平台初始化，最核⼼部分】</span></span><br><span class="line">            board_debug_uart_init 				<span class="comment">// 串口iomux、clk配置</span></span><br><span class="line">            init_kernel_dtb 					<span class="comment">// 【切到kernel dtb】！</span></span><br><span class="line">            clks_probe 							<span class="comment">// 初始化系统频率</span></span><br><span class="line">            regulators_enable_boot_on 			<span class="comment">// 初始化系统电源</span></span><br><span class="line">            io_domain_init 						<span class="comment">// io-domain初始化</span></span><br><span class="line">            set_armclk_rate 					<span class="comment">// __weak，ARM提频(平台有需求才实现)</span></span><br><span class="line">            dvfs_init 							<span class="comment">// 宽温芯⽚的调频调压</span></span><br><span class="line">            rk_board_init 						<span class="comment">// __weak，由各个具体平台进⾏实现</span></span><br><span class="line">            console_init_r</span><br><span class="line">            board_late_init 					<span class="comment">// 【平台late初始化】</span></span><br><span class="line">            rockchip_set_ethaddr 				<span class="comment">// 设置mac地址</span></span><br><span class="line">            rockchip_set_serialno 				<span class="comment">// 设置serialno</span></span><br><span class="line">            setup_boot_mode 					<span class="comment">// 解析&quot;reboot xxx&quot;命令、</span></span><br><span class="line">            									<span class="comment">// 识别按键和loader烧写模式、recovery</span></span><br><span class="line">            charge_display 						<span class="comment">// U-Boot充电</span></span><br><span class="line">            rockchip_show_logo 					<span class="comment">// 显⽰开机logo</span></span><br><span class="line">            soc_clk_dump 						<span class="comment">// 打印clk tree</span></span><br><span class="line">            rk_board_late_init 					<span class="comment">// __weak，由各个具体平台进⾏实现</span></span><br><span class="line">            run_main_loop 						<span class="comment">// 【进⼊命令⾏模式，或执⾏启动命令】</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】Buildroot开发</title>
    <url>/blog/Rk3568Buildroot/</url>
    <content><![CDATA[<h1 id="【RK3568】Buildroot开发"><a href="#【RK3568】Buildroot开发" class="headerlink" title="【RK3568】Buildroot开发"></a>【RK3568】Buildroot开发</h1><h1 id="Buildroot目录介绍"><a href="#Buildroot目录介绍" class="headerlink" title="Buildroot目录介绍"></a>Buildroot目录介绍</h1><table>
<thead>
<tr>
<th align="center">说明</th>
<th align="center">顶层目录名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">arch</td>
<td align="center">存放 buildroot 支持的所有 CPU 架构相关的配置文件及构建脚本</td>
</tr>
<tr>
<td align="center">board</td>
<td align="center">存放特定目标平台相关的文件，譬如内核配置或补丁文件、rootfs覆盖文件等</td>
</tr>
<tr>
<td align="center">boot</td>
<td align="center">存放 buildroot 支持的 BootLoader 相关的补丁、校验文件、构建脚本、配置选项等</td>
</tr>
<tr>
<td align="center">build</td>
<td align="center">Buildroot 编译系统相关组件configs 存放了所有目标平台的</td>
</tr>
<tr>
<td align="center">configs</td>
<td align="center">存放了所有目标平台的 defconfig 配置文件</td>
</tr>
<tr>
<td align="center">dl</td>
<td align="center">download 的缩写，该目录用于存放下载的各种开源软件包，譬如alsa-lib 库、bluez 库、bzip2、curl 工具等；在编译过程中，buildroot会从网络下载所需软件包、并将其放置在 dl&#x2F;目录下；如果 buildroot下载某软件包时失败、无法下载成功，此时我们也可以自己手动下载该软件包、并将其拷贝至 dl 目录下。所有软件包只需下载一次即可，不是每次编译都要下载一次（除非删除 dl 目录），只要 dl 目录下存在该软件包就不用下载了；所以往往第一次编译会比较慢，因为下载过程会占用很多时间</td>
</tr>
<tr>
<td align="center">docs</td>
<td align="center">存放相关的参考文档</td>
</tr>
<tr>
<td align="center">fs</td>
<td align="center">存放各种文件系统的源代码</td>
</tr>
<tr>
<td align="center">linux</td>
<td align="center">存放 linux 的构建脚本和配置选项</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">该文件夹会在编译 buildroot 后出现，output 目录用于存放编译过程中输出的各种文件，包括各种编译生成的中间目标文件、可执行文件、lib 库以及最终烧录到开发板的 rootfs 镜像等</td>
</tr>
<tr>
<td align="center">package</td>
<td align="center">存放所有 package（软件包）的构建脚本、配置选项；每个软件包目录下（package&#x2F;<package_name>&#x2F;）都有一个 Config.in 文件和<package_name>.mk 文件（其实就是 Makefile 文件）；如果需要添加一个新的 package，则需对 package&#x2F;目录进行改动。</td>
</tr>
<tr>
<td align="center">support</td>
<td align="center">存放一些为 buildroot 提供功能支持的脚本、配置文件等</td>
</tr>
<tr>
<td align="center">to loc ha in</td>
<td align="center">存放制作各种交叉编译工具链的构建脚本和相关文件，binutils、gcc、gdb、kernel-header 和 uClibc</td>
</tr>
<tr>
<td align="center">utils</td>
<td align="center">存放一些 buildroot 的实用脚本和工具</td>
</tr>
</tbody></table>
<h1 id="常见编译指令"><a href="#常见编译指令" class="headerlink" title="常见编译指令"></a>常见编译指令</h1><p>在buildroot跟目录下可以直接使用make命令编译buildroot，也可以单独指定packge进行编译，具体见make help提示。</p>
<h2 id="编译跟文件系统"><a href="#编译跟文件系统" class="headerlink" title="编译跟文件系统"></a>编译跟文件系统</h2><p>编译之前，先进行配置；进入到 buildroot 目录下，执行如下命令进行配置（以 rk3568 平台为例）：</p>
<blockquote>
<p>source build&#x2F;envsetup.sh rockchip_rk3568</p>
</blockquote>
<p>命令中最后一个参数（rockchip_rk3568）用于指定目标平台的 defconfig 配置文件（不带  _defconfig  后缀），所有目标平台的 defconfig 配置文件都存放在<Buildroot>&#x2F;configs** 目录下，在</p>
<p>该目录下可以找到 rk3568 的配置文件 <strong>rockchip_rk3568_defconfig</strong>，如下所示：</p>
<p><img src="/picture/tech/buildroot/buidroot1.png" alt="配置文件"></p>
<p>配置后直接：</p>
<blockquote>
<p>make 或 make all  </p>
<p>make -j20 或 make all -j20 </p>
</blockquote>
<h2 id="编译package"><a href="#编译package" class="headerlink" title="编译package"></a>编译package</h2><p>编译之前，先进行配置。进入到 buildroot 目录下，执行如下命令进行配置（以 rk3568 平台为例）：</p>
<blockquote>
<p>source build&#x2F;envsetup.sh rockchip_rk3568</p>
</blockquote>
<p>配置完成后，执行如下命令编译指定的 package：</p>
<blockquote>
<p>make <package_name></p>
</blockquote>
<p>参数<package_name>用于指定 package 的名字，譬如 myh_package：</p>
<blockquote>
<p>make myh_package</p>
</blockquote>
<h2 id="Buildroot清除"><a href="#Buildroot清除" class="headerlink" title="Buildroot清除"></a>Buildroot清除</h2><p>执行如下可删除所有构建生成的文件（包括 build、host、staging and target trees、images 和 toolchain）：</p>
<blockquote>
<p>make clean</p>
</blockquote>
<p>执行如下命令可删除所有构建时生成的文件以及相关配置（彻底清除，相当于删除 output目录）：</p>
<blockquote>
<p>make distclean</p>
</blockquote>
<p>执行如下命令可删除指定 package 的构建目录：</p>
<blockquote>
<p>make <package_name>-dirclean</p>
</blockquote>
<h1 id="添加Package详解"><a href="#添加Package详解" class="headerlink" title="添加Package详解"></a>添加Package详解</h1><p> package_name 对应的便是 buildroot&#x2F;package&#x2F;文件夹中的某个目录对应的名字（或某个子目录对应的名字），并且该目录中存在 Config.in 配置文件（用于定义 package 配置选项）以及<package_name>.mk 文件（Makefile 文件，用于定义 package 的构建逻辑）。比如：</p>
<blockquote>
<p>rkwifibt       → 	package&#x2F;rockchip&#x2F;rkwifibt&#x2F;</p>
<p>rknpu          → 	package&#x2F;rockchip&#x2F;rknpu&#x2F;</p>
<p>rkupdate	→ 	package&#x2F;rockchip&#x2F;rkupdate&#x2F;</p>
</blockquote>
<p>package（软件包）的构建过程可以分解为：configure（配置）、build（编译）、install（安装），其执行顺序为：<strong>配置</strong>→<strong>编译</strong>→<strong>安装</strong>，每一步可单独执行，执行如下命令：</p>
<blockquote>
<p>make <package_name>-configure     #执行配置命令</p>
<p>make <package_name>-build             #执行编译命令</p>
<p>make <package_name>-install            #执行安装命令</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>utils&#x2F;brmake <package_name>-configure   #执行配置命令</p>
<p>utils&#x2F;brmake <package_name>-build           #执行编译命令</p>
<p>utils&#x2F;brmake <package_name>-install          #执行安装命令</p>
</blockquote>
<p>以 rkwifibt 为例：</p>
<blockquote>
<p>utils&#x2F;brmake rkwifibt-configure </p>
<p>utils&#x2F;brmake rkwifibt-build         </p>
<p>utils&#x2F;brmake rkwifibt-install      </p>
</blockquote>
<p>与之对应的还有：reconfigure（重新配置）、rebuild（重新编译）、reinstall（重新安装）：</p>
<blockquote>
<p>make <package_name>-reconfigure   #从配置阶段开始，重新启动 package 的构建过程</p>
<p>make <package_name>-rebuild           #从编译阶段开始，重新启动 package 的构建过程</p>
<p>make <package_name>-reinstall         #从安装阶段开始，重新启动 package 的构建过程</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>utils&#x2F;brmake <package_name>-reconfigure  #从配置阶段开始，重新启动 package 的构建过程</p>
<p>utils&#x2F;brmake <package_name>-rebuild          #从编译阶段开始，重新启动 package 的构建过程</p>
<p>utils&#x2F;brmake <package_name>-reinstall        #从安装阶段开始，重新启动 package 的构建过程</p>
</blockquote>
<p>以 rkwifibt 为例：</p>
<blockquote>
<p>utils&#x2F;brmake rkwifibt-reconfigure </p>
<p>utils&#x2F;brmake rkwifibt-rebuild        </p>
<p>utils&#x2F;brmake rkwifibt-reinstall       </p>
</blockquote>
<h1 id="添加package"><a href="#添加package" class="headerlink" title="添加package"></a>添加package</h1><ol>
<li>添加代码，编写makefile&#x2F;cmake。</li>
<li>Buildroot&#x2F;package目录下创建目录，并在其中编写Config.in和mypackage.mk。</li>
<li>修改package&#x2F;Config.in，添加mypackage。</li>
<li>mkae menuconfig 在Target packages中使能mypackage。</li>
<li>执行make mypackage-rebuild&#x2F;make mypackage。</li>
</ol>
<p>随后可执行文件会生成在output&#x2F;rockchip_rk3568&#x2F;target&#x2F;usr&#x2F;bin目录。编译烧写rootfs到板子即可使用。</p>
<p><img src="/picture/tech/buildroot/buidroot2.png" alt="生成的package文件"></p>
<h1 id="编译RK3568根文件系统镜像rootfs-img"><a href="#编译RK3568根文件系统镜像rootfs-img" class="headerlink" title="编译RK3568根文件系统镜像rootfs.img"></a>编译RK3568根文件系统镜像rootfs.img</h1><ol>
<li>配置defconfig：source build&#x2F;envsetup.sh rockchip_rk3568</li>
<li>make -j20 或 make all -j20 或 utils&#x2F;brmake -j20</li>
</ol>
<p>命令中最后一个参数（rockchip_rk3568）用于指定目标平台的 defconfig 配置文件（不带**_defconfig** 后缀），目标平台的 defconfig 配置文件都存放在**<Buildroot>&#x2F;configs** 目录下，在该目录下可以找到 rk3568 的配置文件 <strong>rockchip_rk3568_defconfig</strong>。编译成功后会输出到output目录。</p>
<h1 id="output目录介绍"><a href="#output目录介绍" class="headerlink" title="output目录介绍"></a>output目录介绍</h1><p>output&#x2F;</p>
<p>├── rockchip_rk3568</p>
<p>├── build #包含所有构建的软件包，包括 buildroot 在宿主机上所需的工具以及为目标平台编译的软件包</p>
<p>├── host #包含为 Ubuntu 主机（宿主机）构建的工具，以及目标工具链</p>
<p>├── images #存放最终编译输出的镜</p>
<p>├── Makefile</p>
<p>├── staging #一个指向 host&#x2F;目录中目标工具链 sysroot 的符号链接</p>
<p>└── target #根文件系统系统目录，用来创建根文件系统镜像，rootfs.img 镜像的内容就是该目录下的内容</p>
]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】U盘锁</title>
    <url>/blog/Rk3568Upan/</url>
    <content><![CDATA[<p>【RK3568】U盘锁</p>
<p>创建一个USB锁系统需要涉及到几个方面的技术：USB设备检测、文件读取、数据校验和权限管理。对于隐蔽性和安全性，还需要加密和代码保护措施。</p>
<h1 id="USB设备检测"><a href="#USB设备检测" class="headerlink" title="USB设备检测"></a>USB设备检测</h1><p>检测USB设备，首先要建立一个udev规则，当usb设备连接或者断开时候，执行某脚本。</p>
<p>在&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;目录下创建1-lock.rules，名字可随意。</p>
<p>为规则添加内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ACTION==<span class="string">&quot;add&quot;</span>, KERNEL==<span class="string">&quot;sda1&quot;</span>, ATTR&#123;idVendor&#125;==<span class="string">&quot;0781&quot;</span>, ATTR&#123;idProduct&#125;==<span class="string">&quot;5530&quot;</span>, RUN+=<span class="string">&quot;/opt/apps/src/lock/lock_in.sh&quot;</span></span><br><span class="line">ACTION==<span class="string">&quot;remove&quot;</span>, KERNEL==<span class="string">&quot;sda1&quot;</span>, ATTR&#123;idVendor&#125;==<span class="string">&quot;0781&quot;</span>, ATTR&#123;idProduct&#125;==<span class="string">&quot;5530&quot;</span>, RUN+=<span class="string">&quot;/opt/apps/src/lock/lock_out.sh&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中KERNEL是U盘的磁盘名字。</p>
<p>ATTR{idVendor}和ATTR{idProduct}代表U盘的ID，可通过lsusb指令查看。如下：</p>
<p><img src="/picture/tech/u%E7%9B%98%E9%94%81/upan_lock1.png" alt="lsusb查看U盘"></p>
<h1 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h1><p>随后前往&#x2F;opt&#x2F;apps&#x2F;src&#x2F;lock&#x2F;目录编写lock_in.sh、lock_out.sh脚本</p>
<p>此处脚本仅实现最简单的，挂载U盘，读取U盘lockPassword.txt和本地password.txt中password:”xxx”,的xxx字符进行匹配，若匹配则成功，失败则退出。</p>
<p>脚本执行时候是后台执行，所以无法交互输入，我使用了在password.txt中填写密码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># lock_in.sh</span></span><br><span class="line"><span class="comment"># Configuration</span></span><br><span class="line">BASE_DIR=<span class="string">&quot;<span class="subst">$(cd <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span></span><br><span class="line">LOGFILE=<span class="string">&quot;<span class="variable">$BASE_DIR</span>/lock_in.log&quot;</span></span><br><span class="line">MOUNT_POINT=<span class="string">&quot;/mnt/usbLock&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;/dev/sda1&quot;</span></span><br><span class="line">LOCAL_PASSWORD_FILE=<span class="string">&quot;<span class="variable">$BASE_DIRpassword</span>.txt&quot;</span></span><br><span class="line">USB_PASSWORD_FILE=<span class="string">&quot;<span class="variable">$MOUNT_POINT</span>/lockPassword.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Utility Functions</span></span><br><span class="line"><span class="function"><span class="title">log_message</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date)</span>]  <span class="variable">$1</span>&quot;</span> &gt;&gt; <span class="variable">$LOGFILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">extract_password</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> file=<span class="variable">$1</span></span><br><span class="line">    grep -o <span class="string">&#x27;password:&quot;[^&quot;]*&quot;&#x27;</span> <span class="variable">$file</span> | awk -F\&quot; <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main Script Execution</span></span><br><span class="line">log_message <span class="string">&quot;Started script&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check and create mount point if not exists</span></span><br><span class="line">[ ! -d <span class="string">&quot;<span class="variable">$MOUNT_POINT</span>&quot;</span> ] &amp;&amp; <span class="built_in">mkdir</span> -p <span class="variable">$MOUNT_POINT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mount the USB drive</span></span><br><span class="line"><span class="keyword">if</span> ! mount <span class="variable">$DEVICE</span> <span class="variable">$MOUNT_POINT</span>; <span class="keyword">then</span></span><br><span class="line">    log_message <span class="string">&quot;Failed to mount <span class="variable">$DEVICE</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if USB password file exists</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$USB_PASSWORD_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Check if local password file exists</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$LOCAL_PASSWORD_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        local_password=$(extract_password <span class="variable">$LOCAL_PASSWORD_FILE</span>)</span><br><span class="line">        usb_password=$(extract_password <span class="variable">$USB_PASSWORD_FILE</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Log the extracted passwords</span></span><br><span class="line">        log_message <span class="string">&quot;Extracted Local password: <span class="variable">$local_password</span>&quot;</span></span><br><span class="line">        log_message <span class="string">&quot;Extracted USB password: <span class="variable">$usb_password</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compare passwords</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$local_password</span>&quot;</span> == <span class="string">&quot;<span class="variable">$usb_password</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            log_message <span class="string">&quot;Passwords matched&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            log_message <span class="string">&quot;Password mismatch&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        log_message <span class="string">&quot;Local password file <span class="variable">$LOCAL_PASSWORD_FILE</span> not found&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log_message <span class="string">&quot;No lockPassword.txt found on USB drive&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unmount the USB drive</span></span><br><span class="line">umount <span class="variable">$MOUNT_POINT</span></span><br></pre></td></tr></table></figure>

<p>u盘插入后，会自动执行本sh，同时会输出一个log日志，&#x2F;opt&#x2F;apps&#x2F;src&#x2F;lock&#x2F;lock_in.log。如下：</p>
<p>上面是部分是USB插入打印的信息。下部分是log日志。</p>
<p><img src="/picture/tech/u%E7%9B%98%E9%94%81/upan_lock2.png" alt="查看U盘插入打印的信息和日志"></p>
<p>此处例子USB插入未实现处理代码，所以不放出lock_out.sh，各位可根据自己需求来实现。</p>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>上面例子的方式并<strong>不安全</strong>，最好使用加密措施。<strong>简单的</strong>比如使用<strong>OpenSSL</strong>，在u盘lockPassword.txt中存放两个经过AES文本密码加密的字符串。然后在板子password.txt，填写两个字符串的密码。然后使用openssl进行解密对比两者结果，一致则开放权限等。复杂情况不建议使用sh（不好写，可读性差），可以在sh上执行其他脚本，如python脚本或者，c++写的脚本。</p>
]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】高频问题linux系统</title>
    <url>/blog/LinuxSysQues/</url>
    <content><![CDATA[<h1 id="【Linux】高频问题linux系统"><a href="#【Linux】高频问题linux系统" class="headerlink" title="【Linux】高频问题linux系统"></a>【Linux】高频问题linux系统</h1><h3 id="用户空间和内核空间通信的方式有什么"><a href="#用户空间和内核空间通信的方式有什么" class="headerlink" title="用户空间和内核空间通信的方式有什么"></a>用户空间和内核空间通信的方式有什么</h3><p><strong>系统调用：</strong></p>
<p>​		应用程序通过系统调用请求操作系统提供的服务，如文件操作、网络访问、进程控制。例如：<code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> 等。</p>
<p><strong>虚拟文件系统：</strong></p>
<p>​		操作系统提供特定的文件系统接口，允许用户空间应用直接读写这些文件，从而与内核交互。例如，在Linux上，可以通过读写&#x2F;proc<code>和</code>&#x2F;sys中的文件来获取系统信息或修改某些内核参数。</p>
<p><strong>I&#x2F;O 控制 (IOCTL)：</strong></p>
<p>​		<code>ioctl</code> 是一个多用途的系统调用，一般用于设备驱动程序，允许用户空间应用发送命令或请求到驱动程序。它通常用于不适合使用普通系统调用的那些特定的、不常见的设备操作。</p>
<p><strong>信号：</strong></p>
<p>​		内核可以向用户空间进程发送信号，通知它某些事件发生，如终止请求、段错误等。</p>
<p><strong>共享内存：</strong></p>
<p>​		内核可以与用户空间应用共享内存区域，使得它们可以直接读写同一块内存，从而实现高效的数据交换。</p>
<p><strong>消息队列：</strong></p>
<p>​		进程间通信（IPC）机制，允许用户空间应用发送和接收消息。尽管这主要用于用户空间之间的通信，但某些操作系统实现（如Linux的netlink）允许内核和用户空间通过消息队列进行通信。</p>
<p><strong>Socket：</strong></p>
<p>​		尤其是在Linux上，netlink套接字允许用户空间应用与内核空间进行通信，主要用于网络配置和监视。</p>
<p><strong>中断和异常处理：</strong></p>
<p>​		当硬件设备需要注意或发生异常时，内核会接收到中断或异常，并可以选择将相关信息传递给用户空间。</p>
<p><strong>内存映射 (mmap)：</strong></p>
<pre><code>     用户空间应用程序可以使用 `mmap` 系统调用将文件或设备映射到其地址空间。这允许它直接访问内存，从而与内核或其他进程共享数据。
</code></pre>
<p>​	</p>
<h3 id="系统调用read-、write-具体做了什么工作"><a href="#系统调用read-、write-具体做了什么工作" class="headerlink" title="系统调用read()、write()具体做了什么工作"></a>系统调用read()、write()具体做了什么工作</h3><p>​		系统调用<code>read()</code>和<code>write()</code>是POSIX规范定义的基本I&#x2F;O操作，用于从文件或其他I&#x2F;O流中读取数据以及向文件或其他I&#x2F;O流中写入数据。在Linux中，几乎所有的I&#x2F;O操作，包括对普通文件、目录、设备文件、套接字等的操作，都可以使用这两个系统调用。</p>
<p>内核中的操作：**</p>
<p>​		此函数从一个已打开的文件描述符（file descriptor）读取数据。通常，第一次读&#x2F;写操作从文件的当前偏移量开始，并在读&#x2F;写操作之后更新该偏移量。</p>
<ul>
<li>内核的操作：<ol>
<li>验证给定的文件描述符是否有效。</li>
<li>检查是否有权限从给定的文件描述符进行读&#x2F;写。</li>
<li>确定要读&#x2F;写的数据量和位置。</li>
<li>根据文件描述符类型（例如普通文件、套接字、字符设备等）进行特定的读&#x2F;写取操作。</li>
<li>从文件系统缓冲区或设备驱动程序读&#x2F;写数据。</li>
<li>将数据从内核复制到用户空间的缓冲区（或将用户空间缓冲区的数据复制到内核空间）。</li>
<li>更新文件的当前偏移量。</li>
<li>返回读&#x2F;写的字节数。</li>
</ol>
</li>
</ul>
<p>​		这些操作经过了多层抽象，并且可以根据文件类型、文件系统、驱动程序等进行特定的实现。例如，对于普通文件，<code>read()</code>和<code>write()</code>可能会涉及磁盘I&#x2F;O，而对于套接字，它们可能涉及网络I&#x2F;O。</p>
<p>​	</p>
<h3 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h3><p>​		系统调用是操作系统内核提供的一组函数接口，允许用户空间的应用程序请求内核执行特定的操作。这是用户空间程序与内核空间代码进行交互的主要方式。系统调用为应用程序提供了一种方法，使其能够使用由内核管理的资源和服务，如文件操作、进程控制、网络通信等。</p>
<p>系统调用的主要作用包括：</p>
<ol>
<li><strong>抽象硬件</strong>：系统调用为应用程序提供了一个统一的接口，使其可以访问硬件资源，而不必关心底层硬件的具体细节。</li>
<li><strong>提供安全的权限控制</strong>：通过系统调用，操作系统可以限制用户程序的行为，防止其执行潜在危险的操作。例如，一个普通用户程序不能直接重启计算机，但它可以通过系统调用请求这样做，并由内核决定是否允许这种操作。</li>
<li><strong>资源管理</strong>：操作系统负责管理计算机的资源，如CPU、内存、磁盘等。系统调用提供了一种方法，使应用程序能够请求、使用和释放这些资源。</li>
<li><strong>进程控制</strong>：系统调用允许应用程序执行诸如创建、暂停或终止进程，以及进程间通信等任务。</li>
<li><strong>文件操作</strong>：应用程序可以使用系统调用打开、读取、写入和关闭文件，以及执行其他与文件系统相关的操作。</li>
<li><strong>设备操作</strong>：系统调用提供了与外部设备（如打印机、磁盘、网络卡等）交互的能力。</li>
<li><strong>网络通信</strong>：系统调用允许应用程序创建套接字、发送和接收数据包，以及其他与网络通信相关的操作。</li>
<li><strong>时间和计时</strong>：应用程序可以使用系统调用获取系统时间、设置闹钟或延时执行。</li>
<li><strong>查询和设置系统信息</strong>：应用程序可以使用系统调用来查询或修改系统的运行时信息和配置。</li>
</ol>
<p>​        总之，系统调用为应用程序提供了一个受控、安全的抽象接口，使其能够与计算机的硬件和系统资源交互。应用程序可以不管硬件和内核安全的执行其任务。确保资源访问的安全性和系统的稳定性。</p>
<p>​	</p>
<h3 id="内核态和用户态的区别"><a href="#内核态和用户态的区别" class="headerlink" title="内核态和用户态的区别"></a>内核态和用户态的区别</h3><p>​		这两种模式的存在是为了隔离操作系统内核和用户程序，确保系统的稳定性和安全性。</p>
<ol>
<li><strong>权限</strong>:<ul>
<li><strong>内核态 <strong>：CPU可以执行所有的指令和访问所有的内存地址。它拥有对系统资源的</strong>完全访问权限</strong>。</li>
<li><strong>用户态</strong>：CPU的权限受到限制。尝试执行特定的敏感指令或访问受保护的内存区域会触发异常。</li>
</ul>
</li>
<li><strong>错误的影响</strong>:<ul>
<li><strong>内核态</strong>：在内核态下出现的错误通常会导致整个系统崩溃或不稳定。</li>
<li><strong>用户态</strong>：用户态程序出现的错误通常只会影响该程序本身，而不会对整个系统产生影响。</li>
</ul>
</li>
<li><strong>上下文切换</strong>：<ul>
<li>从用户态切换到内核态（或反之）需要上下文切换，这会产生一定的开销。这种切换通常通过系统调用、中断或异常来触发。</li>
</ul>
</li>
<li><strong>应用</strong>：<ul>
<li><strong>内核态</strong>：操作系统内核、设备驱动和其他系统级代码在内核态下运行。</li>
<li><strong>用户态</strong>：应用程序、用户级工具和大多数软件都在用户态下运行。</li>
</ul>
</li>
<li><strong>安全和隔离</strong>：<ul>
<li>通过将操作系统内核放在内核态并将应用程序放在用户态，操作系统可以确保用户程序不会直接访问或修改关键的系统资源和结构。</li>
</ul>
</li>
<li><strong>内存访问</strong>：<ul>
<li><strong>内核态</strong>：可以访问整个物理和虚拟内存，包括硬件的内存映射区域。</li>
<li><strong>用户态</strong>：只能访问特定区域的虚拟内存（进程分配的内存）。尝试访问其他内存区域或执行某些特权指令会导致异常。</li>
</ul>
</li>
<li><strong>系统调用</strong>：<ul>
<li>当用户态程序需要访问系统资源或执行某些只能在内核态完成的操作时，它会通过系统调用进入内核态。完成系统调用后，程序返回到用户态继续执行。</li>
</ul>
</li>
</ol>
<p>​        总之，内核态和用户态的区分是操作系统设计中的一种关键机制，用于确保系统的稳定性、安全性和隔离性。这种分隔使得操作系统能够控制和管理资源，防止恶意或错误的用户程序干扰系统的正常操作。</p>
<p>​	</p>
<h3 id="bootloader、内核和跟文件系统的关系"><a href="#bootloader、内核和跟文件系统的关系" class="headerlink" title="bootloader、内核和跟文件系统的关系"></a>bootloader、内核和跟文件系统的关系</h3><p>​		Bootloader、内核和根文件系统都是操作系统启动过程中的关键组成部分。</p>
<ul>
<li>Bootloader：负责初始化硬件并加载操作系统内核（初始化硬件，比如设置时钟，初始化内存控制器等。加载操作系统内核到 RAM。跳转到内核的执行地址开始执行）。</li>
<li>内核：管理系统的硬件资源，提供程序运行时的各种服务（管理硬件资源，如 CPU、内存、I&#x2F;O 设备等。提供系统调用接口，应用程序通过这些接口请求内核的服务。进程管理，调度，内存管理等。）。</li>
<li>根文件系统：根文件系统包含操作系统和用户程序需要的各种文件（系统配置文件、系统库、用户程序和脚本、设备文件等）。</li>
</ul>
<p><strong>关系：</strong></p>
<ul>
<li><p><strong>Bootloader 到内核</strong>：Bootloader 负责将内核从存储设备加载到内存中，并将控制权转交给内核。这一过程可能包括解压缩内核映像（如果它被压缩的话）。</p>
</li>
<li><p><strong>内核到根文件系统</strong>：内核在启动时，需要访问根文件系统来加载初始化脚本和程序，来继续启动过程。这通常包括挂载根文件系统，运行 init 程序等。</p>
</li>
<li><p><strong>整体流程</strong>：电源开机 -&gt; Bootloader 启动并初始化硬件 -&gt; Bootloader 加载内核 -&gt; 内核初始化并挂载根文件系统 -&gt; 运行 init 进程 -&gt; 系统完全启动。</p>
</li>
</ul>
<h3 id="bootloader（U-boot）的启动过程"><a href="#bootloader（U-boot）的启动过程" class="headerlink" title="bootloader（U-boot）的启动过程"></a>bootloader（U-boot）的启动过程</h3><p>简单的说，bootloader过程分为以下几步：</p>
<ol>
<li>上电或重置：重置向量，开始执行。</li>
<li>初级启动阶段（ Secondary Program Loader）：初始化关键硬件</li>
<li>硬件初始化：进一步初始化硬件，这包括时钟、内存、外设接口如串口、网络接口、存储设备等<ul>
<li>控制台初始化：U-Boot 在控制台上显示其版本信息和命令提示符，允许用户与其交互。</li>
<li>执行bootcmd：U-Boot 执行名为 <code>bootcmd</code> 的环境变量中定义的命令。用于定义如何查找和启动内核。</li>
</ul>
</li>
<li>加载内核和设备树：根据 <code>bootcmd</code>，加载内核、加载设备树 blob（DTB），及硬件的结构和配置。</li>
<li>跳转到内核执行：地址并跳转到内核的起始地址，开始执行内核。</li>
<li>参数传递：传递信息给内核。这些参数可能包括 root 文件系统的位置、控制台的配置等。</li>
</ol>
<p>这只是大致过程，不同平台可能会有一些区别。</p>
<p>rk平台处理器uboot启动过程：<a href="http://www.baku233.top/2023/09/12341234sdfg.html">http://www.baku233.top/2023/09/12341234sdfg.html</a></p>
<p>​	</p>
<h3 id="linux内核由bootloader装载到内存吗？"><a href="#linux内核由bootloader装载到内存吗？" class="headerlink" title="linux内核由bootloader装载到内存吗？"></a>linux内核由bootloader装载到内存吗？</h3><p>是啊！</p>
<p>​	</p>
<h3 id="为什么要bootloader-uboot"><a href="#为什么要bootloader-uboot" class="headerlink" title="为什么要bootloader&#x2F;uboot"></a>为什么要bootloader&#x2F;uboot</h3><ol>
<li><p><strong>硬件初始化</strong>: 在操作系统内核可以正常运行之前，需要进行一系列的硬件初始化操作，包括时钟设置、内存配置、外设设置等。Bootloader 负责这些初始化任务，为后续的系统启动创建一个稳定的环境。</p>
</li>
<li><p><strong>通用性和灵活性</strong>: 与固定在硬件中的启动逻辑相比，bootloader 可以被更新和配置，以支持不同的启动场景。例如，U-Boot 支持从网络、SD 卡、USB 或其他存储介质启动。</p>
</li>
<li><p><strong>简化内核设计</strong>: 由于 bootloader 负责初步的硬件初始化和配置，操作系统内核可以假定某些硬件已经被正确配置，从而简化其设计和初始化代码。</p>
</li>
<li><p><strong>交互能力</strong>: 许多 bootloaders，如 U-Boot，提供了交互式命令行接口，允许用户更改启动参数、测试硬件功能或手动选择不同的启动选项。</p>
</li>
<li><p><strong>支持多个操作系统</strong>: 一些 bootloader 可以配置为从不同的内核或操作系统映像中选择启动。例如，GRUB 可以让用户在 Linux、Windows 或其他操作系统之间进行选择。</p>
</li>
<li><p><strong>预启动环境</strong>: Bootloader 为系统提供了一个预启动环境，可以进行故障排除、系统恢复和其他低级任务，而不需要完整的操作系统。</p>
</li>
<li><p><strong>提供启动协议</strong>: 特别是在 ARM 或其他嵌入式系统中，bootloader 可以为内核提供设备树 (Device Tree) 信息，告诉内核关于硬件的配置和特性，这样内核就不需要为每种硬件配置重新编译。</p>
</li>
<li><p><strong>保护和安全</strong>: 一些高级 bootloader（如电脑的 UEFI）提供安全启动机制，确保只有签名过的操作系统或应用程序能够执行。</p>
</li>
</ol>
<h3 id="linux内核同步方式总结"><a href="#linux内核同步方式总结" class="headerlink" title="linux内核同步方式总结"></a>linux内核同步方式总结</h3><p>​		Linux 内核提供了一系列的同步原语以支持多核和多线程环境中的并发操作。这些同步原语确保数据的一致性、防止数据竞争并帮助实现原子操作，还挺多。</p>
<ol>
<li><p><strong>自旋锁 (Spinlocks)：</strong>略</p>
</li>
<li><p><strong>信号量 (Semaphores)：</strong>略</p>
</li>
<li><p><strong>互斥量 (Mutexes)：略</strong></p>
</li>
<li><p><strong>读写锁 (Read-Write Locks)：</strong>适用于读操作远多于写操作的</p>
<ul>
<li>可能基于信号量和互斥量。</li>
</ul>
</li>
<li><p><strong>RCU (Read-Copy Update)</strong>:</p>
<ul>
<li>允许读者和写者并发执行，特别适用于读操作远远多于写操作的场景（例如路由表、配置数据等），不需要传统的锁。</li>
<li>写者通过创建数据的一个新副本来实现更新，读者总是看到数据的一个一致的版本。</li>
<li>延迟回收机制<ul>
<li>当新的数据副本被写入并被其他线程访问时，旧的数据仍然存在，因为可能还有读者正在访问它。</li>
<li>RCU 保证在删除旧数据之前，没有线程正在访问它。为了做到这一点，RCU 使用了一个名为“grace period”的机制。</li>
<li>在一个 grace period 期间，RCU 保证系统中的每个线程都至少被上下文切换一次（即从内核模式切换到用户模式，或者反过来）。</li>
<li>一旦 grace period 结束，可以确信没有线程还在访问旧的数据，因此可以安全地回收它。</li>
</ul>
</li>
<li>RCU 读操作不需要锁，但写操作仍需同步机制（例如，自旋锁或信号量）来保护数据结构，确保只有一个写者修改数据。</li>
</ul>
</li>
<li><p><strong>顺序锁 (Seqlocks)：</strong>用于读操作多于写操作</p>
</li>
<li><p><strong>位锁 (Bit Locks)：</strong>允许在一个字内为每一位设置锁，从而实现非常高的锁粒度。</p>
</li>
<li><p><strong>原子操作 (Atomic Operations)：</strong>略</p>
</li>
<li><p><strong>屏障 (Barriers)：</strong>用于确保一系列的读&#x2F;写操作按预期的顺序执行，防止编译器或处理器重排操作。</p>
</li>
<li><p><strong>完全屏障 (Memory Barriers or Fences)：</strong>用于多处理器系统，确保某些操作的全局顺序。</p>
</li>
</ol>
<h3 id="为什么自旋锁不能睡眠，拥有信号量时候可以。"><a href="#为什么自旋锁不能睡眠，拥有信号量时候可以。" class="headerlink" title="为什么自旋锁不能睡眠，拥有信号量时候可以。"></a>为什么自旋锁不能睡眠，拥有信号量时候可以。</h3><p>奇葩问题？持有自旋锁时，再去尝试获取一个可能导致睡眠的信号量或其他可能导致睡眠的锁。。。</p>
<p>持有自旋锁，处于原子上下文，代码不能打断，会破格好坏数据结构完整性或引发竞争条件。</p>
<p>如果在自旋锁中键，不能进行会导致当前任务被调度出去的操作。会造成死锁啥的。而且这么做内核一般会触发信号BUG或WARN，生成调用栈回溯。</p>
<p>​	</p>
<h3 id="linux下检查内存状态的指令"><a href="#linux下检查内存状态的指令" class="headerlink" title="linux下检查内存状态的指令"></a>linux下检查内存状态的指令</h3><ul>
<li><p>free -h</p>
</li>
<li><p>top</p>
</li>
<li><p>htop（需要安装）</p>
</li>
<li><p>vmstat（看虚拟内存）</p>
</li>
<li><p>swapon（看交换空间）</p>
</li>
<li><p>pmap （看进程内存映射）</p>
</li>
</ul>
<p>持续更新。。。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】使用MPP采集USB摄像头数据</title>
    <url>/blog/Rk3568MppSaveVideo/</url>
    <content><![CDATA[<h1 id="MPP"><a href="#MPP" class="headerlink" title="MPP"></a>MPP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>瑞芯微提供的媒体处理软件平台（Media Process Platform，简称 MPP）是适用于瑞芯微芯片系列的通用媒体处理软件平台。该平台对应用软件屏蔽了芯片相关的复杂底层处理，其目的是为了屏蔽不同芯片的差异，为使用者提供统一的视频媒体处理接口（Media Process Interface，缩写 MPI）。MPP提供的功能包括：</p>
<ul>
<li>视频解码：H.265 &#x2F; H.264 &#x2F; H.263 &#x2F; VP9 &#x2F; VP8 &#x2F; MPEG-4 &#x2F; MPEG-2 &#x2F; MPEG-1 &#x2F; VC1 &#x2F; MJPEG</li>
<li>视频编码：H.264 &#x2F; VP8 &#x2F; MJPEG</li>
<li>视频处理：视频拷贝，缩放，色彩空间转换，场视频解交织（Deinterlace）</li>
</ul>
<h2 id="MPP在RK的系统架构层次"><a href="#MPP在RK的系统架构层次" class="headerlink" title="MPP在RK的系统架构层次"></a>MPP在RK的系统架构层次</h2><p><img src="/picture/tech/mpp%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91/rk_mpp1.png" alt="RK的MMP系统架构层次"></p>
<ul>
<li><p>硬件层Hardware：</p>
<p>硬件层是瑞芯微系列芯片平台的视频编解码硬件加速模块，包括 VPU，rkvdec，rkvenc 等不同类型，不同功能的硬件加速器。</p>
</li>
<li><p>内核驱动层：</p>
<p>Linux 内核的编码器硬件设备驱动，以及相关的 mmu，内存，时钟，电源管理模块等。支持的平台主要是 Linux kernel 3.10 和 4.4 两个版本。MPP 库对于内核驱动有依赖。</p>
</li>
<li><p>MMP层：</p>
<p>用户态的 MPP 层屏蔽了不同操作系统和不同芯片平台的差异，为上层使用者提供统一的 MPI 接口。MPP 层包括 MPI 模块，OSAL 模块，HAL 模块以及视频编解码器（Video Decoder &#x2F; Video Encoder）和视频处理功能模块（Video Process）。</p>
</li>
<li><p>操作系统层：</p>
<p>MPP 用户态的运行平台，如 Android 以及 Debian 等 Linux 发行版。</p>
</li>
<li><p>应用层：</p>
<p>MPP 层通过 MPI 对接各种中间件软件，如 OpenMax，ffmpeg 和 gstreamer，或者直接对接客户的上层应用。</p>
</li>
</ul>
<h1 id="MPP库编译与测试"><a href="#MPP库编译与测试" class="headerlink" title="MPP库编译与测试"></a>MPP库编译与测试</h1><h2 id="下载源码："><a href="#下载源码：" class="headerlink" title="下载源码："></a>下载源码：</h2><p>MPP 源代码发布官方地址：<a href="https://github.com/rockchip-linux/mpp">https://github.com/rockchip-linux/mpp</a></p>
<h2 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h2><p>MPP 源代码编译脚本为 cmake，需要依赖 2.8.12 以上的版本，建议使用 2.8.12 版，使用高版本的 cmake工具可能会产生较多的 warning。</p>
<h3 id="交叉编译："><a href="#交叉编译：" class="headerlink" title="交叉编译："></a>交叉编译：</h3><p>Linux环境，先配置 build&#x2F;linux&#x2F;aarch64&#x2F;目录下 arm.linux.cross.cmake 文件里的工具链，再运行 make-Makefiles.bash 脚本通过 cmake 生成 Makefile，最后运行 make –j20 进行编译。</p>
<p>此处我是先把mpp源码放在ubuntu中使用交叉编译编译完成，再把代码传到板子中，也可以选择把mmp源码放进buildroot中，通过编译rootfs，再放在到板子。</p>
<p><img src="/picture/tech/mpp%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91/rk_mpp2.png" alt="编译MPP"></p>
<p>编译完成后，进入test目录，可见一些测试文件。</p>
<p><img src="/picture/tech/mpp%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91/rk_mpp3.png" alt="mpp测试目录"></p>
<h2 id="测试和使用："><a href="#测试和使用：" class="headerlink" title="测试和使用："></a>测试和使用：</h2><p>传输到开发板中，后运行.&#x2F;mpp_info_test，测试程序输出打印在&#x2F;var&#x2F;log&#x2F;目录下，cat syslog或者cat messages。打印的信息提供了有关 MPP 库版本和其历史的重要信息，以及与不同版本之间的兼容性改进相关的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpp_info_test: normal version log:</span><br><span class="line">mpp_info: mpp version: 188dfb5d author: Herman Chen   2022-06-1</span><br><span class="line">mpp_info_test: history version log:</span><br><span class="line">mpp_info: mpp version history 10:</span><br><span class="line">mpp_info: 188dfb5d author: Herman Chen   2022-06-17 [mpp_enc]: -gen-rkr3, tag: m/master, atk/master)</span><br><span class="line">mpp_info: 2da4ad7b author: sayon.chen    2022-06-16 [vepu580]:</span><br><span class="line">mpp_info: 6304f44f author: sayon.chen    2022-06-16 [rkv_dec]:</span><br><span class="line">mpp_info: b05ba20d author: sayon.chen    2022-06-16 [mpp_frame]</span><br><span class="line">mpp_info: 3e6ff53b author: sayon.chen    2022-06-15 [mpp_enc]:</span><br><span class="line">mpp_info: 7c340c88 author: Hongjin Li    2022-06-15 [mpp_dec]:</span><br><span class="line">mpp_info: a053db72 author: sayon.chen    2022-06-15 [h265e]: Fi</span><br><span class="line">mpp_info: ec1f93f1 author: xueman.ruan   2022-06-15 [h265d_pars</span><br><span class="line">mpp_info: dd284cc8 author: Herman Chen   2022-06-14 [cmake]: Se</span><br><span class="line">mpp_info: 67536321 author: Herman Chen   2022-06-14 [test]: Add</span><br><span class="line">mpp_compat: id| name -- mpp compat info</span><br><span class="line">mpp_compat: 0 | increase decoder fbc buffer size</span><br><span class="line">mpp_compat: 1 | support encoder async input mode</span><br></pre></td></tr></table></figure>

<h3 id="解码测试："><a href="#解码测试：" class="headerlink" title="解码测试："></a>解码测试：</h3><p>运行.&#x2F;mpi_dec_test，通过查看输出日志，了解参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpi_dec_utils: usage: ./mpi_dec_test [options]</span><br><span class="line">mpi_dec_utils: -i    input_file   input bitstream file</span><br><span class="line">mpi_dec_utils: -o    output_file  output decoded frame file</span><br><span class="line">mpi_dec_utils: -w    width        the width of input bitstream</span><br><span class="line">mpi_dec_utils: -h    height       the height of input bitstream</span><br><span class="line">mpi_dec_utils: -t    type         input stream coding type</span><br><span class="line">mpi_dec_utils: -f    format       output frame format type</span><br><span class="line">mpi_dec_utils: -n    frame_number max output frame number</span><br><span class="line">mpi_dec_utils: -s    instance_nb  number of instances</span><br><span class="line">mpi_dec_utils: -v    trace option q - quiet f - show fps</span><br><span class="line">mpi_dec_utils: -slt  slt file     slt verify data file</span><br><span class="line">mpi_dec_utils: -help help         show help</span><br><span class="line">mpi: type: dec id 0 coding: mpeg2            id 2</span><br><span class="line">mpi: type: dec id 0 coding: mpeg4            id 4</span><br><span class="line">mpi: type: dec id 0 coding: h.263            id 3</span><br><span class="line">mpi: type: dec id 0 coding: h.264/AVC        id 7</span><br><span class="line">mpi: type: dec id 0 coding: h.265/HEVC       id 16777220</span><br><span class="line">mpi: type: dec id 0 coding: vp8              id 9</span><br><span class="line">mpi: type: dec id 0 coding: VP9              id 10</span><br><span class="line">mpi: type: dec id 0 coding: avs+             id 16777221</span><br><span class="line">mpi: type: dec id 0 coding: jpeg             id 8</span><br><span class="line">mpi: type: dec id 0 coding: av1              id 16777224</span><br><span class="line">mpi: type: enc id 1 coding: h.264/AVC        id 7</span><br><span class="line">mpi: type: enc id 1 coding: jpeg             id 8</span><br><span class="line">mpi: type: enc id 1 coding: h265             id 16777220</span><br><span class="line">mpi: type: enc id 1 coding: vp8              id 9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随后运行.&#x2F;mpi_dec_test 加上各种参数即可实现解码视频。</p>
<h3 id="编码测试："><a href="#编码测试：" class="headerlink" title="编码测试："></a>编码测试：</h3><p>同上，运行.&#x2F;mpi_enc_test</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpi_enc_utils: usage: ./mpi_enc_test [options]</span><br><span class="line">mpi_enc_utils: -i       input_file         input frame file                      </span><br><span class="line">mpi_enc_utils: -o       output_file        output encoded bitstream file         </span><br><span class="line">mpi_enc_utils: -w       width              the width of input picture            </span><br><span class="line">mpi_enc_utils: -h       height             the height of input picture           </span><br><span class="line">mpi_enc_utils: -hstride hor_stride         the horizontal stride of input picture</span><br><span class="line">mpi_enc_utils: -vstride ver_stride         the vertical stride of input picture  </span><br><span class="line">mpi_enc_utils: -f       format             the format of input picture           </span><br><span class="line">mpi_enc_utils: -t       type               output stream coding type             </span><br><span class="line">mpi_enc_utils: -tsrc    source type        input file source coding type         </span><br><span class="line">mpi_enc_utils: -n       max frame number   max encoding frame number             </span><br><span class="line">mpi_enc_utils: -g       gop reference mode gop_mode:gop_len:vi_len               </span><br><span class="line">mpi_enc_utils: -rc      rate control mode  set rc_mode                           </span><br><span class="line">mpi_enc_utils: -bps     bps target:min:max set tareget/min/max bps and rc_mode   </span><br><span class="line">mpi_enc_utils: -fps     in/output fps      set input and output frame rate       </span><br><span class="line">mpi_enc_utils: -qc      quality control    set qp_init/min/max/min_i/max_i       </span><br><span class="line">mpi_enc_utils: -s       instance_nb        number of instances                   </span><br><span class="line">mpi_enc_utils: -v       trace option       q - quiet f - show fps                </span><br><span class="line">mpi_enc_utils: -l       loop count         loop encoding times for each frame    </span><br><span class="line">mpi_enc_utils: -ini     ini file           encoder extra ini config file         </span><br><span class="line">mpi_enc_utils: -slt     slt file           slt verify data file                  </span><br><span class="line">mpi: mpp coding type support list:</span><br><span class="line">mpi: type: dec id 0 coding: mpeg2            id 2</span><br><span class="line">mpi: type: dec id 0 coding: mpeg4            id 4</span><br><span class="line">mpi: type: dec id 0 coding: h.263            id 3</span><br><span class="line">mpi: type: dec id 0 coding: h.264/AVC        id 7</span><br><span class="line">mpi: type: dec id 0 coding: h.265/HEVC       id 16777220</span><br><span class="line">mpi: type: dec id 0 coding: vp8              id 9</span><br><span class="line">mpi: type: dec id 0 coding: VP9              id 10</span><br><span class="line">mpi: type: dec id 0 coding: avs+             id 16777221</span><br><span class="line">mpi: type: dec id 0 coding: jpeg             id 8</span><br><span class="line">mpi: type: dec id 0 coding: av1              id 16777224</span><br><span class="line">mpi: type: enc id 1 coding: h.264/AVC        id 7</span><br><span class="line">mpi: type: enc id 1 coding: jpeg             id 8</span><br><span class="line">mpi: type: enc id 1 coding: h265             id 16777220</span><br><span class="line">mpi: type: enc id 1 coding: vp8              id 9</span><br><span class="line">mpi: mpp color support list:</span><br><span class="line">mpi: color: id 0     0x00000 YUV420SP,      NV12</span><br><span class="line">mpi: color: id 1     0x00001 YUV420SP-10bit</span><br><span class="line">mpi: color: id 2     0x00002 YUV422SP,      NV24</span><br><span class="line">mpi: color: id 3     0x00003 YUV422SP-10bit</span><br><span class="line">mpi: color: id 4     0x00004 YUV420P,       I420</span><br><span class="line">mpi: color: id 5     0x00005 YUV420SP,      NV21</span><br><span class="line">mpi: color: id 6     0x00006 YUV422P,       422P</span><br><span class="line">mpi: color: id 7     0x00007 YUV422SP,      NV42</span><br><span class="line">mpi: color: id 8     0x00008 YUV422-YUYV,   YUY2</span><br><span class="line">mpi: color: id 10    0x0000a YUV422-UYVY,   UYVY</span><br><span class="line">mpi: color: id 12    0x0000c YUV400-Y8,     Y800</span><br><span class="line">mpi: color: id 15    0x0000f YUV444SP</span><br><span class="line">mpi: color: id 16    0x00010 YUV444P</span><br><span class="line">mpi: color: id 65536 0x10000 RGB565</span><br><span class="line">mpi: color: id 65537 0x10001 BGR565</span><br><span class="line">mpi: color: id 65538 0x10002 RGB555</span><br><span class="line">mpi: color: id 65539 0x10003 BGR555</span><br><span class="line">mpi: color: id 65542 0x10006 RGB888</span><br><span class="line">mpi: color: id 65543 0x10007 BGR888</span><br><span class="line">mpi: color: id 65546 0x1000a ARGB8888</span><br><span class="line">mpi: color: id 65547 0x1000b ABGR8888</span><br><span class="line">mpi: color: id 65548 0x1000c BGRA8888</span><br><span class="line">mpi: color: id 65549 0x1000d RGBA8888</span><br></pre></td></tr></table></figure>

<p>随后运行.&#x2F;mpi_enc_test 加上各种参数即可实现编码视频。</p>
<h1 id="MPI接口使用说明"><a href="#MPI接口使用说明" class="headerlink" title="MPI接口使用说明"></a>MPI接口使用说明</h1><p>MPI（Media Process Interface）是 MPP 提供给用户的接口，用于提供硬件编解码功能，以及一些必要的相关功能。MPI 是通过 C 结构里的函数指针方式提供给用户，用户可以通过 MPP 上下文结构MppCtx 与 MPI 接口结构 MppApi 组合使用来实现解码器与编码器的功能。</p>
<p><img src="/picture/tech/mpp%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91/rk_mpp3.png" alt="mpp测试目录"></p>
<p><img src="/picture/tech/mpp%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91/rk_mpp4.png" alt="mpp接口示意图"></p>
<p>如图，mpp_create，mpp_init，mpp_destroy 是操作 MppCtx 接口的过程，其中 mpp_create 接口也获取到了 MPI 接口结构体 MppApi，真正的编码与解码过程是通过调用 MppApi 结构体里内的函数指针来实现，也就是上图中红框内的部分。红框内的函数调用分为编解码流程接口put&#x2F;get_packet&#x2F;frame 和相关的 control 和 reset 接口。</p>
<p>接口略…有点多。请参考MPP手册或代码。</p>
<p>后面可根据官方例子，进行改进，编写自己的app程序。下一章节介绍。</p>
]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】采集并保存USB音频</title>
    <url>/blog/Rk3568SaveWav/</url>
    <content><![CDATA[<h1 id="音视频处理库"><a href="#音视频处理库" class="headerlink" title="音视频处理库"></a>音视频处理库</h1><p>  <a href="http://www.ffmpeg.org/doxygen/trunk/index.html">FFmpeg</a>是开源的<a href="https://so.csdn.net/so/search?q=%E9%9F%B3%E8%A7%86%E9%A2%91&spm=1001.2101.3001.7020">音视频</a>处理库，对音频、视频流的编码与解码非常方便，这个库很强大，包括libavcodec解码库、libavformat格式转换库，在抖音、快手、剪映等热门软件的安装包里可以解压出这些包。作者板子sdk自带，所以此处使用FFmpeg。FFmpeg是C语言实现的，所以在别的语言如C++中使用，需要使用entern “C”{}包含。</p>
<p>​    头文件需要包含以下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="查看USB摄像头音频参数"><a href="#查看USB摄像头音频参数" class="headerlink" title="查看USB摄像头音频参数"></a>查看USB摄像头音频参数</h1><p>输入arecord -l，查看deviceName：</p>
<p><img src="/picture/tech/usb%E9%9F%B3%E9%A2%91/usb_audio1.png" alt="查看deviceName信息"></p>
<p>输入arecord -D hw:0,0 –dump-hw-params，查看详细参数：</p>
<p><img src="/picture/tech/usb%E9%9F%B3%E9%A2%91/usb_audio2.png" alt="查看详细参数："></p>
<p>单通道，采样率8000~48000，采样格式16 位有符号小端。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>此处实现，get_audio_params_from_arecord()函数使用了arecord -D hw:0,0 –dump-hw-params，通过解析内容自动获取音频通道、采样率参数。除此方法还可以手动设置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指令获取audio参数，解析并保存</span></span><br><span class="line"><span class="function">std::map&lt;std::string, std::string&gt; <span class="title">get_audio_params_from_arecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; keys = &#123;<span class="string">&quot;CHANNELS&quot;</span>, <span class="string">&quot;RATE&quot;</span>&#125;;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; params;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::string&amp; key : keys) &#123;</span><br><span class="line">        std::string cmd = <span class="string">&quot;arecord -D hw:0,0 --dump-hw-params 2&gt;&amp;1 | grep &quot;</span> + key;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">        FILE* pipe = <span class="built_in">popen</span>(cmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pipe) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to run command.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), pipe) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::string <span class="title">fullOutput</span><span class="params">(buffer)</span></span>;</span><br><span class="line">            <span class="type">size_t</span> pos = fullOutput.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos != std::string::npos &amp;&amp; pos + <span class="number">1</span> &lt; fullOutput.<span class="built_in">length</span>()) &#123;</span><br><span class="line">                std::string value = fullOutput.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Trim leading and trailing white spaces</span></span><br><span class="line">                <span class="type">size_t</span> first = value.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">                <span class="type">size_t</span> last = value.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t\n\r]&quot;</span>);</span><br><span class="line">                value = value.<span class="built_in">substr</span>(first, (last-first+<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (key == <span class="string">&quot;RATE&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// Get the higher rate from the range</span></span><br><span class="line">                    <span class="type">size_t</span> spacePos = value.<span class="built_in">rfind</span>(<span class="string">&quot; &quot;</span>);  <span class="comment">// Using rfind to find the last space</span></span><br><span class="line">                    <span class="keyword">if</span> (spacePos != std::string::npos) &#123;</span><br><span class="line">                        value = value.<span class="built_in">substr</span>(spacePos + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                params[key] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pclose</span>(pipe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册所有设备，初始化libavdevice库</span></span><br><span class="line">    <span class="built_in">avdevice_register_all</span>();</span><br><span class="line"></span><br><span class="line">    AVFormatContext* pFormatCtx = <span class="literal">nullptr</span>;  <span class="comment">// 用于存储音视频文件的信息</span></span><br><span class="line">    AVDictionary *options = <span class="literal">nullptr</span>;        <span class="comment">// 打开设备时的选项</span></span><br><span class="line">    AVInputFormat* inputFormat = <span class="built_in">av_find_input_format</span>(<span class="string">&quot;alsa&quot;</span>); <span class="comment">// 指定使用alsa格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果您的USB摄像头音频设备不是hw:0,0，请相应修改</span></span><br><span class="line">    <span class="comment">// 输入arecord -l查看deviceName，设置音频驱动名字</span></span><br><span class="line">    <span class="comment">// 获取音频流的参数并设置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* deviceName = <span class="string">&quot;hw:0,0&quot;</span>;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; audio_params = <span class="built_in">get_audio_params_from_arecord</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Channels: &quot;</span> &lt;&lt; audio_params[<span class="string">&quot;CHANNELS&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sample Rate: &quot;</span> &lt;&lt; audio_params[<span class="string">&quot;RATE&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;channels&quot;</span>, audio_params[<span class="string">&quot;CHANNELS&quot;</span>].<span class="built_in">c_str</span>(), <span class="number">0</span>);     <span class="comment">// 单/双声道</span></span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;sample_rate&quot;</span>, audio_params[<span class="string">&quot;RATE&quot;</span>].<span class="built_in">c_str</span>(), <span class="number">0</span>);      <span class="comment">// 采样率Hz</span></span><br><span class="line">    <span class="comment">// 打开输入流，关联到pFormatCtx</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, deviceName, inputFormat, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t open input stream.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找流信息，FFmpeg读取一些数据包来确定流的参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t find stream information.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找音频流</span></span><br><span class="line">    <span class="type">int</span> audioIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audioIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audioIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Didn&#x27;t find an audio stream.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出上下文，在outputwav创建一个新的AVFormatContext</span></span><br><span class="line">    <span class="comment">// 并为其创建一个新的音频流，然后从输入流复制编解码器参数。</span></span><br><span class="line">    AVFormatContext *outContext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">avformat_alloc_output_context2</span>(&amp;outContext, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="string">&quot;output.wav&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!outContext) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t create output context.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的输出流，nullptr使用默认</span></span><br><span class="line">    AVStream *outStream = <span class="built_in">avformat_new_stream</span>(outContext, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!outStream) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t create output stream.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制编解码器参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_parameters_copy</span>(outStream-&gt;codecpar, pFormatCtx-&gt;streams[audioIndex]-&gt;codecpar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to copy codec parameters.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;outContext-&gt;pb, <span class="string">&quot;output.wav&quot;</span>, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t open output file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入输出文件的头部。写入WAV文件格式的标准头部，包括音频格式、采样率、通道数等信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(outContext, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occurred when writing header.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVPacket packet;<span class="comment">// 保存从输入设备捕获的音频数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">av_read_frame</span>(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (packet.stream_index == audioIndex) &#123;</span><br><span class="line">                <span class="comment">// 将音频数据写入文件</span></span><br><span class="line">                <span class="built_in">av_interleaved_write_frame</span>(outContext, &amp;packet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(&amp;packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 短暂休眠以减少CPU使用率</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(outContext);</span><br><span class="line">    <span class="built_in">avio_close</span>(outContext-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(outContext);</span><br><span class="line">    <span class="built_in">avformat_close_input</span>(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 输出CMake的版本信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;cmake version $&#123;CMAKE_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 交叉编译工具链的路径</span></span><br><span class="line"><span class="keyword">set</span>(TOOLCHAIN_DIR /opt/atk-dlrk356x-toolchain)</span><br><span class="line"><span class="comment"># C++编译器和C编译器的路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/bin/aarch64-buildroot-linux-gnu-g++)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/bin/aarch64-buildroot-linux-gnu-gcc)</span><br><span class="line"><span class="comment"># 设置系统根目录（sysroot）路径，包含目标系统的头文件和库文件</span></span><br><span class="line"><span class="keyword">set</span>(SYSROOT <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/aarch64-buildroot-linux-gnu/sysroot/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSROOT <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/aarch64-buildroot-linux-gnu/sysroot)</span><br><span class="line"><span class="comment"># C++11标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 设置FFmpeg的头文件目录和库目录</span></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_INCLUDE_DIR <span class="variable">$&#123;CMAKE_SYSROOT&#125;</span>/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIB_DIR <span class="variable">$&#123;CMAKE_SYSROOT&#125;</span>/usr/lib64)</span><br><span class="line"><span class="comment"># 将FFmpeg的头文件目录添加到项目</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;FFMPEG_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="comment"># 链接的FFmpeg库的名称</span></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBS avdevice avformat avcodec avutil swresample swscale)</span><br><span class="line"><span class="comment"># 将交叉编译环境中的头文件目录添加到项目</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SYSROOT&#125;</span>)</span><br><span class="line"><span class="comment">#生成 opencv_test 执行程序</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(saveWav saveWav.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(saveWav <span class="variable">$&#123;FFMPEG_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保链接时搜索到FFmpeg的库</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;FFMPEG_LIB_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【RK3568】采集并存储USB摄像头视频流</title>
    <url>/blog/Rk3568SaveVideo/</url>
    <content><![CDATA[<h1 id="添加OpenCV库"><a href="#添加OpenCV库" class="headerlink" title="添加OpenCV库"></a>添加OpenCV库</h1><p>一般开发板sdk都会包含opencv库，需要添加到跟文件系统中。本文使用buildroot添加opencv4。若使用者板子没有opencv库，请自行下载cv代码，编译后添加到buildroot的Libraries中。网上资料比较多，不多赘述。</p>
<blockquote>
<p>buildroot中使用make menuconfig添加opencv4代码库。</p>
<p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video1.png" alt="menuconfig添加opencv4代码库"></p>
</blockquote>
<blockquote>
<p>添加后，编译烧录到开发板。可在开发板&#x2F;usr&#x2F;lib查看库</p>
<p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video2.png" alt="在开发板/usr/lib查看库"></p>
</blockquote>
<h1 id="编写APP程序"><a href="#编写APP程序" class="headerlink" title="编写APP程序"></a>编写APP程序</h1><h2 id="测试开发板OpenCV库是否ok"><a href="#测试开发板OpenCV库是否ok" class="headerlink" title="测试开发板OpenCV库是否ok"></a>测试开发板OpenCV库是否ok</h2><blockquote>
<p>测试代码：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv4/opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图片，这里读取开发板上的一个图片，可以替换自己的</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;opt/apps/src/test/logo.png&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查是否成功读取图片</span></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法读取图片文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个窗口来显示图片</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Image&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// 等待用户按下任意键，然后关闭窗口</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写CMakeLists.txt</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 输出CMake的版本信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;cmake version $&#123;CMAKE_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 交叉编译工具链的路径</span></span><br><span class="line"><span class="keyword">set</span>(TOOLCHAIN_DIR /opt/atk-dlrk356x-toolchain)</span><br><span class="line"><span class="comment"># C++编译器和C编译器的路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/bin/aarch64-buildroot-linux-gnu-g++)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/bin/aarch64-buildroot-linux-gnu-gcc)</span><br><span class="line"><span class="comment"># 设置系统根目录（sysroot）路径，包含目标系统的头文件和库文件</span></span><br><span class="line"><span class="keyword">set</span>(SYSROOT <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/aarch64-buildroot-linux-gnu/sysroot/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSROOT <span class="variable">$&#123;TOOLCHAIN_DIR&#125;</span>/aarch64-buildroot-linux-gnu/sysroot)</span><br><span class="line"><span class="comment"># C++11标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 链接的OpenCV库的名称</span></span><br><span class="line"><span class="keyword">set</span>(OPENCV_LIBS opencv_core opencv_videoio opencv_video opencv_highgui opencv_imgcodecs opencv_imgproc)</span><br><span class="line"><span class="comment"># 将交叉编译环境中的头文件目录添加到项目</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SYSROOT&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;SYSROOT&#125;</span>/opencv4)</span><br><span class="line"><span class="comment">#生成 opencv_test 执行程序</span></span><br><span class="line"><span class="keyword">project</span>(opencv)</span><br><span class="line"><span class="keyword">add_executable</span>(opencvTest opencvTest.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(opencvTest <span class="variable">$&#123;OPENCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在CMakeLists.txt目录下创建build文件夹，进入build中，输入make ..创建Makefile，随后输入make编译程序。使用scp（scp opencvTest <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#54;&#x39;&#x2e;&#x32;&#x35;&#52;&#x2e;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;">&#114;&#x6f;&#111;&#x74;&#64;&#x31;&#54;&#x39;&#x2e;&#x32;&#x35;&#52;&#x2e;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;</a>:&#x2F;opt&#x2F;apps&#x2F;src&#x2F;mySrc）传输<strong>可执行文件</strong>和<strong>图片</strong>到开发板，运行代码。效果如图。</p>
</blockquote>
<p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video3.png" alt="运行代码显示图片"></p>
<h2 id="OpenCV视频常见保存格式"><a href="#OpenCV视频常见保存格式" class="headerlink" title="OpenCV视频常见保存格式"></a>OpenCV视频常见保存格式</h2><ol>
<li>AVI (Audio Video Interleave)</li>
<li>MP4 (MPEG-4 Part 14)</li>
<li>MKV (Matroska)</li>
<li>MOV (Apple QuickTime)</li>
<li>WMV (Windows Media Video)</li>
<li>FLV (Adobe Flash Video)</li>
</ol>
<p>本文使用AVI，这几种视频格式优劣请自行百度（我也不熟）。</p>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><p>写程序时候一定要确认好自己板子驱动video号码，我的是video9。还需确认opencv和FFmpeg组合是否支持对应的视频格式及其编解码器！！选择合适正确的格式、编解码器~</p>
<p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video6.png" alt="查看usb摄像头信息"></p>
<p>本例子使用的usb摄像头使用avi格式，使用MJPG编解码器。</p>
<p>以下是捕获并保存的app代码,CMakeLists.txt请参考上文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv4/opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv4/opencv2/videoio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化摄像头</span></span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">cap</span><span class="params">(<span class="number">9</span>, cv::CAP_V4L2)</span></span>; <span class="comment">// 使用V4L2后端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查摄像头是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Couldn&#x27;t open the camera.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取摄像头的分辨率</span></span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(cap.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_WIDTH));</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(cap.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_HEIGHT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置保存视频的参数</span></span><br><span class="line">    cv::VideoWriter writer;</span><br><span class="line">    <span class="type">int</span> fourcc = cv::VideoWriter::<span class="built_in">fourcc</span>(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>); <span class="comment">// 使用MJPG编解码器</span></span><br><span class="line">    <span class="type">double</span> fps = <span class="number">30.0</span>;  <span class="comment">// 设置帧速率，根据摄像头而定，也可以使用cap.get(cv::CAP_PROP_FPS)获取</span></span><br><span class="line">    writer.<span class="built_in">open</span>(<span class="string">&quot;/opt/apps/src/myhSrc/output.avi&quot;</span>, fourcc, fps, cv::<span class="built_in">Size</span>(width, height), <span class="literal">true</span>);  <span class="comment">// 在这里，你可以修改保存视频的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查视频写入器是否成功初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!writer.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Couldn&#x27;t initialize video writer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::Mat frame;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cap &gt;&gt; frame;  <span class="comment">// 从摄像头捕获一帧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: Empty frame captured.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writer.<span class="built_in">write</span>(frame);  <span class="comment">// 将帧写入文件</span></span><br><span class="line">        <span class="comment">// 显示当前帧，可选</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Camera Stream&quot;</span>, frame);</span><br><span class="line">        <span class="type">char</span> key = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(cv::<span class="built_in">waitKey</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">27</span> || key == <span class="string">&#x27;q&#x27;</span> || key == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 按ESC, Q, or q退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video4.png" alt="捕获并显示视频测试结果"></p>
<p>导出储存的视频，电脑打开如下。</p>
<p><img src="/picture/tech/usb%E8%A7%86%E9%A2%91/usb_video5.png" alt="保存的视频"></p>
<p>程序在获取1080P@30fps视频流时候会很卡。我随后尝试使用多线程方式主线程显示视频，另一个线程储存视频，结果是显示流畅，储存的视频很卡。原因有2，一是MJPG编解码过程比较耗时间，可以尝试使用h264，二是密集型io操作很耗费时间。针对视频图像处理最好使用硬件加速解码。比如瑞芯微的MMP的hardware层支持硬件加速。此处不展开了。另起一篇介绍MMP。</p>
]]></content>
      <categories>
        <category>RK3568</category>
      </categories>
      <tags>
        <tag>rk3568</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tool】clang-format代码格式化工具</title>
    <url>/blog/ToolClangFormat/</url>
    <content><![CDATA[<h2 id="clang-format有什么用？"><a href="#clang-format有什么用？" class="headerlink" title="clang-format有什么用？"></a>clang-format有什么用？</h2><p>clang-format是一个由Clang项目提供的工具，用于对C、C++、Objective-C和Objective-C++代码进行格式化。它可以根据预定义的样式或用户自定义的样式规则，自动调整代码的缩进、空格、换行等格式，以提高代码的可读性和一致性。<br>通过使用clang-format，您可以避免手动进行代码格式化的繁琐过程，节省时间和精力。它可以应用于单个文件或整个代码库，并且可以与各种编辑器和集成开发环境（IDE）集成，例如Visual Studio Code、Xcode、Eclipse等。<br>clang-format提供了多个预定义的代码样式选项，例如Google、LLVM、WebKit等。此外，还可以通过.clang-format文件或命令行参数自定义样式规则，以满足个人或项目的需求。<br>总而言之，可帮助开发人员在编写C、C++、Objective-C和Objective-C++代码时保持一致的代码风格，并提高代码的可读性和可维护性。</p>
<h2 id="Use-clang-format-windows"><a href="#Use-clang-format-windows" class="headerlink" title="Use clang-format (windows)"></a>Use clang-format (windows)</h2><p>使用VsCode插件使用，需安装以下插件：</p>
<ul>
<li>Clang-Format</li>
<li>C&#x2F;C++ Extension Pack</li>
</ul>
<p>安装完毕后设置clang目录。我的目录在<code>C:\Users\16097\.vscode\extensions\ms-vscode.cpptools-1.17.5-win32-x64\LLVM\bin\clang-format.exe</code>,各位可根据自己的vscode安装插件的位置寻找。</p>
<p><img src="/picture/tech/clang/clang3.png"></p>
<h3 id="编写-clang-format"><a href="#编写-clang-format" class="headerlink" title="编写.clang-format"></a>编写.clang-format</h3><p>然后在工程目录下编写<code>.clang-format</code>文件，用于配置格式化的规则。</p>
<p><img src="/picture/tech/clang/clang1.png"></p>
<p>以下是我自己的配置，仅供参考，可自行去官网查询如何设置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: <span class="number">-4</span></span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveMacros: <span class="literal">true</span></span><br><span class="line">AlignConsecutiveAssignments: <span class="literal">true</span></span><br><span class="line">AlignConsecutiveBitFields: <span class="literal">true</span></span><br><span class="line">AlignConsecutiveDeclarations: <span class="literal">true</span></span><br><span class="line">AlignEscapedNewlines: Right</span><br><span class="line">AlignOperands:   Align</span><br><span class="line">AlignTrailingComments: <span class="literal">true</span></span><br><span class="line">AlignArrayOfStructures: Left</span><br><span class="line">AllowAllArgumentsOnNextLine: <span class="literal">true</span></span><br><span class="line">AllowAllConstructorInitializersOnNextLine: <span class="literal">true</span></span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: <span class="literal">true</span></span><br><span class="line">AllowShortEnumsOnASingleLine: <span class="literal">true</span></span><br><span class="line">AllowShortBlocksOnASingleLine: Never</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: <span class="literal">false</span></span><br><span class="line">AllowShortFunctionsOnASingleLine: <span class="literal">false</span></span><br><span class="line">AllowShortLambdasOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: Never</span><br><span class="line">AllowShortLoopsOnASingleLine: <span class="literal">false</span></span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: <span class="literal">false</span></span><br><span class="line">AlwaysBreakTemplateDeclarations: MultiLine</span><br><span class="line">BinPackArguments: <span class="literal">true</span></span><br><span class="line">BinPackParameters: <span class="literal">true</span></span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterCaseLabel:  <span class="literal">false</span></span><br><span class="line">  AfterClass:      <span class="literal">false</span></span><br><span class="line">  AfterControlStatement: Never</span><br><span class="line">  AfterEnum:       <span class="literal">false</span></span><br><span class="line">  AfterFunction:   <span class="literal">false</span></span><br><span class="line">  AfterNamespace:  <span class="literal">false</span></span><br><span class="line">  AfterObjCDeclaration: <span class="literal">false</span></span><br><span class="line">  AfterStruct:     <span class="literal">false</span></span><br><span class="line">  AfterUnion:      <span class="literal">false</span></span><br><span class="line">  AfterExternBlock: <span class="literal">false</span></span><br><span class="line">  BeforeCatch:     <span class="literal">false</span></span><br><span class="line">  BeforeElse:      <span class="literal">false</span></span><br><span class="line">  BeforeLambdaBody: <span class="literal">false</span></span><br><span class="line">  BeforeWhile:     <span class="literal">false</span></span><br><span class="line">  IndentBraces:    <span class="literal">false</span></span><br><span class="line">  SplitEmptyFunction: <span class="literal">true</span></span><br><span class="line">  SplitEmptyRecord: <span class="literal">true</span></span><br><span class="line">  SplitEmptyNamespace: <span class="literal">true</span></span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">BreakBeforeInheritanceComma: <span class="literal">false</span></span><br><span class="line">BreakInheritanceList: BeforeColon</span><br><span class="line">BreakBeforeTernaryOperators: <span class="literal">true</span></span><br><span class="line">BreakConstructorInitializersBeforeComma: <span class="literal">false</span></span><br><span class="line">BreakConstructorInitializers: BeforeColon</span><br><span class="line">BreakAfterJavaFieldAnnotations: <span class="literal">false</span></span><br><span class="line">BreakStringLiterals: <span class="literal">true</span></span><br><span class="line">ColumnLimit:     <span class="number">120</span></span><br><span class="line">CommentPragmas:  <span class="string">&#x27;^ IWYU pragma:&#x27;</span></span><br><span class="line">CompactNamespaces: <span class="literal">false</span></span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: <span class="literal">false</span></span><br><span class="line">ConstructorInitializerIndentWidth: <span class="number">4</span></span><br><span class="line">ContinuationIndentWidth: <span class="number">4</span></span><br><span class="line">Cpp11BracedListStyle: <span class="literal">true</span></span><br><span class="line">DeriveLineEnding: <span class="literal">true</span></span><br><span class="line">DerivePointerAlignment: <span class="literal">false</span></span><br><span class="line">DisableFormat:   <span class="literal">false</span></span><br><span class="line">ExperimentalAutoDetectBinPacking: <span class="literal">false</span></span><br><span class="line">FixNamespaceComments: <span class="literal">true</span></span><br><span class="line">ForEachMacros:</span><br><span class="line">  - foreach</span><br><span class="line">  - Q_FOREACH</span><br><span class="line">  - BOOST_FOREACH</span><br><span class="line">IncludeBlocks:   Preserve</span><br><span class="line">IncludeCategories:</span><br><span class="line">  - Regex:           <span class="string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line">    Priority:        <span class="number">2</span></span><br><span class="line">    SortPriority:    <span class="number">0</span></span><br><span class="line">  - Regex:           <span class="string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span></span><br><span class="line">    Priority:        <span class="number">3</span></span><br><span class="line">    SortPriority:    <span class="number">0</span></span><br><span class="line">  - Regex:           <span class="string">&#x27;.*&#x27;</span></span><br><span class="line">    Priority:        <span class="number">1</span></span><br><span class="line">    SortPriority:    <span class="number">0</span></span><br><span class="line">IncludeIsMainRegex: <span class="string">&#x27;(Test)?$&#x27;</span></span><br><span class="line">IncludeIsMainSourceRegex: <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">IndentCaseLabels: true</span></span><br><span class="line"><span class="string">IndentCaseBlocks: false</span></span><br><span class="line"><span class="string">IndentGotoLabels: true</span></span><br><span class="line"><span class="string">IndentPPDirectives: None</span></span><br><span class="line"><span class="string">IndentExternBlock: AfterExternBlock</span></span><br><span class="line"><span class="string">IndentWidth:     4</span></span><br><span class="line"><span class="string">IndentWrappedFunctionNames: false</span></span><br><span class="line"><span class="string">InsertTrailingCommas: None</span></span><br><span class="line"><span class="string">JavaScriptQuotes: Leave</span></span><br><span class="line"><span class="string">JavaScriptWrapImports: true</span></span><br><span class="line"><span class="string">KeepEmptyLinesAtTheStartOfBlocks: true</span></span><br><span class="line"><span class="string">MacroBlockBegin: &#x27;</span>&#x27;</span><br><span class="line">MacroBlockEnd:   <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">MaxEmptyLinesToKeep: 1</span></span><br><span class="line"><span class="string">NamespaceIndentation: None</span></span><br><span class="line"><span class="string">ObjCBinPackProtocolList: Auto</span></span><br><span class="line"><span class="string">ObjCBlockIndentWidth: 2</span></span><br><span class="line"><span class="string">ObjCBreakBeforeNestedBlockParam: true</span></span><br><span class="line"><span class="string">ObjCSpaceAfterProperty: false</span></span><br><span class="line"><span class="string">ObjCSpaceBeforeProtocolList: true</span></span><br><span class="line"><span class="string">PenaltyBreakAssignment: 2</span></span><br><span class="line"><span class="string">PenaltyBreakBeforeFirstCallParameter: 19</span></span><br><span class="line"><span class="string">PenaltyBreakComment: 300</span></span><br><span class="line"><span class="string">PenaltyBreakFirstLessLess: 120</span></span><br><span class="line"><span class="string">PenaltyBreakString: 1000</span></span><br><span class="line"><span class="string">PenaltyBreakTemplateDeclaration: 10</span></span><br><span class="line"><span class="string">PenaltyExcessCharacter: 1000000</span></span><br><span class="line"><span class="string">PenaltyReturnTypeOnItsOwnLine: 60</span></span><br><span class="line"><span class="string">PointerAlignment: Right</span></span><br><span class="line"><span class="string">ReflowComments:  true</span></span><br><span class="line"><span class="string">SortIncludes:    true</span></span><br><span class="line"><span class="string">SortUsingDeclarations: true</span></span><br><span class="line"><span class="string">SpaceAfterCStyleCast: false</span></span><br><span class="line"><span class="string">SpaceAfterLogicalNot: false</span></span><br><span class="line"><span class="string">SpaceAfterTemplateKeyword: true</span></span><br><span class="line"><span class="string">SpaceBeforeAssignmentOperators: true</span></span><br><span class="line"><span class="string">SpaceBeforeCpp11BracedList: false</span></span><br><span class="line"><span class="string">SpaceBeforeCtorInitializerColon: true</span></span><br><span class="line"><span class="string">SpaceBeforeInheritanceColon: true</span></span><br><span class="line"><span class="string">SpaceBeforeParens: ControlStatements</span></span><br><span class="line"><span class="string">SpaceBeforeRangeBasedForLoopColon: true</span></span><br><span class="line"><span class="string">SpaceInEmptyBlock: false</span></span><br><span class="line"><span class="string">SpaceInEmptyParentheses: false</span></span><br><span class="line"><span class="string">SpacesBeforeTrailingComments: 1</span></span><br><span class="line"><span class="string">SpacesInAngles:  false</span></span><br><span class="line"><span class="string">SpacesInConditionalStatement: false</span></span><br><span class="line"><span class="string">SpacesInContainerLiterals: true</span></span><br><span class="line"><span class="string">SpacesInCStyleCastParentheses: false</span></span><br><span class="line"><span class="string">SpacesInParentheses: false</span></span><br><span class="line"><span class="string">SpacesInSquareBrackets: false</span></span><br><span class="line"><span class="string">SpaceBeforeSquareBrackets: false</span></span><br><span class="line"><span class="string">Standard:        Latest</span></span><br><span class="line"><span class="string">StatementMacros:</span></span><br><span class="line"><span class="string">  - Q_UNUSED</span></span><br><span class="line"><span class="string">  - QT_REQUIRE_VERSION</span></span><br><span class="line"><span class="string">TabWidth:        4</span></span><br><span class="line"><span class="string">UseCRLF:         false</span></span><br><span class="line"><span class="string">UseTab:          Never</span></span><br><span class="line"><span class="string">WhitespaceSensitiveMacros:</span></span><br><span class="line"><span class="string">  - STRINGIZE</span></span><br><span class="line"><span class="string">  - PP_STRINGIZE</span></span><br><span class="line"><span class="string">  - BOOST_PP_STRINGIZE</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><ol>
<li>使用Vscode快捷键(手动格式化)<code>Shift+Alt+F</code></li>
<li>自动格式化<br> VsCode设置搜索clang，勾选后下图处，保存文件会自动格式化代码，需要的话可自行开启。</li>
</ol>
<p><img src="/picture/tech/clang/clang2.jpg"></p>
<h2 id="Use-clang-format-linux"><a href="#Use-clang-format-linux" class="headerlink" title="Use clang-format (linux)"></a>Use clang-format (linux)</h2><blockquote>
<p>安装clang与llvm：sudo apt-get install clang llvm</p>
</blockquote>
<h3 id="编写-clang-format-1"><a href="#编写-clang-format-1" class="headerlink" title="编写.clang-format"></a>编写.clang-format</h3><p>可以选择使用默认的Clang样式或创建自定义的.clang-format文件。然后将其置于代码库的根目录中以应用于整个代码库。<br>可以使用以下命令在当前目录生成一个.clang-format文件：<br><code>clang-format -style=llvm -dump-config &gt; .clang-format</code><br><code>clang-format -style=google -dump-config &gt; .clang-format</code><br>或者直接复制上面的~</p>
<h3 id="格式化代码-1"><a href="#格式化代码-1" class="headerlink" title="格式化代码"></a>格式化代码</h3><ol>
<li><p>命令行</p>
<p><code>clang-format -i &lt;filename&gt;</code></p>
</li>
<li><p>或集成开发环境（IDE）：clang-format可通过命令行或与许多常见编辑器和IDE集成使用。例如vscode。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目介绍1】</title>
    <url>/blog/MyProject1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="62b37668c6e22148100d6d044aaf7d2dbd0f9b673baa139a1b399d782e73c246">61ef1ad7815c9e1a9b9f44436a386f8b134402df2560e707ccdf581c4c1fea5e7261711f9fb5315431da0114b435970e6bd19e1348a5f1b016adf8438a8c71d0276b47529831d9b84c3760ad3799f4c3140f58bb5868a9ef1b0a1b29e195ee9e8747deb1411f92d1279476ca35a74f54556ac7df826bfd208da8f7fbbaa277e4a4ed52ac3472d21d680a0682a58f290860826e9c75acb3bbfd95ad5efadd49db8a9fece8b5ed113f2bb04e298049bb28403ec58c010ade321886cbc6e016679f41a9561b4990b78a131e1df2cd8a1c6c5645b2c5163498ff78b12912826dcbb0811331fd5fad83d473df5880277ebb98347610a5f147fd2c572fafb461ee4688dbee2dadbc38ebffd7ec2397bed1ebef8be66a0429d7ca70fd757dbab11e4fcc74376d6fe1c24d33b9c1402dee75c0333dbb0edf6e80c9245ade312fee76f0ce0451aea27ac25a78858db3ebf44379f6fe7b4d4c4046380d798af670a5ead735f1b9cf00deb671175a23bbfc3b811f2e807f879901d4aa7371c57fb7194a40ac73da6886f0b279e158cf75312de9cc191e1647e0ab9d021797340dbc4ca7d0d81ed86bec36e91fab7b2400e5a80ae7544cc71bdad3ae09c339d54a7ede3e775b1c792c0809b71796142b9f181436829b10a0957265dc00530a83852ba8759dafe371726aaae025e01dc645ab4cfdf0491738c23d0c04cb10f12a1b84e6e361f962dd6fb6c73eff854f5637fbc7667724bdd5d5a02531b9c14bfbd1edd028d51427e7e7869b1bf849456be028c79b5b8852b2fa838361a7f1395ab1762671526f978d062e9179272fc82a08f74ad846c90a797c567413016df0de78b9f2547637199418994b9679936369ab8bafa21a2c1957c90e0a83de982463168b5ebaf943b6c96e817f68bca7ccf809138e43e01684485b7207153c28d166f5229e3325e630aeba56de819cc51377c5739ac72b0d68189d4866d21458e0610ea2287aba6e6612f3741b3f17b88d5161992b2245facbe2b339a0b85cfb1fdaa99c62439d274aaa472dc6d2ac9cfc2b83021459de8de6c3a4d47def0afc00ebfdeb4e0bab995a3fe0b59f163fc3f745426bdbed35a9ac4ef319744feed0ff2620ded23beee7195814c8c3a56a7583daec9bd44c2ae099573cbbbccfcd450e70cf279d34f514e6963d7c47cf67879cbb036e4b8e1d6e2d5d4660333f3389efba1df92e90d3eecc2b751dc292fbbf9b8f71f384a8d0b934ed293e091b73a7d3ae6dc10ab8008f9df3fc9f8678d4d466c5f78822b61b7aa68d95e8c567c965eb2d3fed87ef2d51a70e5fd721406775301bcae612e007909bae7123411cc995c2a0dc51630bbc945e8a22fe9fc22a932fde1de08a559d5b8bbd612c3ed584ff78029a72d8d07607fb212f80de2d24404a66e3eb95f2de50d1b333cc6f3372178caedc4bffb3668695ff3a2921d0a91ccad0c390e6189f923082957ad0a5f65ede63d25101212789f2f575e61bc3a43a1af4c821a8a70cf3db2a4cf103efbdf6fbaf775ba1ff543d091c0e49f1855156c351860f42a3fd92ed347172749c97dd00cf1b47b4433debf443b01f8a25d7ba5e40b3de972b4701b90f5797355057466d3544459a7863e27b3e5c1ec0a75be8e5e4746b61c0c5bdb1fe1df808c98d5cef2711641ee465825eb1f91bb8bac9a54e5bef795db4f3d046dd2154bf47b4ee3f87e43d23b1ddb28b29f5b672cbbb3928f5f4e199df756556091008e848c82ea9beadf8c9eb22da01e82a992fc1cea4d9cdf6b158424804931866f8187eafecb412807089938b92e01baf4ac35047d5e7ba51bb282f934b0768a71c3f9aa48084b3aa71cab58bf6ff6f4a2a9f2382b1dcfa266a43e006fc9844be53cc11ee40d9e3c61568a8d3dd9a0099611b3b48b58c9ad6cd48e6bd4fb0f8c3b0dd4e09ba887fb4db1dc6c6916cb601108f51d34774558801a42c60ac8d283d0b360cffcc17169d6a388cb63dc4e9095eea16bca5bfd1e11c2dc05ec858653ad1c7777f4d0f10514965805b8a61a6f9804c8560230d89b80c76240cf0308441652cb3ea25d6eda1fbd2380687c31871653dba9f0035d3cf3ad85b704b9e6324d52d7b15701f847fb98e0b76e3f0533880ab0339fcd75e48cd0e7ca40b6fbe9de952eec14b81fe1e50ba0ccc07c84be17d1731d1c6e2f1fc8b1b6d70bd43de9d93d70ee7fb40ef62cac0ae1b91863ff7933d3842353c21d6ff464949129b4cec1bc8caae34986f9aa011ecc92c9cd903315ca585c8b74cf9401e74adb6dc925d453338cc9bb4d976f5389c2d313f40b5f36ecbe265145a4c7672308e52510c9ab8a9bb8f0031391308baae26d4fb664e0dc4a8416a3528026a950d9841475ed1341c8f64261169dee2f8f26f971ffc778097ef6196990b8ff290bc627e6637da167b95846d616ab4f0ae8f98f2d96c950992bb156d8fe301688eeb008d300176f7279224cb3f4b327fa211c0c88f1715a909db61d6b13f4089dfbedb04c6cac11ab2c6751e5e8aac38ec260d81672e513a0b8fcce93e712f27687e75b5ffa1f8d35f45192d7440db552302803ad87fb2d97a2dedb4e967a35a082df9b3d8aa32738b70fb9ae60f6fec09fc88ee08c9197b06cf0b9ecff9c4e334b5c354bbbff3802e8038c6ce34cc8a0815edd75a7af21a3a115ae3c9b8d5a8c6fcf183dcfb553af49091a8cccbe425e9702fdf4c55475ddceb7accbb768c5ad09614d42ae83b09c34bbf39ca885ed3e1f6b960d3ae28605d24a601751ffd9b9cf2d4260dc873c59648d14461994f95d0a1dd7c56611fe82644a56b00d587e38f125a9792915dae66609682c9f2f567eaae81be10d0bb398d3a5a0770e907241e210306ace9da34f7230324cd81e049675fdaaf499d69a10b2c86c565d2eaccd54313f8adf63810b8342f2ee3fc90b4a18a1103f94568053f39fe814d992407b881a81f09d875db408f0526e83f444c0166ee2a11b6083e1019f284f90e4550051bee8505d4f64858f3a5e1a37f27d387cd7bd4a44ff33cf95824b73550088003ebd4b1e5ea73ae2e97ca9fee9f86d906c427bf3694314ea5eb68a4cb146a4ea2ba3e92f394cd26595c1c9f1b8ce64e0f8e4eff89763213dbfda721e36c6bb2a6a084aa2aa22ac5ce330be7eb5b36666496e6458aa31b2361f9357f34151a45124815b66d675f60d529c204b5644a0b495f556772b6428f19df4e2054da0150c8e37feede66117286f6b24b5215bdb915d69217fb3c5ffe7752a6e0ceb9bc48d673f2838d666be0d2ceb5d8f03abd38dddd7d6bed7ed9668fa1c9d91c20db4b32428f3ba12fd3ea16cc1a55a23974b476096265697e39451837476d65e8070fbb237a56ca0af3556ba7c236ce66c7b275c1aa18144dfbaaff30fbc3ea8e63c89c5de00450f404dfaa0aa86522bcdc6d9677f15c1ac12b6faac0acb4ab40faa1ae6363be8395b617fa079b70d4826a901a49c6e6e81073bd7821131aa2f5c783f98d803d41e4172de0b7876d3061a90e65341537f7e38ac730300e604fcb15961573bf4a7eb8c0419e0bcbcc8dcba156b69b1eb5532aa87f453f4e00fbeb7bcda2e2bd6cd65896e6ce34168457341143984f6bc208644fd7f1e869ce52c7aef2775ecafa7f683e89451d62b130d82d5d9b8f47613a16a3e2e377453f8dad832c72ffbc10abcf6f42c67e5cd2861e699b3dafc5014d430e47b9344c3cf20012c08584cb3af7de2a9a872e5ffd795179f79a14fd726c9ceadc29a7a2a26774b5650257bb4fa88c4905bd5d658e6ad7a10ab0b6a36a3b25c30b135f29b6e93c0b1e75b4ac351499cb8d56c8ca0900d0355f6698d2a1529795b9a4a2b16ee4c7d94749303c4c8f7adac8f2e0543930338691c600347c5401b837b4411735a30c564cb226fe0b5632fe9bd71edff673aa3b48cae7afd381c66a27ac14bac475bc330d566cdc137011f9a1bf85007707aa80c0da5eba9b95872295324d20da5f712edd8c55bbe91b0a22eceba8e5a1c2f680f1620a13de8a1ecd2d239bb39ce54abea5702dcdba7f5fd576a66d8d8502e05c79c3c992085f177595a74cb944fb8e23055a4766788252126f6fe1eb8ab94021250af7ff59156a08e2d9b863b94e2922f6375d7bf83a172d25a7379edbcce042b3a331d2f99d7b45777ff345b276f381aac05a629712a9debf6be1ee2c153e77acf8c059577beee271fda11babb2633bd6956d97f58d3becc4da6a49ee69ba5483e459b33c07163c8636c41192d60c2c53079e3e44b3e5024683a9e2db4092171cbe899d3e4be16054ce0f8eca3dcb2fd6d6822e2532a17aebe671ebfa27ddfecff625eaedb5df9aac3520451a8ee295713f87bf4f05238760477424666e0259b12120ec5cff33cc9a549dc6229d9281e6abbdcb1c275173dc55010db00878c6c56a83173491896f1deda5e016b9404692e09baee0007296cdad3b571994d114f93d6894dfef3532d1e7ad1aed033635477f0ce47416d34e736ab8169d815d7fc087a18b238e519eaac840f9b9f8cc2e1e5bd21f0218dbdd29bdc3a70bc2d495c990b73aad9d341ba4fd0c6a7b4b30581e9d8becabb11a5f38d26aa0afdf79b8ed97ef7474027f55d789d55d2386e586cab559d51ed13513d0b9b87e008ccac835089257c2b6c93af74c309c3e19a72e2f16f4d7259bf67528ca42ffcea18435d23fa0c9860adefa50774d39262702707eb98e9b3cdcd7f9dd5db7cfcdc304c0fe991b465017bd8e5c1e668e36cb8c3eb365e1e8ea2132295dc491035b7dbbe859f7f50498977f03593a7c88a8296ce3ae1c6038585a28b345cadaf23a0c3e483d0322db5d287837d1fc0bfe2cb55956c8748172f4d1560402b0c8435d34b752b10b3214facbab93e06acbfa21e247c9e207d1ed9ac4415ccce4dcb3adfea62cba272fbb8864378a902f1f1363289fb90e4898dc0e3c85f6b6e46f2ffc3b3eb4f4a0a67f88c77edb11d79fdcf5553cfdb27d2ab0c966fa5eacb43e19f2c20b277752d7d21398a09ea932568fbb0f91fc5246cba7cdc98f70844ba342e166c5d49aca5c8c236a40d19cf487de0cc4e66d3609e9e9e85737fb62f90042e4e9c6d4d5cf44b9208011690a14ba715f88181abc9962293520648f57b8381e2ed1d4007a273759e1db43f842a9b2473d6ebff721625cecb74261553ce80bb0e3827d62dd0cbf186ad09a746d451bc2124f5669946794096c10230510a219f06cc47cbc1009c3b297f30267db110d316a40861dcb3714c857109498442a25ee2e9374c802e9a15b7c4d5836d68784a1170b89b592cf1efe2a0410da67ac091f29bc480baedc603b8a7ab35bd238236b5fd996ce4e3a65c9ff2d6d9986d5fe412083311c2e85007b2988ad87f6a24b2c9ab07c2265a899340449b798fff8b070bc38bd8a0434c3da85411831069b533fdfe0eaf515605873e73a09b4ae58e03a2fb7b8e03e3e509b65ec39af49f1e15ae335873922efafbe3d1e4bc18eb9c17a40656c6aa82787c5678b6db1ad84b2971f5e1e7def0d071caf3220a8473b807e6d811f9478b9ac18dadc5a4e04c1f9867dd28635158391c966bda69019ac0d7c1c0c2288ec2aa12828a8ed8adea86e9eef9db06bf8ee5ffabbefbd9f14bfa0f2694f3650756c1f993f61b75429794334bd79c7440209f425046aa965d80f3eab872946120c7517578094e467b0b104b25c762cbb43e47170cf8f5787c80401432d9d618a716d2814d92bfb3a52a112f9295e3146a429aca07ec544f49acc2a704c6ed726ed52d26a4cf745f0b37989baa1bd84cd3858f5acbca332d89ee014f7bfb4db17611f7a753a27adf876cccab9af033fc76bb6bbc9856705ec9030675c3924c25f9dc45ee656c03a7bf7187fc38205c768a971fcb025bceb012d209effd41f9d1d17fef53f78f4a161183789dd9d73cb27b6acca8da895a3f43e7731f9aef0a94397c3d5153bca470c565cc8b6576970774384067b451b0c205e6a75a20064c9a4ba12dabaf1ee730d81471c4b302aea58f40f5ea6aa6ee0031ecf9594ac741d0183d85240575d80a4817fb3e7af56ec5d5a7027478804ab588b49e1387bcfa136768aeef7baee41ae167f3aee7d18bc897a985b6647d78dd142af9844c192a3533a79d1495e50af76314c7921fab60a6804c1afe37df782c9b1e8c63b1135b0d2fd2df85848dd7b6c0ff0f18f40f57401409e0a803e4831d411b4de2b67cecfea15bb13d76c143d64e772193d1899277371a163626d61d01273468925046ebfc47c09727a7f243eefd5bbd3ea1c9c9d341765e1b046e7a00890402b6fc1e335e1ab71bad834c12967c5bac5e4947a3fcdbead6265b380dc0659bc4de0a213a75948ecd3b0a5c333d3d0fd3e329514155b3e88d7d6876653bc0a9dceeb6901c4ad1b1b17660956968fe7e116c09e0208caa3a8367d00cae92dc646e9edc180675ea53a7f52d87cff3d7b23d22acc737e4e2805883d1a860abb80582f3b17b681aeaa7399416546e5ec79a3cd005fe2cad38c09f1901b16116be59480551fdbed2bfd18c28b9e410a6ad530897afbcbfc1bbd290dbc65ce8e5543b17d5e4f9927ad048e174fe3815a026d83a75475f583ecd2de4d359c82d4aabe07f8ffac5423bd1077cab91312daf5521d68f226b3c9544b206305f31d84d9216bc6fc7e73167738a194f8f2277d8941ae6e606121882d767d539cb2dd4934b700c420cd9f87edffab48d34ecb7c695d4c4bf6494058727362b2c5636683ce41a365bd0ddef8e6f17f777a8ee363af478a1c3c35a0923a562e6ebd80a4d66f5ffb2d4df99cd5121b836c407ceab93109a704260d5f7a4147b5895ea9414ab7431e7759df3fcdc9ebb1855ec84c084e48cb4eda8167052abbbe0e5364deab9afbcee3ef0451a809ededfca6a260e3ae97814e9b0fb77a68824dd8354fa73e3eed9293bbe5ba39662ae36c7bd1e301ffc7ecb951d8fc8202dfe0c83de3c395192420dcb4ccbe6529d5eb806c7afbbd5f135566c56af706cc15f091dac4b7aa510d0088e368ed2d7b831fcef5e35ad2f47b4ec71ff4cd7cc0e2ec5c517fb9eac064e3c70cb3f27da9a6e887423c7a02b67e182ca42155d1c5006a64040449fd4ba75c3fbb19ace4591a11851ebc91ddfd42283f52f5f880631dd79738dc70cc43001b63e01a1e5fe8e8165e3ef8d607ab2ed9066130ecc75c0e0a1e899cd5b111a3851093ebabb97d90dfa229d09fb2e737ce207710ffc8c9f8db04a19648eccc54b0dbeaff355ecf5fce6099c04691656eec079666ec3b9d545d77dda163458b84283ec8a88f17ff1b2ae082258deb05055880425785279f63154afb687efb1020cd745045d80e3da35153a4e6c3ce1c220906444bf79826a1cf77b0610a3aa077ff89a3b1349683ed378cb709ef3d534364f8315e33f6e56d10cfd13df6675ade2c0d04a65d27afe8a1f7fdae36fd72051bbbb0f6cd17370bf8b297f6d80dcb82c8cdeddc452045d81f7bd55034245c409b94b0c9e589a502b51c9fa4671fbea916486116e848723d171c49a290bec0a1565ecf1313a70b76aff765e4970b1f2729c5e7cf6c60dcfe43c5d5a908af5d26087c06d269ef64f1a35603edf7638c19add9e368be65e35d51416478f11a9b59fb6a2bcb63dc36a59a3f55fe599faa3f40b07ed7bf43c9a7e351f77a772ed7d1a96e4180435975ad8e4618ab09f39bcb1ff9c3d37aadaebffdba812668546620bb68c699855bd0422c3bd55fb380ef608294e3f37276cc59b20656f902c383828e8db5f8f3258efd9f07c730ef4653dca4e064c3d7b9033efe935298ca6ae3aaec0f7954414715820b7d24f22c95a77cb712ac8a3205c86ab8dec47be9a7b775c2249a9263d42677d24e67c58c0144e9436363a49dac02e885b6c56c0879ee2fa8da92532d3b3fe100b87b848c0b6448d21e9fc6c3894844bc862d96541ea5b5e41a7d6630851e1a21c63e0cfeb02ee88de8bac9b31b88d5dd35f263d5e0fc9fa9b3f369da3d2b8cf62cd86ab30ab15c7f7ce2ab5fdf79cf1917cda0e8b73719bc5e07e46c966aff3cad45dc8bbbde1bedafba3f902883cf1703fc235b789b1a12d3aed9396419ef4de43342d30d873c376429d0fa0e6fdc05ee2ea724d3d3bdcb803cf450dc0e977a1999f863fb8c1125add21065a216f2f47af00e3a7c74fe4050a9c9fe027636d231d39178077465b2aa677cfd0c8b39fdbe8efe927ae3c2df38d42c0a2595d722eaf19a43f19b2479bd7fabfc0fb30909913bd4809b15df97b7e62d6e4412c3da622b070481029f67986b3a1d8bcc1c98e68224683a194210234594d35e409199c018f36b44b3a36bce566caa87315047da04d3757fbadd9e4b8c49c3d8bea0ce5b72479a4b867b0d35db050d813f97897850922a210ea83d7501277d6d961f448d7832c9c3d663ca495de609b729850a5e80f95c3de9133c8995562dd30e9475b871a0dad08e8dfd1bd5a44f64bf5baa74e24c7caed5b2cb32bf0b8d8ac3e7d7fcb019f681ca29731862cb37f5110c1a8af535c00cba8ca23bea86a5b337074a8033b9b005e5b3a7bd2f86e9b1a125c8bf35999d45569e5b905d541979b732058224f87f000df4d4b0a1842f9e09de26b9711c8ad04bafb2ad459399994eef41e7de80c19008c3ab6b5868c0acdcb6cf535a88b0e3b06b58709aa15629e57e0cb73803f170c43ccab772b459fbab88db176e23dfb97d872eace76fbdf3b29e99a04bb6384aacf60e1aa05d2b8d3c09dd8b4636b4dc63ffff143fc7d450a2fbde8ad66103a63ce73c841a3ea4d228e1f5c8e89f461c494aab1abc4a7ff11e61930f59fbf21150bdbab6255f4c03901af3348c0e6121b7420ad1e2d09a789070eef1025f3f1dd47fc6ac7ef3661a21ae75efec8087008041188c995b587decbaeddca3aebbf342ea238fe8288561c02e0f16d1ade83dc41d5a9d6f227dd10d59c4a17cd0766e06eecd9dd7fb88ec0be9797e88e8b7920e0f0737191b8a6105c031d8d2200d9e2779dbd29253220524f592733390127a0059d6b0703e86a6e443c599991e4ccd7f27afeaa3f20797da4433c3cb82b8043b884c99cbe57da41b127d960d7fcf01ebdb17395cd482365c8b1dd96c6649649ca98ea5ccea0551321935e43471854e70dff61ebefa13ced17d2d96b641673d72c33ab3b17c2e30863ecb4a52a309212354c184501319e6ac97153ca3b479c2f3c47071a300e67cfc24f188c87e3897f7eb35cfc265dcbeb54a7c4b8733c3f3d7b8078b1967ff3413293b61418603948047002c43cd607525729123a0eeb7fbbaa78466897c5681bebd4cc91b84acab79fedb80622c6c6e75c3ba20d6d4894bf96a42a392d326942cc97cd7eeee682e44356f9c4094fd1625ebed16f3530e4339a6cc5c6121b6e478a71f8a9ac9e4196843dd689bf6149592acabbca149805a81a15850bc13ec1e26ff5d8613ef3565936d702d76987d5cd620aa034a5e61ed740283048ed353b4156952a969adb2f4e8ca33b2bfe4859bcc0b98e5315bbdef115bb8edcca7db3c95d2ed4484f5af682bb61cc422416e39c7ccb188197b69d30ce5443831267901a6e179c448dc514cd8aa4d9e4e85d163f889eef23a30640f0e141a2812d82e926b4747ed88a0ca5d85e791086287014c55ad7a5815a2c62087dad5eca5c8d343fb0af8c24e6fb90521f46950371e9ff6604b9b1efaa8c12b79ea04ab15e8ceaf9b05fbc14f5676e168d8369f831557704926d6294b5d0b785c211ecdb9dc91035594333593c292ce8f2a61930eb98af61735bdb5fc1dc72bf6981d86f7f500868e36ef6f3830270c41397fe983461aaeaf5b96a99e3927b7d1f0a999df4cd3eeb8d9fca3e0781b5d15c671dde155763d8b4db7e55bb818819d1579772b5ea11cc19bfbc4bef20af6414c472a3cffd34c53ca1c411e64317756dff38ed705b801273aeac4e4ea7894cc1e38363a0b1a0125812b1023c4993b66ada4787c220dae9a4aba5536164cbace7b8c48f7d7b628a26d8027925187a3694bfa09477c2a7a5018cd2feec6b4f73d3507cb703783ccc535680945be3df6495c5059b9d6dacab9e60008aabccc15e7a07c399dd9f4df2e453b6f4dde3c666bd9a434349c0bcf688299804be422b1ff412b818f01accf4426867bbc1b7fc6adbb3d9b7874471b526c74abcf88ae70ad671e64dfd001ed1fd646dea792029b5cc014d238c44f44d2670b090f2b6f9b81755158b3c04eb84602a11707864c627e3815b3f05cb509609b3dd4deb5ad4e0ef4e74e94ff7e63a5646b6c9de83237c7334c7808342ddeab2ca9f35d9d57d9e4e17636b7b27330caabe546cd93502e27378b8ed5af687fe9b37367295da9b0e993293d9b556b5610032a86bb034464884e38b600b8204a190b6b44c853accaa43623c3ef713ddcc5aa17471dc14df0f15b5debfac1225edad7c2ad08441b5a47cfdcd0c315d8fd83a1d248d8edada8ad7c403cd95ba1171f2288399c337c905e14a564c0e72c22f6bd39966da6403f0ef1310114eb9ed984484a8de3d898fd43ee8ed9af82eb2f820973cadc53fd64dd7caab797e1fec518c539418a5660e3b254410be83d412fbdf10fc617eb9de9b438b84a6bde83385223f237eaa138cab537b0e1fe8c14a57fcf084d5e06bd83292534fbea058c26e99a2a5297368d766edd8d32646bbc1bcec2420df85e521544dbfc1fe457c730e2aa42083d12cb6035c6bc0cbd8b2589a4f12d42b163df35bed8d7176acb26bad823ecd3d47c0fabdfafe845327a06870d00bec503fc165952fc3fb5885cf9c238cd5b353d214ee757060fa8f284402702f011e39f5df0d643e0bdf36b46a45873c2b210cab45e24941627804cff0554dc5fdcd50c46dbcd7aed08a8db6fa1801c49dcb0a8b9b935bef5a59f6f407c154ed63150d17e7d42098c8ffee68ee79f3fef7257246635b5d82356f2449727131b1996832380b1aa88ed459568fcc499b0306c75c73063c2cf4aab6179763fd91f566d033feb01cf83c0112964ffeb4a20cbf57614cb54f62c320cecbaf6f2050c13435b6f4d3c007b296fa22cc111d5e65c0e227f498bbcd2398c715d0d5e3c1ee09ef8f48bf6f921b9ef09ec5c7f6129d68aa11265e183710ac0678ce0fa3bdda92d77fffec6da07ba8e0ef6347d4507f1dfa213a0ee2da8c240769b28b6440c515f53a62c8779378408a4c1e9dc1c1b363969939a32eac6a7d9d3c34d23c53a31727241c194b98b2b5d9cb98aa7ed419ed8cea929009def5729ea0f801bda84055780e7799163510a97acd9de6a501db1e623f94caaf07e90b173afe41a32306afffe8a03f457b443bb89533ac3e80c9dba4125ce597a0f0aed017e5a2eb9306a1c572d25788ccdc771a9f2cf3eee91cbcee817488ad09d46bd1496cdca8e24ab59491349a0f00b75dd9698b4147349f3844855c72fb7735384162f048d47283939a7719b74193dc5aabe3eb0aaf8e34f09b9dc24c144ee2a732052b07b429a3be81920d80036df79066fcd41e550cd058363c3010f3d3c8a9e6c7db6093ef8a2c643253a2d636538def335c6c7c254d2f8527a386d3374aca505a6ec957755a9aff565c8487ec8dd24b852d10606c7f0765d4a50d56c870864555ac4cee4790b1caf1a5414140068efd9504e483fbc9c261491d6364ecd212bfc57ed21fb5102ce34e5b39f612e394e7acdd61cc9d22b53d1b14f66c2430b73cb141640c732ecc0637065af705eeb29758619ebe267a5eca80943416b709b5e20bcdee05ed6259a69f09febd659c4dc1390633671bf4f8f136292b5c1d74c62494a87d1b502cf3ce8b3b136749da8590e2a2316eb7ee30e754711c8b31560487596919d3140e91c9016584c350ede9ed049dd98aa5cc08d98eeab777911ea0e6af4d6475ca76a52cad32cde10d0adb21e22be2dfce6699176cf0d3c7043db33e0226b1a3edc33a4094e95ba7ee69d919c332b81dba58adef6846382a2a478e94766b1784eb5adf5af2084b99a7b89e6b098706757fe0e649dc49e22fe7a6f085e0f730698fa888b3fb7cf99fec7a5bec2053574d1df546a97aae465dd02ef619a5ac272c031d37fd71308d11a68438568d0cf55b0ddfd4cac4cbc0f909fb3257cf2830301375203d5fe6abe83d2fc39f991e54525cf72011e95c87a3cce229d15dd5eee28ea9d29e28ac4f3301bc5cad0eeed685297816f676f6f04c2186440e75fccf53feb2192c7bb5fc71fc5638334e7225531b9f966c68f70b2a1a49cc0968aa1badb2197efec2158b0e877535aae304103496df68f9b3b43d805d619f3973fbe9c3b0e352786b666f17654f1107b33be76d29ae36b09ce3b6a82c1d58642c4e3c036ac14ecc211691e06cdcf56283591768bc3524a9657f4b5957022f61534dd91f8aefc33513e0b4ad43a4c2b6e0d1f04e700b0387e8c9a0615120b45c6e7f22a75fac8a5ef9a1f0a4162d07570715c03770d7019a2dbe5b1dca9be269227d879777bffe65f29f4f58805045354ca896189306fdd8ba7f22649be2c133a9bf895cd46635031cdd589d28b9371ca38fef825f6db2b9a489018389641160815794a2924cd738587fcbaf6b238cf1f520fbc321c6981b77065d4885c4da0969b8449c924528dba276c82d95541f1356eec720e75160115d2914622083e4ec43fdc5ce36a6af62b44a6f41cfa21e214af00c251a6c640ca448df34ecb0aeaeee8f1cb416f8e598d8ff223e15ffcdc8f72cdd9ac97e8cbf5c3a58d8be1981f1043a5233b8f750d69fcc2bd4b14b1d6381b8b865a2eb653341d18b688276384d75e68f77ea7fe92c09a5a8c296b3cddbd0c746d558241abbc93b19d694619f0624a25b6ddc1863cdc4f14badd564bae9da039ef5c939cbe0dc538b936eb0fcb8fcaf490aab62315571f514f9c9239efd21e5f044d8bc4a67d497b7265447ccf7055b99ce35b59790950599bb5994b449cd9bf37cb7996b3c255d56e5b88b091b37e2a6faaac778a073c535b5c739c49c851f93016f5b62be5ecb71e575ed1031955f0d4e74e1952868ac3b7d2f483ed9e0f54c44b7f9f23be89dc6ca9ed35f0d5b914a3eb7fa2aba8d11075801c95f09167913fcf11185b80438532b15f1b2d0d7e0ff879dc47c6f0ebb743eb5a788ae6cad7aa1d90796a6c69bedcc98d88a6b2371dc64afffe1e628dfc46b912dfffa3027114a6991f073e596b9b7c8b4eadb02c026df1e78cbdfee5497faccf6aff70b188f4738386b1a90d69225369371c62f8dd7405afe33e142ccbf48d6825e1858ffdb4a7ff9c9060255fd6828ca17e17a5873cc372afa1af80d3a6198698c215db62314c3300eb14bcd87b8b20cd8906a452da7e164c7e4131963e9f59a4cd734e6fd945303ea458769d0bd5d56cdc7ef6b4fa3640435325f8031d4052ae318ed64024afff52eb400591d52ce878a01e6df47f804de6a6881aa43400fc64b15c5d62eb1b0996b84e0c9b3ca51bfb0d69e292739e2596cf896a2be93865e544e2230dba85ae27b76c7e1f5f7536541b14c8bc1ea11d362887e13da4994df8c3b3c6033910f4398e9832fe83aad93f5511af16e1d7284900c1f6b3a0cbe51a3f275c88e27b85acf159998952ac77be8f2001b5e5217456acfcc1cf240de7b7ec13d0ba37666d1b8465c1036022ef0fab52c537ed565feef9c957e51dd6eefb0f64234a05aca7d37137c1b604ad667269fd5c6109026cc3ef75fb4a1f941e40abfb80d1ed6fa071b442ec30a7a0fa5b1676e0d97403ad0a180394c756904457b08e7d9bda42ebb2821775f0be301c00b4af71761ebb46d38e1f63411c406222d2aec64ceb58b28c744cd2dae96976692a1a4951f0e736c348d89718469532e41291b7dde6f0f0ae0e029aaca340ff54b21729f462eadc91188d9f1e42fb6fdccb7ca3b1655b72984d6021c20b578e5d225e080b7c412b92fe1947f244850e883db2978016f0a2caaa14fc01bd8466d28d1bd86e3aae6418215f73a107a9c807bc0d8e4840055e7c30ec8741b457aff1f1ade6f3ed30d1da60b208f907d177058c4554aa6cc73f37d48acca538c1f09966696dfa904a0aee5b6f7808080caafa88dd4a2f24c8635b9ab445882eeef78ce6e358e50701575627dd139601a4f133a46cf46d20c728a045f2308007e162dc4371fd4c59c29afeae941dabeb76625215f3939d1d13e950749e41baf3024a0abd58e884831ef8bf8bda46dce3adbb6675deecf3e494177b2cb9c0ec1d170eb19c939fe2b16b490b614cdde3acd447d9c09e5df55d8afa3788e0e1edb6ea3d9037a0d0f21499b582653720a3fb467f513eacbc9ee6bbc1f539bb358bd404112fee130861254134602cb7c492e33571e4a23d31330cb578c97dd0ee44090a442cf9e58f6e5fcecbc3d9ed3317f8595b0b4498f9200d15e2b40449273551f718f31efd1445fb9c6cd4257259b8110a024c69f36e8e9122fa9576a62d5c4078a048a5c596fc4632f5ff07b5f89f38f371313664e137d5008e3c109f360cf76c848bc1ed6b670c7584a1277f2694cabc1452da7cfdb8f166fc028a3cbb3697ec2474abec581a5051eb4ffa91e6dffad46165be6bc7938f6ee271f91660cd93d9b102e1cb1d973f7f3fa83488b8e912dc753ff352443fdf4ad4706c3fe2be9460219ea9853ab0f5abcdf33353b3a6b280224b9f663adb71fac4a7b2d6d69752db49d37da3fd77e9fbb176c30b6abed322bbf12000a06929ac761fff94624a714013ed9cadfcc9af50170516b817d0a3c5db6538867f4c781acca9d79356fb05da621f4113d9a069de7e554a4b7caaa9a65cc6b90d6d7eb65a178d88ce955e1c04047e0dd769824c63d62a7c45ca803b4a058ccee9e52ac9bf02b1dfac612d235ffc171f1d6b78ffe2bc3756f7df6afb84150a1f163cb35facf26110cb7d61e9ca326b6e3f2e89a9b760b5e66f694c2ee5baa5bd615aaf7ddaea4f8922753e7c8897b7905c8f1599082925fc7990b558f2437e5c8f9a328cfd5fb7628e0b7eaf0ee7700a23c6d102a7a312235159bd8cc5521ea4d2c323a9a6d1949738cff8b3fee28510eb5f090393e647b6573d7e885eb42074f33f227720d6d91761ad0474ffb842bda07d861ffede28d4d5a8120f795a7d6c4bdb48b6c4a2d820f9aecbfc473c7da2ce064d308525ca197a864b5ea10891379851cc4b3a856a813471a8f8f07473e42c145c009e6f4493c3ac7d98b5aedafb69a3bc88b0e9f2014d6c381702dc0700209e870df11d79985a92ee733d74b6a14090c5422b392e190b86dcd4b507dd7b07f3e2af879b1a548355663cd0ca075f866362400fa2ff9e797ce2e668c3916911e66f1157a0df73a8c59c733f6b211d9689a2ac77529042327b79e86e206fd8d15321262acd366642fe3952b303358a2bd5a3f4bbfe21ff5be933d2d0cd2f0efccdab51d7626fcaa4cfc7145950865c3e953a878e46ee33555287f4e3be914f51772d89b96cb31d704ce56dc5faacc3d057c0fcc9d2b4ec53baf963e1f5db7dd2e8f75e3ce567212d97abb021c23afad674cfabd6e80e710a81d62eef0d5dc6c034531476e4e2ac3a6c837eeb6eff0db3ec0e18d8d0f883c15d4abd96aaa031a9db3a8ed22283a8069655ed188c302efa5be4726afa66ec9b5a90eaa17398bb33c34a25d96b494afcbcf2cf38af388610a13eabc6963c3a0e3cae30da7a91f0dcfd5af3ca08b7fe2218f6bc28c139e98d2dbe9000bc3fa430f60fc241504418251de5027b7add3c189fb7ff85698b77ac9251ae9f827e57d4614695b26ac70cfe38f957399fcb5ba57be553afb2a18ae0401320630a2c8f43b3cb9c961a1f2ed2e3f5ebe94f070c3baad753908ab9cbd433f9366ef3a7238d2ca431b4c24eb519d0a3a45c52538dd8a2040c974844f2b37aa0057956a4b7edbd09c6e8a60a53852df1460fef68d6cc9eca18fce8239b58ef1ca6597003d655aa3c45ac6d2610eb14e5d558534b859610a9487807f5dde9db944c44b369b76c8bd27465f2b25b162a8233133b540758770f990a78469729762d5cb8658af62fccda12416576846826620d5f4e81828ef5d4bf210d34095daba5591863f7a00d2cbf50ba9e36c331771be3a8a1091590fbd0bb0943f4d462818fcafd327f2cc41c91dcac5dd106047d6ff6f1628e02a8232d7488cda607f64f80f98be240b955787e24c5729265f6523dac40dacb6b8674e4f2dfabab09a80046691d38262e5b4a911c672a016aaaf06d3be52a2a6cec91bf0ab03496673add338d55c554adeb41eb06a0ee6d8c98a6f0eb7d8d78bf2d520d0ff0bd3da275dfef29f06f5696abfeb8a878ddd807a34c907a7c3e0592cf8530ee2aa49f0aa45e1b1c17fa4d5d084fa946a957c1f6e5e27410a15288f306cd8df118785b96d85691c782c7c7cb64bd7683f86f34f632f7af1b86cf930a416e655a12f5327e55cc7cac436749c57e1fa1b741d26127a8afb856a4f1005da2028d38f0ec53fed27a0d1a62ecbc2641bb6510aa0cef9b2ae9d571dd8893b4f5cc8c859b757e3962e56921a7a6e61f8d7b09861183763533d3c6397160aa887d14223e3270b3643aad9c31cbbbb4a2bf9d7da03e76a25fa34c39700eae131dc0b35122bf3759d750f06bb1ce2aad96f3ea849f867e7edab930791a8151130cdc2b2bc3105f0ee5e874857234c889bc91c2378daa98d22c0d7b0563ef420984a70a370c5455bdd8802ab823ef7ee14aa6850643d891ea0628fbdc5f4312f28c1be8281cfe02848b335501e32a9cbcd3fe17f91efb68068961b82afa14641ac454755d0a3c14e60af1d92149e87e26422f2207ac4be1b17dd1873932a3b9a364148adeaf48bea173b6e27b4b73ba0cf21c305ef41b62b7f266e8a2790df0735d5d25e4f1a0658bc565e307b2186b85a71a106b249f76cb01ee4b29bc8d89657ea309ed2e0ca57b4d884c9cd74a1b42cf0a2551a918051009e64c0c95dbaba3bdcd4182fe3feae37ab3f6f8a818e303d7cb05f095152d51a67e7e52d54205f5621ac4e193f12eda6b87bf1bc87b2d14c4de3879aa384ebc361a91218a6b7a5e19c7f207d593a880180abc6750ac40b8fe5a38eb9a74fee4768c65781200ba952ecbb308e4ee2edb23c17371a7488bf8c715dd9b64fc189c352e4d5772ed11d38fd90a0c954327c9a41a6cd0b99b90f8e73f8695f35b9f69e2e31180e61a08e48f7c23dd46f894e53819ebd892891e21445e73e91d99c7dfabc953e7881d050a54cbf8696a634a72e4ffc600b2e927cdafa4b0ea663ed3fab56c91e73ac16ecf7be9a9605a5dc566b99cc19457b690d292d01465fcdcb1b423aee5447e8d8956f39876c8a57d1781a6f6b1f1c191254f9c0d4da21c6705c41f5fda48a033163dd20c63d34aa5ebf0171ab7da800339b8d2ddd5ea1d4ddf50c0eeb93af6bdd31402c419cb497606219ecadb29ed657c41134581412e09dbc1059f0d6853a67722c024ad0383321c167945a8201f86d694fece43d4efa6f5ceb398f7d8b5db9c791983965dee5cb492f7fc06daf3edcf888cc282fdad95e2ca93cf22a30a9eb6e190cef7045f2bcba87d6100f2cb2ade77470052b4f914c0f6f2569f17b2eb6c81a1117a18cc3cf997d11cc22a3bad4bc2b6f6ed38b02b2dfe575041025954c1fec9cdb88e6d71a9764bfc1faefe6d9026c71758c870a01a9c223dba640a583037beef87ce9d811a010ec81f7ef788c86d0b86e159d5c1c2cc30891191108a761059835f1c304ee77751fed468e836d05d8019d90386f6e90d09ed2b8f9989cb3ddbc00be8c7ef6632bb841b7284d5c051d4f4337af338638922307ac826eb071126c67348675fd46a9a377e76629aad61ab2d6e2942b53b6bfa3e475795b94b5f916f14177408eb38235bdf6a6a45a8997d978c5511010dafb8a122e78992dbee5dea6c624852dd5d67e64b8014241010d094c4d275c3173cf0748fef8a1b94672ef0026c8f4de5a3daf214cf351c84453dc3acf400abed6b4c78358a49ee91b2f83fd5ccbd4ef5bd68fbe65494eeef7409ced768515d6c8078441dfc2e8d9f0fc0c34ff934189ae5617a0e7692729a2c9cb3966e8063679d3bfeb3a423d95a242eb8020e03c84bac7a11001373365e3aceaf9fe3c8a60c5534459587438c3ef0a94f7dec491772419f4b1b47f4e28dedf1ed38bce09f0d2c1857a173fcff5efa8c7089f9e8621e3162dc548ac72f64e32e6a588edeb5431133b3fd2c8f2d7d76d927b017a8a33d7216986382d96aa4c2ceb549498d065de704b8bdcdb45161abd55a7e566625a71f640ab7852c6c7181b0899a4de9e54546da338aa6ef5e485798ac4a1c162b916961898803c0c703d8cf35de34392706435c8e6eede67908b4e94bfb3cbe96ca8e1e98c3c26bb0f0dd79ceb69e8faf4b04dadd45aa54fed0931efbf3157cb212881d5d0660f451028a494bf0ddb9a416d6d91ffcff624db53fde143b0a07774f0312997842034f40324f1132ba8f235f9cfc0d2b34d41276b3a1b143ecfba3ffbfc7cce5a3360e54885342248f31311e37dd185aaa10d0f0323823a87272cacc90c3a32bb592b5379a49b666b9bc0e85c46e6bb88a1923a9c8a9964f68b8afcb15d604d26116236c4b7060559af39f7ebac3ec63de742a18adca382d3841cbd2c5b1af9691c7c11619f82abf03735977471b6fcec9b3b8f90635254915d67ba40b466557cae0c9738b0df962cfe22168fb6399b2c53dfd70fe54bcccb9d67eb79d7404b1d6f967936d33101880d7509a6b13ac43a50076ea950899184c0b8b15bd9a0008497b640d60733f4f6469d95e4ffee1b74744ff56be9307fb69da608ede80fd6ab9003cc60b5241e16b80b599a3beddd0c7203b3ebdd2db2302a793aef2ed062b43b18db52645f29c13221d19eea1a031561eb07918bebc8f730376e3572d91a5d6ac72b5c008b14bff89e03e3530ede023741c4406ba01dab29d20843aaa14446d183d571233a6d1627a910b3b4e571c2cb36cd1e9407909036045a7a7e42dd0c5a24bbe71eebef0710f379bd6f979e0a4b4ab1cd62ae9834b118ca67b79b835d2e320506238f83ac454eac98222944a777574cc503868d5b03673809b577e5d07ac9afb03770b54f5a1e26bd3499201da51c4bf5367a0184dc5773d381cc37563e98d8f6bde42c07afe15a7a4c545a983babd783c295b1af92fda7597213b196561dcc6433732c0daf8e68e462387ce39c21c2169f147d20f95bdf64508f75e795cedbfba6972cb5861def9e350e52b2ddb33301dd563defa76d28fa206956f3b056aed5a4fa53868156eae0880734a239271ddb5204a161c1069c75ff6d28a8436fe40efde51ca9f317f79df0b618863984d020377c06b14b4b54803ba4a625730020de56a7e2af3a5add9edb03f3d223f4b1f599c4dd204757af2e208ed0249f666296d912b8828329a508af1b94d40fc12f3d4e49de43b49917eda260cea65ce61bde924979d370a0bb893d0aa468676f082bd191d4f1b7d5b8c8c1b878ad64c5c8d562e0bd23788b12981d6163b0855b05f0d2cf3c312879e94cf735ed8573b0eb1694db431619aadb8c019652ca812671cedfab4387622a34c204927850b2df39409bc89398a418560df4caacf27f76b4e4bdb7465441bc5b2dfc2c9bdb32fe90d57ebe5c245c353816e69af9fae3d2a01187918bdf9780ebdcc755864f0f69d18a8f37be974250f195f4f2753ef59fbdc929307ea7348f6874cc0630ba65d0038d338f9b16578eacf0fa3c2eaf2d9aa3b1804da44494f0388f2464221839c49a3d30df04b1aadf5478c8e5ed109171a8b58521c1c4c1700e475fb0332b6bb4c53e9c423e5e098c6582f7648103e637f8b75b3190927af597a475c70dff18c626cfffd5b0fe74e38d152ed34ae0ce6965f8422f7d02f5e5bf9a1db70e33f88a48d75b7800a8a6c86c5c2ecc8f94574751978d790aea6c382057876e934eaf1d16279e517140496b2b844453f0bbd8da1197557d1b1857a13bb286eb539b5759c19387f672126e6410fd15ccfb21706bc5cb596e3ef106e85703476b258b145e063028dad275fc8cb582fd41803b2d2d0a3a4a23ff62f67a1d89ade9fda886082016d475058894a6cef7d96777cba9a6be193f011e2c3c1cbbd566c132cf732c945627d7439fd8eb9270b80d635aab9a106a423042c573149c79450bcfe34edf03eed397cf364e2fbac947f70285b414ccbeef3bccb7d5fd7320056c26b1afea1ae66f8e6c7c95a58c7ffc24cdd065f2f3a40df53fd673c2ffdcbc2070ab6742fd990077310e4e4ffa995293b0ed142d6cd887ac1323919b3f7707cf4b4f11349f5649e0c42d63fc88ce2da3b422a6205bb40a547e26194d1def1787d3a9ae7b4e1180b1cb753f5fcb2d8738418ffc032c5ce4a624ffae1e5087ad5f7cec0f6db9f02818671f378c1404b75dedf827cd78396321739df778336de3935b66825e88e3583270134be14b4806840927370b17bae9354927327651ca2fa6e8c0c055f8fee505e9fd7e180b8cea8d8930f5c8a45266c5feb6c9d67e8189ed58d7e3ace3c4af7e8f5020b704ea3ff292bc830dc82a1221ad2ce72241895a8c1c67c5d3aa69f8ff539eed063be38cc18094b3f28a0de512ee8a84d97294456dbd92cddf48ea78260c877a1afdbe879bd5ca05d22b8af139fe17d6e6aa2a9108ea687ecd42a086b5ce5413bb2e92e574c60e86022b50149aa397a6ab5cf373211423c4d0ab86bf0804bd2b2166d6663ad16d780ffed5ed22670fc97d9b3cc5591966aa7252c33fbd2ba6bd14c481f848d053dfd0a3d3bee3456079131f648eb0cb122ee8ed824fd637b4f7bc43263710f714daa6d506dd711471517f7458fee8d7fb56a8867caa0fa73ba7306d5c681a873c08684134c120308460c60aa58d7b59abb649f9b363693f3950a62fb237b6685395ac485dbfcdf79044f47116654704f98799244d8e3068361b5c69c1a5aa3bd337e9551aa1240ac9a765b30be107ece3f998289911e63a2503139c6c76bdfc2f0c88e8b081dccea919703b7db1aa6814445acb10ee2a67a1fddf6ac645782d8a29d614c8456af8258f6431b21d293aac5289e09a009522203803f38013131bad3186cc580976a13aeecc410a64059d97f3d4ba345463cdd39605d7bf1d6f119db76d20c41ff55209d8be8fde926a413aa966f9e873d831b2e4615bc8993078fd0a46046de5f4256390e53e40a9cd019f1a08987df2e747f8ea4c2b95cd37f210ca5a2b3ae03061f4ce3628a3f0720b8df9939941397d7786e4444110c1606056d630e51a6d493984ba2b08153c43be492f1f7e3418f2e9ea59765cccea164d216be81500c9c22b54a33ff58ce4142ae4af6076909cbc9a3e654c0ad7b79f9a6b763531d43038815a2842a1f9f9cbeb1c12067c63a7e112231365d0a6e4fb354dc99a117e680b8abf6df7e0d5e18433a8c56a9b0ff24ad9dd4c8a6516f4be6301279b68e927cf005981d23efa8babf4fa7e70e67663e429b0434d237290bf7362538cf3da0e8e3b0d802977f8ed409b25291ecab58f6566005999fb316bd3d3bc6dbcfbf130d4e3d894bb4dfdf0104a0f54905ad31a73696c8fc5be270982f57107b0c52f5eedccdb2518d0da1b39c25e7c76ae5645657490019aa285be85500c660bdedbe4609fe7ace3c024732555c6c31f49388270b70771dd44fc7efc9e72a375f291ce9e99a8fb64fa2fb0db5284a93c7240827c8b9fd940e4118d94a42379c3ec54df604e9db11e0cd39afeb34ccbc9be7cda3e9412e3f80111ed7b09a668154656f340e827fe6e02da5673f17363e5def9f03aab2d9edc92d0089be6adb652de12cdfbcf039a4b6cf06f49c43d53023b1611f774db7c913298a52b13876421cee852b8de4517edf20c93c5a84e5afa2485dd4dfdf428dbbbf08f760739e38f533d5238853d3dd8b4c7efc18f3a6d39f3fab76a885f794d860bc851bd9357aa6e552d275f9785ed0326929ec38201987904bf0b02fbd17f4ac29bbc6902f5d7cb6e45ba7c2ea8f58869c7bd3d6134f25f5a88bb343b5bf3c30b5d6ee75b6eef95c8b2645fa96c658e8030cea7e5591fb05b5542390219b5fd08726087352397a5580a433767f1b8a3e87aaafa3060055325e965ed8ad369c896704dcb29e619c48fad9576cb40e463366046008014232562a29ea21e82e07324ef24a9388d8377849299c03313bae7a5b7fb29461c3846e59eab1f495f82d1bef32a0136f06134ce77607bab4bf61fa74a4cb65a4f8257d1941599e197baed617729d9ec9a620682d26b46f96c477d116a0c0defcb9b5e115199f2a4c9a54ba618d82246b416a3f214a34ec49b5aa784b734e2009892eeb6f5f373235313032146e5adc466ce95c44f95c4ddd493f46f1eb915149e3827b77d00b1261fcc441c219a2096b747e3d0ba4125c0a5439c478ef973e35c349783915f20c2bf25e28c73a84f3be5fec1b691d3a5df09482a38223915307d950ffea9c2c7f344b13289678750d0ee87efb614adca049a0ec887212a16d9b220c579aa6c5ad93adb93363dab3bde902b818796fa9814df3da951c4a4b7b9a61ec8a02fad3f24a4b3c0c9b36a2e9bbec41411e8bc63751858ee7b734c44d37e7c67e39acb613bc6117602f2679bf768b2c07787488e325a1af84fb9b9be1e011e5c25d692191ac300429a1c401f79d6374f497c77445c664c9829d6a5cba99cd93b5d1e52415b08f9047e2118913031aba34905dd300d7e0edde6f864db3fb1f7dade724e50c9865c43c71854d674d15c23b8832c946e3eb287693e4ad545cd58bd7a50804a55bd20c9f24fd6681b9908b40adf88f6f10a5a707636b506161198069558f594446320d42e8d0ef5cc80f674e4b96ab110cc9400ab11ff1bd1a5a0a193a943687bde50cea96fcd1175e2680c306335b7c349cc67146c312350f8dd0c33684ebd7af73633eb9d56581669c2378950d35adb154af1ee62f0cbf1e5dc3908fff215db9d525c9e803f451de7c6a6bee678d9955df4338bc4bdde902c097cd036a35d25e3af1c21d0b7691fadcb7e2ad543a5b770038c3bd33dd954fc6f62f487af3efa7350860c904e6278a315761c2cf10d65c6c0e132e4877456a8589326027df1b2f1ac3d3e5937d1f74a57a7bcd9f8192a5475c87d2e31f672a298716bf1a4bb62fdcb11754b4704ec11916230ff0e4bba5825953359e0f2b773aae11c3aa31d3b396cbad5f19dd413e2f3a5c88b033d580091d4b9beb62b75da94ea19a3db68ab2e815b0bfa412ddf7f1384594145573768b6ea4de599ad02f9ed6d5df05c5e1d92036e01b1c45914733f3526f1a2477a6477a99085b0e44093b16116b5462fd4166243e6bb96f640cc6f75f55675671d88797c088bbe28d8051b241f5806d9ce684f9bd2554a74979bfa63ebdf28e008441b7cef1c7f7cb80c76d0e2f1f1a4a5b1b38f1c70ccdbee3a8d05758d4a8a013842a678851865dfa44ae817b1b109ae7c2e91325dc0eb53eb57b3bf030b58194f555cf809271dbfa5a4eedea736950b84752680e5cde071ad83d5fa74e1e39a6dae7a088f946f15d1cde2d39a8c3c5485bcd4ca713f49bbdb772e7b9853e88a12585ea64ef2a92ea6d1213dfe25fa15cbfd9890afc40e5791001efb75aec36280bd0d30dd607086725ef07ba0f2e542374386c2e1b210380774c134ace675615a1ae522cc3b216de199d5f7ba78d32ae7cb7fec15c7cf763abb329c497ec258a556f29cb5a0801090f91112ab93c50641915874787b4553719475bb4e38db269fc736aa0ea87b45192837235c3b156bf73876befceadd74b400683f7bf11148f671e3799dcc0727bf870afbe0b61f5aa7d851a2ec896abd7d0936e600d1431c0c5c0adef760631f8ec60ee4d44616555f98f4b5889141bc4b73b695ed271e63f43d912a823c9ff218fde58c0388455aae3be9dc5c83736e4c9b204f6e1a42c361124cd7e8932d8d7e7b6f6a68777327030c44b69e03871aa53cf1423ae661e3b14252bee0148d0d3a2f509575ec5d457752193229687faf26a0c4bbd116a27533495864970b62c786fe60deb741411604e18eda8d50891207ee39e46da9abc3e6d93602ba0e8d2f5b75dd8c13b8f8cb8d5c49601cae2a3f04b30936b1ef3e0c4d191922bafac013d1cf4fec29429407a854284328b2ae65fe91a443165c359f5271d7633c42a654ea2eb16ecc5863ccb70290cc2a5e506f1cf16786e18b2e698dec8d3a86d8d6f46494049c3e1935a75efb44a86e5e07e7d5179014512f72fe94e1a19457ec9934689b9037bbf57b508d37be604d7665190e720c15e1ef550502e02edb367a9c8f027026d48f98c8edfb2986a5c0a7369fa8d971278e4903a10a7b89b013822f093cf5dc235c81f3808169afa0997142f1ded8e65c2653586f805def3cf7cb8dcf6b9d3b9d072679c935278839a4660743a7abcaea6a083aa312f028252fa8970e5890f2824268abef3b439332835f90a2202f0c03ff23a13825781340f082417e3b955447e101dbe4610b04d8d3666c7753459143d100b434b1e94ebd9c7cfe52259fe2408e42a6f0e099856fc3e51b16bc07aa6c68a36f0a17ea1e55e1ea1a586b0c7f90a67cbcb0f8a5b52867e006f2e8e3341ab2b905779232f6614f9f15287dea8f7254341c08dbea97e8e9656055c0fc1fb788e8f3b8e6f82d58ef06d0745735fd839ce93cb7be454d783fec72858f43a3bfc0220a1bc2f0d036345bc0de0c16e0805c1439729cfbcc0e7a00e75d3f1c557c1816043853fb59dea08a212461fe28e0338caa122ebc4b2753de6399490b52a7441fb214eebf3fea1648d2a7714bbe85386870b91e32aff65c7c9b702ba3be64126e04e6c355e8a012b8fd1a9463e3cbbbc87896a46e699780a02f5bf2396e75a1cb42c36e8a7dc9ce6765c998037bd49d654026e31f76bc16906e720353dcf632bb7ed99344b49883743e40bf3e503c4068808d4f7396b5c0300632fcc19eddaf8963163cae37c9f26a8fba90f0a8c467dd712a897f2c849cf437d496466eb670e99c63b60afc49b592ca52a833fb62ec752e0c7f3514bba9fd1cbc68361bba63ddb6bb29308995285ff0d58a5c705ad03a102c476fa66e0ae86d263ed1b00f065b69afc29cc5bcdfe07b5d65bd93837a672539769377689b5d2bce49e8fdc94fb86cd5c7d281fb53393ed939f347aa8220ceb1634cfa39807b013a7b1eae3d407a8896ed91ae22c183a9bb7e6cf01a1620a6fc189f72634d9a0ee867cf96a166792eab8f4bdd6ae31d99274c442b9037f4565ca052105aabd58fe0a5b02eb712ce096074375bf47016500bcaf87789699838a04c38681c2cb857427804dafcc3410bf4060514aadb98dfaee004e70fefdd7073ae8477f1de405b517e8ab0aec5b7763da79668e2c18edc3f3b445f03d9732642b0a7d190bbec343f469ae4e76094e61ddb33509d6657ab7849a84806b850a5281b640c51599c1cc8f4bb74c83ab91b8837585271d8cb16c90f29e8fb22359cbc430b6d82b8575b25eea4857d7b254cac55b54569d2063fd2d671354d195b1aff9e18f1e626caaaad4a222859e0c6696802ba5a89e466a2eecdd662d0e38776fc77b17ad9a04c024d12c16278ce0f27fd6fad3717cd30e7340dd2aa7a6d96cf680252ac661cab28c18c579513a886566d6d119b6f0556de8df033133cacd5406baae6ec9db5d367fc61684215f653c82a93706b1d38266e15158acbaf810977d94023ea8149d11e7a89120a6d996108f45f4dd9a2f380309c816382a07fce2650fff5f86697d8bb159e2e70717b052f841d3b8b45d8e9089685e64d1c725ea4950551760bdd7930ac9fd867192f551b584a7abe40c5c206196cf78c28ce8bb17708980c08867053150835dabedaa5d7edfdf1ce36b1835cca6e79490dba1a1f5181a904da93db019b9955237a454bc6b270d7af655d8af327600ddb66e55b7487dbab9457269f47f5d0d52b450a7faa4a15966e9e5d47e6ab52c16e83c27c7d5f8c732dbae189536f4588c5d6ce54bf92f125b7c343d5bf58f876d182872cfb5af8aa2f64b8af052ba1de9e2f3bf56dc8423fb932ffa680c1b5cb8c68b61aff9d911c668e2edf994006ceb959ef4681c7990ba97b9f51814419021af9b29d60a87833bc0a5ecb50d339f473b3e7a14d8ecdb30480165a4d21eb460ef58d31e0224bff51c926c4721ee5016e6856d49bc5f9d2e5deba395ce18290e87a453b3c3cd85a2da19b0dd041bb9c4869830602148a59dffbb09d382482be75dd4021de0515945353395bcbf07a216aa3ed4603550f8d61a3eeb9abe499e405e52fbdbca95f545af1a3d128cb7e29dbc33f222cef88d58eee72b915e5ca9878cce387f6fbd7c48889287efa0b5a612e31d1e04349a05aecf8d91dc64070eaaf35244504682e84a09fa3b4ce79b765231836ea6f1a0328e760df552cadba30510d3c3bc8af7a1608012d59b114c33cd1bfb9377a1f104e20805bfe6e7cf63cde8879328e8ad64e86dc4c794ea4d8bafe60e348151522d8e6461659aaee17f49f0075188053d163ff9d72808ebde30652900c5e1816278eabc8d427c50038167ac58940a86b4ac5f013a2818c2a05a2ab3b6cc5cca3336d4175702e230ad89755299dea4159d26524291e948f7512a70603a6f3e1cffbf51b88643dd181d182866ae778a470c2596a639be8591ce89dc8cc56c116e1750be6124416772b6a96c36a8b1ab8926cb6414e2a60bddb44b0d5c53be820d2856e25d5db4bdd639bf3e101607398a1aec52bca7d4c2e58b8655772e8195642ec329f9e2fae75d00439202b9124a96d13ab7e0b2851c28755e2bdfa9870f34b43016edf001b04a4e3df8afb01880cea3883192de7135b77d9c93677ed64ec0ebf40d70b0b13f16bf58691bb19154b985985411fa38f75383fda3d1c53fc29fb312e93c13c31d0d1eca5d9602df5018ef1d62fb1d8c9dd4e193d17257486a00a4d5e15876ea6587483da6f0c3ba7217af7df0570f395b8d7dc50bd9884721a04bc492c4f137a823fa2d087e3a1e94fe310aed9e6cc1a9b2ba843e150ab0577eb46ff923168716969e6413ab782a5af3264d4623ff23eef3950b86df453fc584faa078efa1d0ffae0f83c327cc5bed049127aa16df398a4fa735f3a0c816b15a642b97f5ed4e4dedb72ed060b637f41c3b53d31d57a62ecc2f70498161e94c6be21d91fa2d26ba0c52f45bb63fc2ea2f6f19fad85f1532b49e9e211547fc1b9514bec38246ed6a11486611814d319b4f3d0225a51bac889f6e38e8fd848fbb82f7209fb619a60a7fad55c0f2bbffa79215218d0600265324328bcd7e2d6d6ae567db0e2a842bf1e8603eeee753d06d50857c371832e969bf2654653ce37551213b72d8bd0dd9eb622ed8ae71465a19530f48546a0bf5148e0afaa011520fb2a73f0874d5f7f0a0aaf11b745b227084ff7e0a2db89b954d22bccb608ee4afabb348af278005b303741a264130a4e9a0928d923f0dfa57f89bacae3b5e98827b30a55846ea3e8a7c221b8f58b043e7a37047289e35af1b2a56637e79fbfb6e9c6e78d15ccd7f1028668241c5fbd66a63480cac0d33662d163ae8b223c2d65ed9542aab9910ffa54da06894d9f69d92368c5a1e638291817bd79436ea1c15c0d24cafc08953659bc1c4bb8d40c632990d9a082afe387de673e1a7a797047e3491f1962b95777331253da00151d65e6fd2c7cc3ef4760d84198fa70c0e5b16cbcc11b42cbc07a1029665bf0835a9d4af94cca6ccc1292d9bebc2d33c50569c156e11b0952918b3944ebbaf7979d97325e2bc2b188862e26988c8f40993b640e955aedda25f64118aa09f52783cc8a86daafd6748c0d49605106570ce9cb38098a4376a182a27016fc89e77475f584ccb47b8c2d4aefe2daa32399179b21bdb8397daa671b2e98400bdf621d02349dfcc97213d41cd48d7c3ae1b749e55d3235f0fe05bb0b1347c9eefec0b1b628d93b7eaf553095b94f656e0d2a9b1ed43ce68cf21d018aeea732528861d8536c83f9c21cc8338c9934034429b67fd23c14566c3da7977d2aabbed6f26263586d1d31c57a816c7cbeec452534a00649d983297ce4a59462349a86584ef83b5aba8aab3f5c7ec9c721919e958c5634b0a5cc03b0593be72eecaf8755c536f7fbcd49899e69279080286f2fa1df699a35dab435183bed52e2c48f8932a2eb1c3ae66712493b892fcaf6d782560b5150c075ec7c549b776bc1be684229e26fb1e8da094e99768e02ca89515886715fc587c5c4c28e18ee07c6f44b322ff457dbc8322d7197b1a01f2447ee1459cc931f08060630d7e5e9d72fbf4eb853b93dab37af782483fddfdc187afb86f5e6b95f2cf0b6154ccde35cc62a185b4cd4b9d89835f3ff6769fb155803704b537ff3ec9e80ff5c96f9e051843c687f99e16becf56bed18e733c6577282e9bbf3d230afa7b6161f8dc0d99ceaa8b482328562bd736a54debca3164501982bab43dee92f196c6ff18b29a69de5fbb326c478f3bda4ccc53b6d64954d47fdcf1e66c8911d7c342576dbfd29e69ace13ce5144227f47f8808e2ce5d99e883a86ee02ac6d53ddff400bc09c62978de139ef7062c8172b9df54a6ba756125e29435c82885914db8a17119937c55c1d9ce9e265855fa0af398c0166d9ac9149efd30f5fbe9449b25b7c2741f06602471c0c9484b1d619e0aafc8088ab5302fd913a037a536eb655e0f5c4ba566c7bedcf05e6d29fd5ecf3fe3bc4e5bbb8f513196a35fabe34b1eccb12ab3c959f9e1826dc48bc9119cbe66bcc39db3db308c0d7f9f48fd2f7d78d02bece5a8efcefaff1a0af5e76ceac9c892b3179396e46400ccbda9a7651a5682d0090e5d2e6bf02b667ab29fd474a7d89662135e5ecf3058b4ca9d7f9a6155bf457af0a2f67011e7123b2b328919eec6e982a8419793f1a9eac3a6d58cf4bdabd6c4fcf085a7db0ab227d960b6fb35786e5c2773ee1fd001daf119bc9f20ec75d9e3a29737dfc5d99de4f4e6eaadc1ead1fd673ed2b1c7b2a2023a0324d81eba1d1c4502e136cbb2f3307f7b540b73d994a95bd94ef8e19dc8eaec614bae3a09bbfeefb54136b0117a3d0fefb39f00d13565773c6768e711bca266257cb1d9238d92ebd2fd9c8ee5876f901bb147a76d70a4d469ed29b5013086f6455a21c5268ff40cfefbdff03b7425e84f2052404d930471c3d8d003e2dc214d95263d985bb2d7f65a925071b5ca444dbab3a8dc331c9791493b6415c404afdbbd952923583b88531e751c3d591fc2d4eee92173e49552a4254485ee38b33eab449e32ed41450997fafe76f08a3d0ac3fe97e436e546b4099a8f51237c0a59d5736cf7f5ed500bcd6936dc73fe9510e76cbef9072ac9ca43d93bbb174f54ff36284498cc547213bf803ec7e9c4f7fcbb2dd12d7afc38130df179c205b30d0df70b62d3cf9c754605a63f758036d32cab6940b0b5894cba6781211c2241b01be74fe09665bbc101f6dcfac175229ca342ac3fdbd8ef70d65f369adc0bc0a91e43482d39da078eaf6eacbf998f70c0012db8a6b40714c47b9d27af3a235f147b57cdbf03b3fe78c3cebaf5c7e516e37381229941d7363e19b3703c42d8fa0d6bce27d3e98efc2dc03fa578f41f07136209bffb00d08a5ce5568a9645e9dc4b675112ef7213d722b014b55d5486586ee536bbedf394b695610bb0f9b5cfcf4670c06590c164087a3d7f9aff60d83f60cdddfa25145e59f6773d551bacf0a80b34182cc88ef1bed33aa546048f296e3472636060a2a7fc7b1642d4fcf7ba0e0cf2ed58afaca13608dbdbef72160c37a564bf46ebef9e3ac142bc21991fcf490053b7a4f926785adc84882fbdea5d6244b9c87a32eb84fa31236aa2b63f677e6f58152a0ab86f696b0e5704cd0de643879ef62d809080970636b00d8e052a20f754ffeceb72b0846706abddca2fb4faeec5622a79ebf499e1f0236a7f5e04262ea1e70ae2ee0bf808af36476a638f8448794f0c37811bd55e9644dbb2b64ff2509656faa72382bac9f4016373693643a6a0c7a7cf219c4a7c6b126b1353eb1416d38629c08afe11c9da79030feb8c503cbde86ae6167b0415529d0d00a4491a12baff489f664222c74448995d2c7eff22f28a40262b73a16839a5bf117f0fe0beee843255a6df0e760a685d54d20ace49047a79646e8a53ff1431ad8d6d3b716a0ee9dd3dfedf2f6b78a6f908d16ebb3141fa5499a9d95b1486d2980433deba21c5c2c2a0bafac5cfe008e5b36e2c80810c95789bdfca2c087fc661c67429150febecc06bdf26b9fa9929dfb4cef898bbb8be53ed2428a988e854108deb92b7402fbd7967cc861506b93720cdec3fd875d1f92ae36fc62a84891f276adbf42fcade68bf3accbe927284985cb18c19749ccf508bc8d1a1271bab2393bca31f26c2227a7240e4ede2788f30c2d53682d1c314899e6619cec2d7b82c7b1638709003c0f4bed2fbd0f89684f8e8482a5df733ce5b7f8f4ff9e703ac43cdc0f1fc6db8b1d053fec629189da5b72e53d5ec9ef978e6a14479545478901745615fccb5b849cadd79788bc1507ca365fafa752a1e8ab4c4f65e186d09c06f6f4f5ba93078fd1a79fc2de48473223618bfa7d52c6b60ed7f7ef6891077ad0467dcf922790af4825b4b1906eabfb1968e90c479934297aa4f7e304a5ead832aafa6e79fafd6052afdf0be74556b50b4a4eeca3d5dcf3afba353579850c1d9574c2f72d33f11eaa39e8023697a6f9ea7aec5d53add3da4d3ec1bb0ecf3c0190c2faa21c7f918a46b018aee6e2fc7a3084b28b908424c2d33ea5ce2ae0b27d1bfa4b90db3b2abdcee64cf9323d564cafb556c8a82b171fae66dbd2e0ede72e9bba607cbc93823f4630b7f8eb57513caf49975209a4dfb15b86faf6470c3085116f37052c782a029640f1ca0de9c45ffd4bdd4d255e5cf7f006dbc921afacbc0ab21a9f7dc1c15746d3800dd0872272d53bd5012b5b9e3f21f489524799857155aeb8a90c5f5da2e5c848cfc9933d42295b01c4ca9ec4001f37794f9b86fe18b65990178b7e22757656362fc6da63005703801475a8a6ca07ba44d49e2ff9f2b34e0b2eca3173e727695f0ceee4587fb0ef53e6ac784eb78544a461f26d18fef9830a91493b37a40e587931de89e4b2eea045136359820f56b40f132fe84472b4cf979a312cdd57fabd2936428b2e4778cfc5185b65801e49e0ab03cb185fd8313bed4770e95a708bcb06140ae355d43908534a31f8303f23e8360caa99ec10b96c0aeedf14fc8f82e983c5da16175d451a396acb980ea3c1730716c053ae2cb670049e88a4bc7ab8ddcb9398e903076eb4bdc872575873336e5db0a900c8eeb558de5594f44151b6ba75d9d902792e6e7f0e789608b45e2002fd2f1a147f56684d69d024715e7680e711f50e5ef082ee21a50e5ce3e9b7628f7e86948415f07951d9b4e4e201523b0f7a7ede0ce8af14528e0cf68b1b319caba328a6f6d15e663885e39cd348baa062dd1a21b4cd848c02cb0a0600cb3e6fe4cc73c69eb9f1ce552d834e5caaf3db7e95895f560095ac53700490083b7c36ebea8581b64ae5e678c3a40f20b9b17976410b3b847fb0ade93a672ddd1727a06625243df7c9af03dcec53ba904a347fd27127b81fa303cc26f8b567b38fb2663836ef0673f1d8393a220f7dc2116c223179f7609f5df76573ba89e8206616afecf27db76702a323124d2d60caa2f0cf49cbb97ad047c3f10d07664717ff64ccccf7e7744aa6cbd3e518f27ddf469f274e60e87e8e1256b41f70d8a64a8c3990131adef0656ab3173332b8f1c8a4b662053ba6e0faaf51c31cfd535abefb754de089feda92f2c0a1e892a3924e4e170ee5de0b5f92eef9e15f2ee68c840f6ea09a91d0b0d37902bbcfc288b9603f0109002d5de1d7d475cd4fd2b17f9c9e4a50e7f2735971be04db759a1b6d3ed8010fd851c7b54727fa03fc1ba8e382d7db19bfe13001e542c39cf59ed4193115edaf1fb634af60c9de5bad4b9070a4818340a833032b3178193d69e5fa109c187edc56acd4f09beefe7a524c99a6584c51377687a054dfa997291beb5012de7315777b681186ab38e0efbb28baa771cff9e1b1b9c9137eb465a516d436c582eb9d362f6fbfc3750683eabf6a47e153ee02f1b28e3dc18970f7f12a2480653928fe9224030d061ccf5a9d19ce9b9783b9c6d88f640d200c33311dbff491e7c3c288bff97e78bc38e04dbe295b1fdf1491de625e177ef3cc76efa7daf93da031384a78cfd8d52fa7bd9232e4f9131de4b621d1f1cdaa2f4a0bfc52a3753bd6489f606ff2d9a0959931687085a04fa0e8051cb65da6527393003ab25d63debdc457d7b7c18dbb04b01b71d145c43f4a00ac14f035bb1ad25733b7870c155305688ccaaf2724272f84fd83fc3355671b3ebd45b90227efe3e02977faaf334da1daf4def30a79e1044aa7b818c307ae846965ef0446f6967a0f4d2c0649de93edd5176ae10d4c249dd5a01e8a2ba4cadf7e8522f8049643b8df89d3bc275155434ea3c7994e7b8fdd0671c396f049481b4cfac41fb929d58813c4c01c21b29edc12d79d411aaac279a97b16168a0dcc2548ff28704834935fbf81543221c5f568e45ef74fd3a6becd5744dbc05d4e9965f8edc2b483f0f60d9f6c40851075934e7236ca0ca67f2754604072462b8dd5a7d9130c1bc37deb1e33a34f6a34a50dd01f0b56345707a463c7a732abef14390762590be27f89b3ac5cde5f9dcf98f45db400a8abeac0cceead950df0f1cc4a66986704390113c0b2cd3e0b089f7ceed004f40b5e28d4e9d98aeb86ab868ba1e5de9eaa29498d00f7ce4d52069c9cf015fee3ad2c9a3cd258537797f74189ae7ec1487bd471465b17327463e037afe9afbc5dda934e3a1acaeecd98b6a9a4a015afc1e4359eedefffa504d987323ad251c231c7c39e56043c513a44b838587d8bac60a2198ed792c8bc934a6781ca7e81d8b1732eff5d3ce6ff9626ef10fa291f637b347fc5accbaa6a3aa514c9d1f3e17481198f78a905638c3b035d2bc2b2eb37a2ce728db52cd790625f80ead39f586842bbafa318935911489d2afc532850e3ce5a58628a3e5b26ffb3d677b3bb3b2e2f2bbe070b8d266ebdcb6078a99d91f62de30e313bae01dee30437b50ac4128b7aaa2941c1387aebaf75e9e8c1174f4ff60d55ac8e0904d0a532ac944187ec6a121afbf67f0817217dab6b834daedf916115baedff476edd927942086447f97efa2ab9596fad3a5f27146fd9010db301e75fa63aa13b59eff516538cd014d0e890f4ce61b12ec0911093a5715f9475616613a0e87bb4b74a7659291e5a3441c8b0e2a47c254db7b1e0ce89bd4314959ee1d6607be64efb8c68f726ebe320f37bd23b7e3f0f521c90d69e4e0fec871904623ab9bcb0729a3c137138f16f04264d091751060e815d5965010cd8801442a2e12273ee8ee3acda5b3a3d803fbf3a6449b575bc9709d406e34ae598e9df135cfbbcbb67f14718e7290a9deda5fa69acd4fdc438811eb1ccf379b1f651fcb4a98b600ccd04d3c989f50f12df122aaeb28d26ac00b747e619ac9af425199ba054edd50a9fe34eece5ab2e7f30a5cb9e12f033092ede6e732b32089056664d3d689f9c8c32b6eb99e7b78fc39079ffc385ace4489c31437ee3885a5148c4802f45492ea8c85ea9a93e68b1f9c47f56354468e7485f4b048c8ba7121c351e0f9de247c92076bb888a19eeae6265e969607f4a7a0cd308143118acf0695c8f652bb8892a815d807d34140b23e6b05df8a0edbb6fb1d2278ed78d3def8639940fa653d211f1563b8ea62e9e32ec2c12e8720b69b3ce75dfee7b3f1a6848641d7ff025ab7c0f2fdb610199f955e1f3a2d6a9cc1cdc71bc246972637119a8b21f7559c84ef9ccbc64f57839f9414f2d75ccaeea667da77fef52a560edf32653cc1e0a2084c9efd2b1261b211296276e24ad1728ca95853af4adecb9a25c8500089cb295b76b286e75f91217612a665f7b5d6d2063b55430257527ba0f1fff2c9b9a0a297c5c2864d8c96583433e733c4f760236f57a9fc41c39bebad2eb887a73cb78f9320cb234ba41b1fabe721eec26e139fec30bca7b07585881a61e569309848e4eacb33d5054768b5ef72609de43398e4678b519ac9877dd472c2e9e95e797eaa5e4828e925cbd6254dcb075011cb637b8882a61b0a543639b1e236f5c6ee2ce8022eca37c2bd36c2f854fc18260cfd1e7100586936164eac05df7315fa3ceb191cb02a4b735721f752c37eadd371710249cc9985d38c2499194492af46005b79186fbcd7e65ef92ee432dddb6c9611160efed88b995329621ca9ea511f6d45da8a806fe24f0747990e18da4b0e43c75961843bfd81b12c0cd9e92e1baa9c5b1d28a08be8679ceafb5d0597983c615f11f7395a2e9d6d21c0d65bbca7b5e78ce77ad4eb46b5bd777b4cd55bd50f851bf1ba8bb73c51fe71dfc16fe3c21723bfe3f21839b05686fd40b1dec93b780708bda84d3fd0ddd7c546d3e379151a41afc54d40738250fc581419ad49a8a9789d464fd7e1e06f2c3bb744dc52f6031801856ee14d596bcb9ed7c40d301d5efde5daed75b2febeaa9b4b07d2599a89bf64b62789f805ef798d4b769c662b834411b9ee241e0ba5393f85e5c7e4c1dd78e04463e70c23eaf6a7bb94a6b00f281230a12c8648741363c55028c2eb745c6142462d1da695dc3b508d7a5aad77c351b0dd326b59e4c5c3d10e55d749e21bd77577a93304bd059fd9c2c0660b6914154ed9abfcc635374c75a743f961b4725c6691b589f6051064fe3bb82eb2cf538297d9e6b07ddb3161ecc0cfbb73cbe71c0066fe2868e3b45d3a5dfea272088e2897ddf856b7976d27ed02dd1778384556d7f2d6a872129d512ee0621d4711e2bd7af94e80940b9db2fd4b7a51e43af953e0ba08a8f2025daa1544e4264974b0b6de78f04bcbcf6be63c032114cdc04faf1e2cb96aeda3ded28985a51c426e9d18ac52e8750653831b52a8f4df0cc002e5483ed9b05189c846d27dc5dbc3043615e3f7b646ab648f8e7b009ac45b0c9e5f86e88e44d4f4c45d7b9bc97561f7296fe4e63f9466622d8359b083be66c83912919e13eca3d2c8ab79e9099acb1e42ff212fa8398a4b805470e3bad2f87a4f9648c3b272e706527002af7b7c9fa8dd9e8f02585de3603f881f6fb7d1b97098086f022e3e988e6594ddba4973043d91d51bc5979cd5fbf26ede3a766a05e354079b4fb6729fcc47630c8fe8fdb6840482932c34182918ce265329a344edd9e75a9fe5b631b6848d04135653ed1eaf3da6663f069b674cb25a647a84869a1f09acc89ce19f0667b2915885dc82118b09fd42751ab646da4de64aeb41751758e715a3bd39e3e679177c6bcd16064ed1e1add512b33a8be46a7183b22279dc7e3c90c879c044e1a8789897f442703fb258930a3a53e3ee72d90e53bdc596f9b8b0a8536ec3e87ea6299e8d261ec0a32c7c2240f6175828dc638d2ab306020d2dae5fb99182bb16489cfe617a9d4480aacddca0dd18484cf874b72695fe9d0d4afce377b57e932647b9b22dbc85a9d25f2732fc8edf6275f0f07b6f6fd2aaf7c1cb9e57e2a645c0295a53d4a6c275819b61186c21b32a72d6a7098291f18ee3a90e260f5eda962ef02ec43e0f30fd65429f3e80bf7710e47466768b8e9da45493dee1607efd514be5eadae5dccddf13d4ca45e83dab0dad6c12089c7c808ce3b2e5c543a8d80cae957f5a9d1f8483f5d6f4297d99d58f963cc45614b205be105ce1c9427c1354c340dd9a3f804f1bdd23b1f8912fca562cf9909573a87be4c9b648e06212b85a8047ceb357e50ab4dcf3c5d46c1cfc414c5b5cfd0f26ccd1cee937d8ba10447cd7cff5f88a37a671f5303bd6f00526004f26dfdcb6f8a90cfe3916680dd032f78f987e6969c6d1fb8a14fe200a6288588faedd485df0ee0101bf1becdc4856343aa46b9348864907e738dce7d13d518128a54aeab9d5317233a6a58cdd93a6769e97ccc88f56ae605dca8635af66a4a1026271567a9bef939ad2f5780c3cfbc70fbc75fee2c44fc5493db604751cd2230a16d9fa2f7b513c8b11178e1b01956fb71a0ba061ca0a0fd1117d1e562dae59ab45d065a3454fdd80851e9c4c6538a3fa936992d18d4ca1a0df485902a859e5637a5cee3c3199b8b00059b53cf614c1466368860cb4f2c16e748fdcf4566826f68d435a7d1691f80a4924387e4b2b29bd4804d99d1b60da2d9bba0b93413116c1d2468edc78ba018d2ccdb7f5516932e906d0d5bab2899b882dd7f1d94eaf00ec7e7325fc2aeda4ae6cc52b7a2eba33bd8d65eeb3d95b2f9ad477a0eb208367f5b980f7575585bee5d9bb6b5fdc814dd0709cf6696ba6e0a62749a623dc988b0b7063f246dc06519c3f6c0de203ac7f0b55f88469d988225ea052c60f820efeee7c99baedb17dd2946d944361020bf657238386e7c1e31efd71b29d1d6ac58190b6e15c339c3d0554aea2a4248ba3c885884c3708f0dffc3ff801d5d66c4d3e5bdfc80a327f9ad912294a8038b5ab774160c28c6ee9d4f61991cb3311a5c450b80d38494f2ed52893aa9e295637f156d9c2ebe5c26730a60778e7a094328badb8af8bc5bdeeee90e92e80d7b451c1b74839a3cd68fb251713b9c7c307922fd36657ca16db9df720b9065f8bf2cc03fab9921b9ad1964b30171d9f4822d570c8462ba7b3eb9c154f331cbfa8a25072a6e63156da99027ff58adf85aaceba625a2b0a1be6efcf092bc048f7864c5888fdd87f2c11d954d1a1a9e7562855101a7f5ff8ee35e84bddfa8c4a0cf323ebff81a510c4da5f4e561353a5615870b530f7cc177f4bf29f7876c515f8f2a0c387f6d1d5bde251867e9c1623354ec51e119895c7caaf44872b50049f8685e78d45a4d3c027f26e496aabd47f877120087a230ea34eb4e91521ec0cce4f4d16384800d889da4213733b1dabf02720f08b77e58b02ff9576338d588dbd7b742fda2103628bfc46ebbb3afbc19b4f21317f686ff054ec90dd900cc8256427e5bfe722bdae8fba66d907ceafc509fcb47b3e57668b7f32fefcee161fa7de4b7577b75d2c9a2e675affbb539558362a5a3739d6a00d5a3eb959bce4d3709c6772b6840fa3587a767a6a3d1d4f5b19f8dc724f53ae8d0fbe5330e5d4554d2b0311a2a6798368136547ea5e3548eadfc5981283f7a6e2d5b1fb212f34937bb2a7d01c7ee3194dc1e352807105d56ba0fffa70d9cb86080c5329d2da19dd4c5eb06b7e9754d29e4ef58d44c44ab7d52d76532ed59f05ecd9c0b198cdafada7f35242c36f94b488bbac254b53865ddbea3fd6a3391fbfadd25bb2e6506bec9ed5bc80e9cee5b1f747349408c014dd2ed1b366dc0ad4fe971632ec9609e7af475e73e8985d11d8386f4b09387f48d5139766f3c65d717f82e2bf315e8c8ffe8e726768e7b66cd910116201f0aaa84a62c2662e4d553663efce27350f9c00146fe7f46fd874e72071a2aa0174a55b7475e813d460fd887bed1602683ed68e56af5c85e29fdffe1b159cc3ba7c94ef252ed73147556da988bf7b0105098db764ebaaf51c4ecdfc5166e363379ca44c84ccb3fdae1a04c24ecc63d4cb3b65f7a264d9ac9ebef9bb9425a40acdcab256e8e058c48141244ac4d5798e66d04b3105d2e74f96de7c9a4913b867eed741b570496e4721f091f0ec10951bac964502885680ac91ee439a596832604c3c7e4c1928009d032f041de1df7c1286a2c51b9f07ea2a22f6e53c6245a3aee2880cab23415fa662f8527af75b6d560f260d86bd054804b97c11857f0b7aef1b631072fc71e0adec332650450861f3f12276c76a455938e9f695bd52263993d46d446d02129c80e76ef85b7a6b6ca44fec1fb4d443fd9f104597446ad0b059e6af7f3a4196e359aef42baa4c436b3beca2aaaffd240e01c64d9b9e29938d5b5078cad6dd45942b3ff35567a06090fe658f88a6d1e125e528bc9dac28332c2a7208dd5a121b7797a8febfcfc87bad3b7c9f35dbb52f372373c415d8ef07c1776eacd53d3df00d8bbfbe3801ac54beb9dc0cb386699b00a764c6da5cd5aed1e6db4173b100779861a0445f188606964579e52b052e91eb15756837f57efd377d0cb70241a766996fec9ab507ad1b5bcae8fdc367b8756e67aad0cc53d5768a60f1a77076ecbfe2d500956afb56d098d00b9610f66cc038e6c3b79b89761ed51397a0908a2c4feb997c7d9b936183947355c6dee7fcd26d8c6628e3d8d23b64e595515f81947204d5c010da316e8ecf070a0faa3006caa71217a4efecfdecca8f6ccc44a085f9dc1b08fe8e598cb9391c42bb11bd497cbd6ea2a017414cec1cbfccc29a477789960c09550bbec367c3b606f99f66f16fa2a6ff6947d89049815f1f3b0e7cf0077d05a6a9485f0e2c3513853b52f36c4956777ffe5da652b1c78998bb6387c23e7564d112bb37267bcedfbd3b87f0764329402996195983426a09756f741bb7f60dc08673506da1e8bd812831d12be00a9e349f1ae04cdba3438ca523ff713cbd468ce8cecf1047f4143de583aca30b70757957f1a1500712e91d87691a405f5d98a9a286f0ede0a6af3fa8159aaa4780c0a2ec58d3c91aefcb3e34e66e247e17c754719ca394783cf15993cb46826aa35b97fd8af6f9b817ae070f733115415429a8e06353163dc59df2e0f5b0505c249202491c2881ebc3666d3b0a0914aa61d66b03c3d8efd0ca11fb3fc702690861139b249969ebc48f9ed90ce578b9d886a85c6f0a19701c136aeb1828cc8f9b614ba25c9dac3f5e01593d78c092e0f48f7107a0e74241c3674a8175f3d8f4a516c5d778c66e6002f619be774c784231d9ed39b20307699d488ecd8ad6603e99a288320eebbd714fcfb6870c5120723a8738c9aee423ef15a811bd46a43548306e8f6a692b2bc225e04095e6daaf54d2f38cbba4d689763e36af6bc4a748d1a8d84b04ec29563cba2f49640b34258cbc56805e8a7e03fc5ab674a95c179b4f5d53b7d3297e0758fecf111a737eb382408de28f41d8f95e7f5acfd975cba2231771375d37169aad44ce871d3f8cc0f1df1a2c379ffc4d68c6fed4877ddcaed16527a1400eb54ce353754bd6f72dfca827da00431b0634c126b03740914fd87bf16442d05206517ce2f70b79c0d716976b9ac22df4f8b0402102e8519e783b36058b3062ea421baa3bd4588fefd316491bed5106df5ec5453d50b712f7378ba4b2276f5545c9b03a3407e62af0d64bf1a09e060f2af8b9228b30793c8cb87aaf19e7b75ebb69348fcb367a1eaced14e57056fe8328524e86fa8036dbe694d25d3000123271241bfda1fb4bb0ef63db15948d8efaa44ba0ac06e41e703c2ad85305068caf0299833cf647a883cd00af313896457356fef7ab582c2d279416ea457a3df3f5fd2f5eaa8fab6be82424321203780941ebff130f877db8994018e08246b5147a36c42b82b503763099230eb14ec6c5095bbf413e18227facae1f1997eea145b8dd107176532ab17195fccec9e0216d037b77582f02bd3e4d3c77331cd6125664f378e23d274c700cac3fc0409cd1060ee0c8a1687b186afa74648dfffbebe6c43a3f08dd9c6894df9855a3501590508852e11fb0327f111b77a86a7fc9cf8f38461847ec1b9cdce6d44e5295c600e9239c10755808986f28764373a1a7b2285bcb54bce0307a1b664a12d440d4e28687f66958e3a2c00ca22605df6414b78ad5ba54ff696d3cee3d2c679ef5411d28265840f19d64457424bdbd53d2e53ee77cf0b97ede5f6a870154594806c55d2359e658174e6f0bf10df0bdf0c03d1505aaa0476bcec58e2ecb8d993efaae641923ff6974a0241bdc0d5253339541c537fc47e6706861cee3fcfff57f6765ece7f208c708cacef6cc32f856075749dc5cef25033717258e5e3a41bce85c8d1e22d88f2f1bda89f706dc41bec293058e83f7e16f2d310a4e48f0d97f6a7a66447fee61e041c84b4cbc19358185ea57c5daef2b67813c4e6e6075186117f8506601a465692f32789490ff14019b771d06cae608453ce94bffba3de85d5abdb1b32bfcfc5c6453557424c79fd7b6a48f052b88459fb066ca9c0f84ed20450c0b0790c91fa189347f94eef89f525ee9297efeed7b5e3947a5ee713c70ae4de7f7d6114563c2fa83ef3810ffe2525b695d7258707ad7576faf4ac04b50022d195eb39a2cc5f72f191c5dc970da531fe091639a6476e36d454abd317b270a3f298d3c4ed5d0c207ff6b469cf533c3458da3e3019d46691a7aaaefe42038e2c592b022ff6d95c537d5576f015633b5fe2ad5b01db07a61e6d5161b6f70e63a936550f3546a9b331b576bf91a2d3e2e7cf9bdf09536b2eee39da1ea14ca9baa7de6bce6bf629338e4fcbf70eb15a069ed9d0f0774450e043b1ffd456f82f2477e0c1545db014235f329a3c6cec51173a76763470698c6e279b06909b7b3dcd6e0a6be1cfb508c8929b14186b79f02ccac58204b2e8d6a76550722e81dd01b383db8ebbd796e4df27a968510926eaef34911a1a02d40b0304fa438675e0d4543c11c3614ab720faa1031412597198f17ceccd9ef5e03a4b91781065a747049afff98afa0c84b7078cb5f9575910e1a757df29e5149569451dfa03fdbab065e40fc11b301c20bd72289fb4161179696774af3bbbe99dafd2721eb1dd0287a6c221191c89b0366c901b4598f39e163358659ea7116416c697f71b5f6d6d3961d33acbc4b8cb4e41f7ba9d00096d97c4a097aa31b97f4f859ff503b903ab82612e369fd2bc920ab0250555f0b4be463b2353133d34d3b497e9177131d503c8bab5f8f7e8efe0af4097bc07db9a62ec7225cfc1133451a95c218da058821094c1c0cff3b5eeec74e704d60f36a74b61ebda8f001394d22d709715bdbd110af6150b15523335cb4b0d6fffc8a9d0af5e7702a96ccc0685104174fd4f65e177b17ea1bd4a0c93106b56a7042e2504806dedf86fe4d2f820404064a53249b5e4c0f02c18a1d660b85c93816f072bcee09f640c5c5083c41bfbd2eaa77e2e102bad452e92c83b84d3dbdb50c1cc34b2f3f3cd1612ecfee9ca9dec4670e524b4c611aabbdcfb0ea5731fc34343723bf233dd5968a7aec99f0603268ed7ea297f62aaabb6b2aa411bcc14395453150e73f6dcff03b88b0550c883ddcb79781aba65b3b86ff3792163d2458d5fb606534a9cea2d09834818a4e1e0a0dcbf5d8e2a43cf0f6fa9ffe804656873a83c62c2caa03d5cc278f1f5301c4eaeb805563189c32d3da528f3f90d0e53710c59b93a4dae044d52b7e6e936b8db3a60c1a4c2b37c2afba655e8ee4eb9753f13733b2be030d5e4c413ef042c0d8be4b93293ba8b5beeae42a20a62f67cff349f73d1fcbb60483a4922fd3d102787e9c090d82cb7eee96e8b50ecf28ae0f8f79d1246c93b0f5e8deebf4c297024858c4c9cdc8daecf10156284e5b0001f7230ac1fb0e841e44b095a1838005335b3194ad8ee00bf74b6521a8335ddd83c302cf2279a1405b336001e2d3c79e1fc8450c2da2fb4bdb9a7dc70a39dfa5f44cfc0722641610f006b4161dd7e099e53c9c825caa72c97072b150c796ec6732beaef2cc3b50debc0e28601aa4b6b8b76fc91b2eb9fbe806079caccf2785b2f6bc1a920c5e38622ac4c582c3f1f3a9f5236b53cd19b84c7a2de06a4743529abd286195031862dd75806825c5089098c4ec9b8103df5c39cfa39829aacf4864f36322238bb59e1a1a0a684e9707a51c2303d9584323011e3723df762e935e603d1fd194d837ceb728580f7c67eefece80e6504b07873bd03102756581a620e4763e37cc6a56f14707b7e12e14e4b0bfe19bd73a06f08e4ed2bb3b47c78619ffc4fa62fc6ce0c97c77d664919486efb0f236e8fec8a006f6705f84c4bfdbe1be966150fd413c24228d6abb493e0b27e87acb30cf848e3e5685da5a3cfc1f57a1ded4dedcb1d5a678561ab7234e96cf7d70aaab875204c8dbe82967bd524540e5d7456c19f9c2a9dda17322ec6c59c77745061a81bc137133c157824a213d05d78127cc070f172d897d39cbf97d79d37432117d3cafb9564e10cb4b3d00213962537176d3f8dd2307ebf23e184b7675848f3669fd022a7e3bae6b0ad8e8266ced14e5079e4606c70e82a55cfed9ddc398f19083869f90dd8f58c6ad6b1c3de1ca8c7862ed7fa93897d4a6b324315cf4c72628a37afb8fcf833072b7417390dacc19e7f4dd55956af47b5500d4dd61dbacdc965dae466dc850c6727d48f9c5d6998ae17a9e21c2c80cdc5a1cd58cd3585b004bd1f69e57581da68624966b5105146e83878f6c387834f58a627abca92cbec9515d2ee596dceaf23dd9798d81f699deb5d2a915df42215513f317659bb6ad4ded49591b43e2390e714316b8b83882ce4e14e2cd4381d4f98dda3a239b842379fc18036edd138fd74e7421eb852cdfec05641b6448ceee3f9fc5a4a31a338e3544808a901ef87ea099ee11e0ecc4f73e62f83eed04a2b35181504aa2222527901559fba0b11e28b217d75b11ac91317286146bb84a806881b87bf0a1a07598508a4b28f604a9abe449af75dd39240b212c48a96eaac7a873ed14330a41c2999fcd2c0dc13aeef1584c5dbb1150d32822a030b51989d0f0dc124425acf7f20acc6b332b920c540ea71341b60b4f5e80441196e0e607b4b07bc4b56164a2b74eb1d578862c0588bf76b046c19911fbfa315617c65680cf739097da5c89798316def9282a7dd6dcabcfee03bcb18ee492a12e9951c033e46f462a285458974228342b459f27f7263c18f59338dcb1640b297b5d6a8a8e755cd3d032f4fcf6465b5bae71e1ebd4d71e04a50525b6e360e70c6bec485e5b84576aa62d68041ec1b2492c868feb6cc69bbcbf6b35e6cecb98fe112e12edc794fcca581830abb9fa45344359755ad318f73b5ccdfae772e203b6c9345d917df5fa9c61ae7c9b05435304ee1e8d4035c4b63af2f7ebc23f347bbed722279bdfd885da2692364c6a7bdc67f15ddf2ddad2f0a40c92b07a446be5d1cc8d66cba91ff8770eee5d237dc0ff8b8d541a157ed0d4e855c2efb88270d6a9e83124135e419d1383937069134ddb1e27e0bfa6c6f644d130e6c2c35ce3fb78328219cb1b50d22e50410f350654a3722f8efece1d770ecce4c5905d35f150551072bf4dc46654ae5314d44e1ad50ab3b0b3f22842a45a6f935582565fb42671b34b01d350175491cb0bcc89c3034001bec3ca0dc6f95ddf7042a45be506c0079a7216630d4691455685cee142308c686bce9b7792bdb6a519c944d1037b5864a8212ddc48d72d54b4fec2d990a24e23040473f546a6d33d612044d4785c90accbadeaa1425ff1431938cfa4770417f9cf9f55063db2332accf5bee4db7807d2a1650a74a01d25ba1f1c7a0cd303e82cab0bb04dd690c0b7d1a502c9173cc7c5852205e61a09221ea99ab0f37bb61622e870bfa078388c7ee0a33ad5078e21a429f56535d60f2e3b273e51c62918f37856b991b940f94308e2484c5510767bda6d21038f8de17678b00dbd6af8de39c0354cf68a6f53ac0dddc07d68c0661d1781489c0aa790bef3523333c0b0f41b09b79e43945a7a80fbf8869ca075e0f75e4d98cea2292b1fdaea642fdbf4f46b3831e478cbd6a3b6f3e04dd017d893cb2bec1c657ff56f83c1156282f236a2816fd63e92b3a8fecbb264e2145775ca56b3339040df08f60cc9a4e8f4d3f162bd09eb6baee707ba2442274f070b891bbb1084f5eebc6293734fcbef195cb93277209f314ce95df5ffe73bbec947823b36509d83c3a57364ceaaf6bc6dd9337e95902e2231910af2e29962c5cfaf215aa10ab6845163e5286ba1daefa841447e9098ec0136e0eb1fc1cc188e605c1de4b6572e2b8d760dca9fb0f56c066fcbb56ccedd1517c150eb653abe6852557ce23c7319d9ca85b7f87dfd10667de76991e7cb886fa45a5e410ab3338f719e86d96036c368cb927d5e50d2757a42c095878c5d25d953348aac8514e6fbf3ab2ef66365b35b27c26f0e8c4fd4b6b1e2b1bec8646ef18b4d37501da40892f5ba15858b7237dfc8f3bc0b532142bc98f1417d37179bda42b69f2e6477cfbc07e8e28496a67c06adab22b791fe1e57b6758a9235d3c3f7ec75cebde9910b25f3a88874820527afa139c29e9208d247731a28e22b2eb38ffcef34685c41e00e0ffb30d76d5e03434da5612b8d4b1f82a000c7e89caa201a6917f4b8b6a405214bc972d4b6264d3483b327ae08bf66deb2bbeb3b505a831fffd746cecb5ce5d9b25d4e4e8736fb5cbbf2cc7301fdc1c8cd71ac583202150438334de2d7fe3336e9a2a98edb4c59cd050bedc749628f450e07db9538dd302184e2619ca2fb99b06712750407c1a510edfcab6e0f5bc0dbeb6e130ee9a4c9492e17a1e0202d108ac9f3bfec887b251df2dad1b460685727d5deda191fa5ed2fd05f6147be553b4a84ddaea82c50b0cbf3a1a577a898d5b22c3a275f426682270e2075ad58f774d0c9f90a90094700428d0ffc3aaff0d4df3d844475497a406eac3f66e058bf8ac28423217638d4f0d6389ceca903b6fac6f19c41960fa18d3490c733dd5f10da6054f7ed9016d6249770456f2043b56553f99d8a415fac548dbacfe7a156ddd50a358fe38547afa4c7e990ccc9841b6eb76e90be4fa10f824ebec121236a457bc8aa90004e4c44837a1eb008538df0aec3b5656d6f11aefcfc7c0c198e168cf02c7e27fcfcb615ba80f31654765a226ad3ef1c9bd6d358596e2b41119f6f8045de52079b74d3c157f1ebbb48446dc5be3e12da3d9207efc2e5913c866e18d13bda837b84980428e50861769a8dbaee93c2dfc4248746149741b546a171122eabefca85ce0a5db1f59c1167d9e0946a4d4f710819037c2fed4df11e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tool】Static Analysis Tool (CppCheck)</title>
    <url>/blog/ToolCppCheck/</url>
    <content><![CDATA[<h2 id="CppCheck有什么用？"><a href="#CppCheck有什么用？" class="headerlink" title="CppCheck有什么用？"></a>CppCheck有什么用？</h2><p><code>CppCheck</code>是一个开源的静态代码分析工具，用于C和C++代码的错误检查。它的主要目的是检测编程错误和未被其他编译器警告捕获的潜在问题。以下是<code>CppCheck</code>的主要用途和特点：</p>
<ol>
<li><strong>错误检测</strong>：<code>CppCheck</code>可以识别很多常见的C&#x2F;C++编程错误，如数组越界、未初始化的变量、内存泄漏等。</li>
<li><strong>可扩展性</strong>：用户可以编写自己的检查规则，使其适应特定的编码风格或项目要求。</li>
<li><strong>不依赖于特定的编译器</strong>：这意味着你可以在任何系统上使用<code>CppCheck</code>，不管你使用的是哪种编译器。</li>
<li><strong>命令行工具</strong>：它可以轻松地集成到持续集成系统和其他自动化构建流程中。</li>
<li><strong>支持GUI</strong>：除了命令行工具，<code>CppCheck</code>还提供了一个图形用户界面，使其使用更为方便。</li>
<li><strong>无假阳性的目标</strong>：尽管在实践中完全实现这一目标是非常困难的，但<code>CppCheck</code>的设计目标是尽量减少假阳性（即误报为错误的正确代码）。</li>
<li><strong>性能</strong>：与其他静态分析工具相比，<code>CppCheck</code>通常更快。</li>
</ol>
<p>这玩意可以帮助开发者提前发现和修复潜在的代码问题，但是，静态代码分析工具并不是万能的，它不能替代其他测试和质量保证方法，可以作为软件开发过程中的一个有价值的工具。</p>
<h2 id="Use-CppCheck-windows"><a href="#Use-CppCheck-windows" class="headerlink" title="Use CppCheck (windows)"></a>Use CppCheck (windows)</h2><blockquote>
<p>下载地址：<a href="https://sourceforge.net/projects/cppcheck/files/cppcheck/2.12/">https://sourceforge.net/projects/cppcheck/files/cppcheck/2.12/</a></p>
</blockquote>
<p>下载安装后，打开软件，点击分析，选择需要检查的文件或目录即可。（必须英文目录）</p>
<p><img src="/picture/tech/cppcheck/cppcheck1.png"></p>
<p>分析完成后，点击即可查看，若有错误警告都会显示，此处实例无警告和错误~</p>
<p><img src="/picture/tech/cppcheck/cppcheck2.png"></p>
<h2 id="Use-CppCheck-linux"><a href="#Use-CppCheck-linux" class="headerlink" title="Use CppCheck (linux)"></a>Use CppCheck (linux)</h2><blockquote>
<p>安装：sudo apt install cppcheck</p>
</blockquote>
<ul>
<li><strong>基本用法：</strong><ul>
<li>扫描单个文件：<code>cppcheck yourfile.cpp</code></li>
<li>扫描目录：<code>cppcheck your_directory/</code></li>
</ul>
</li>
<li><strong>详细输出：</strong><code>cppcheck --enable=all yourfile.cpp</code></li>
<li><strong>输出到文件：</strong><ul>
<li><code>cppcheck yourfile.cpp --output-file=output.txt</code></li>
<li><code>cppcheck yourfile.cpp &gt; output.txt</code></li>
</ul>
</li>
<li><strong>检查所有配置：</strong><code>cppcheck --force yourfile.cpp</code></li>
<li><strong>为C&#x2F;C++指定不同标准：</strong><code>cppcheck --std=c11 --std=c++11 yourfile.cpp</code></li>
<li><strong>其他请查看help：</strong><code>cppcheck --help</code></li>
</ul>
<p>例如执行<code>cppcheck 99-carController/ --output-file=output.txt --force --enable=all</code>后输出了<code>output.txt</code>。</p>
<p><img src="/picture/tech/cppcheck/cppcheck3.png"></p>
<h2 id="常见警告和其意义"><a href="#常见警告和其意义" class="headerlink" title="常见警告和其意义"></a>常见警告和其意义</h2><ul>
<li><strong>[style]</strong>: 表示代码风格建议，例如未使用的变量。</li>
<li><strong>[error]</strong>: 表示可能的错误，例如空指针解引用。</li>
<li><strong>[warning]</strong>: 表示可能的逻辑或运行时问题。</li>
<li><strong>[performance]</strong>: 表示可能影响程序性能的代码。</li>
<li><strong>[portability]</strong>: 表示可能在不同编译器或平台上导致问题的代码。</li>
<li><strong>[information]</strong>: 提供有关代码或其结构的一般信息</li>
</ul>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
</search>
